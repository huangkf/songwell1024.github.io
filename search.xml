<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[freemarker基础知识总结]]></title>
    <url>%2F2018%2F08%2F20%2Ffreemarker%2F</url>
    <content type="text"><![CDATA[Freemaker FTL指令常用标签及语法注意：使用freemaker，要求所有标签必须闭合，否则会导致freemaker无法解析。 freemaker注释:&lt;#– 注释内容 –&gt;格式部分,不会输出 ———————————- 基础语法 ———————————- 1、字符输出12345$&#123;emp.name?if_exists&#125; // 变量存在，输出该变量，否则不输出$&#123;emp.name!&#125; // 变量存在，输出该变量，否则不输出$&#123;emp.name?default(&quot;xxx&quot;)&#125; // 变量不存在，取默认值xxx $&#123;emp.name!&quot;xxx&quot;&#125; // 变量不存在，取默认值xxx 常用内部函数： 12345$&#123;&quot;123&lt;br&gt;456&quot;?html&#125; // 对字符串进行HTML编码，对html中特殊字符进行转义$&#123;&quot;str&quot;?cap_first&#125; // 使字符串第一个字母大写 $&#123;&quot;Str&quot;?lower_case&#125; // 将字符串转换成小写 $&#123;&quot;Str&quot;?upper_case&#125; // 将字符串转换成大写$&#123;&quot;str&quot;?trim&#125; // 去掉字符串前后的空白字符 字符串的两种拼接方式拼接： 12$&#123;&quot;hello$&#123;emp.name!&#125;&quot;&#125; // 输出hello+变量名$&#123;&quot;hello&quot;+emp.name!&#125; // 使用+号来连接，输出hello+变量名 可以通过如下语法来截取子串: 1234567891011&lt;#assign str = &quot;abcdefghijklmn&quot;/&gt;// 方法1$&#123;str?substring(0,4)&#125; // 输出abcd// 方法2$&#123;str[0]&#125;$&#123;str[4]&#125; // 结果是ae$&#123;str[1..4]&#125; // 结果是bcde// 返回指定字符的索引$&#123;str?index_of(&quot;n&quot;)&#125; 2、日期输出1$&#123;emp.date?string(&apos;yyyy-MM-dd&apos;)&#125; //日期格式 3、数字输出(以数字20为例)12345678910111213$&#123;emp.name?string.number&#125; // 输出20$&#123;emp.name?string.currency&#125; // ￥20.00 $&#123;emp.name?string.percent&#125; // 20%$&#123;1.222?int&#125; // 将小数转为int，输出1&lt;#setting number_format=&quot;percent&quot;/&gt; // 设置数字默认输出方式(&apos;percent&apos;,百分比)&lt;#assign answer=42/&gt; // 声明变量 answer 42#&#123;answer&#125; // 输出 4,200%$&#123;answer?string&#125; // 输出 4,200%$&#123;answer?string.number&#125; // 输出 42$&#123;answer?string.currency&#125; // 输出 ￥42.00$&#123;answer?string.percent&#125; // 输出 4,200%#&#123;answer&#125; // 输出 42 123数字格式化插值可采用#&#123;expr;format&#125;形式来格式化数字,其中format可以是:mX:小数部分最小X位MX:小数部分最大X位 123456789如下面的例子:&lt;#assign x=2.582/&gt;&lt;#assign y=4/&gt;#&#123;x; M2&#125; // 输出2.58#&#123;y; M2&#125; // 输出4#&#123;x; m2&#125; // 输出2.58#&#123;y; m2&#125; // 输出4.0#&#123;x; m1M2&#125; // 输出2.58#&#123;x; m1M2&#125; // 输出4.0 4、申明变量12&lt;#assign foo=false/&gt; // 声明变量,插入布尔值进行显示,注意不要用引号$&#123;foo?string(&quot;yes&quot;,&quot;no&quot;)&#125; // 当为true时输出&quot;yes&quot;,否则输出&quot;no&quot; 申明变量的几种方式 1234567891011&lt;#assign name=value&gt; &lt;#assign name1=value1 name2=value2 ... nameN=valueN&gt; &lt;#assign same as above... in namespacehash&gt;&lt;#assign name&gt; capture this &lt;/#assign&gt;&lt;#assign name in namespacehash&gt; capture this &lt;/#assign&gt; 5、比较运算符表达式中支持的比较运算符有如下几个:= 或 == ：判断两个值是否相等.!= ：判断两个值是否不等.> 或 gt ：判断左边值是否大于右边值>= 或 gte ：判断左边值是否大于等于右边值&lt; 或 lt ：判断左边值是否小于右边值&lt;= 或 lte ：判断左边值是否小于等于右边值 6、算术运算符FreeMarker表达式中完全支持算术运算,FreeMarker支持的算术运算符包括:+, - , * , / , %注意：（1）、运算符两边必须是数字（2）、使用+运算符时,如果一边是数字,一边是字符串,就会自动将数字转换为字符串再连接,如:${3 + “5”},结果是:35 7、逻辑运算符逻辑运算符有如下几个:逻辑与:&amp;&amp;逻辑或:||逻辑非:!逻辑运算符只能作用于布尔值,否则将产生错误 8、FreeMarker中的运算符优先级如下(由高到低排列):①、一元运算符:!②、内建函数:?③、乘除法:*, / , %④、加减法:- , +⑤、比较:&gt; , &lt; , &gt;= , &lt;= (lt , lte , gt , gte)⑥、相等:== , = , !=⑦、逻辑与:&amp;&amp;⑧、逻辑或:||⑨、数字范围:..实际上,我们在开发过程中应该使用括号来严格区分,这样的可读性好,出错少 9、if 逻辑判断（注意：elseif 不加空格）123456789&lt;#if condition&gt;...&lt;#elseif condition2&gt;...&lt;#elseif condition3&gt;...&lt;#else&gt;...&lt;/#if&gt; if 空值判断 123456789// 当 photoList 不为空时&lt;#if photoList??&gt;...&lt;/#if&gt; 值得注意的是,$&#123;..&#125;只能用于文本部分,不能用于表达式,下面的代码是错误的:&lt;#if $&#123;isBig&#125;&gt;Wow!&lt;/#if&gt;&lt;#if &quot;$&#123;isBig&#125;&quot;&gt;Wow!&lt;/#if&gt;// 正确写法&lt;#if isBig&gt;Wow!&lt;/#if&gt; 10、switch (条件可为数字，可为字符串)12345678910111213&lt;#switch value&gt; &lt;#case refValue1&gt; ....&lt;#break&gt; &lt;#case refValue2&gt; ....&lt;#break&gt; &lt;#case refValueN&gt; ....&lt;#break&gt; &lt;#default&gt; .... &lt;/#switch&gt; 11、集合 &amp; 循环12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 遍历集合:&lt;#list empList! as emp&gt; $&#123;emp.name!&#125;&lt;/#list&gt;// 可以这样遍历集合:&lt;#list 0..(empList!?size-1) as i&gt; $&#123;empList[i].name!&#125;&lt;/#list&gt;// 与jstl循环类似,也可以访问循环的状态。empList?size // 取集合的长度emp_index: // int类型，当前对象的索引值 emp_has_next: // boolean类型，是否存在下一个对象// 使用&lt;#break&gt;跳出循环&lt;#if emp_index = 0&gt;&lt;#break&gt;&lt;/#if&gt;// 集合长度判断 &lt;#if empList?size != 0&gt;&lt;/#if&gt; // 判断=的时候,注意只要一个=符号,而不是==&lt;#assign l=0..100/&gt; // 定义一个int区间的0~100的集合，数字范围也支持反递增,如100..2&lt;#list 0..100 as i&gt; // 等效于java for(int i=0; i &lt;= 100; i++) $&#123;i&#125;&lt;/#list&gt;// 截取子集合：empList[3..5] //返回empList集合的子集合,子集合中的元素是empList集合中的第4-6个元素// 创建集合：&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as x&gt;// 集合连接运算,将两个集合连接成一个新的集合&lt;#list [&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;] + [&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期天&quot;] as x&gt;// 除此之外,集合元素也可以是表达式,例子如下:[2 + 2, [1, 2, 3, 4], &quot;whatnot&quot;]// seq_contains：判断序列中的元素是否存在&lt;#assign x = [&quot;red&quot;, 16, &quot;blue&quot;, &quot;cyan&quot;]&gt; $&#123;x?seq_contains(&quot;blue&quot;)?string(&quot;yes&quot;, &quot;no&quot;)&#125; // yes$&#123;x?seq_contains(&quot;yellow&quot;)?string(&quot;yes&quot;, &quot;no&quot;)&#125; // no$&#123;x?seq_contains(16)?string(&quot;yes&quot;, &quot;no&quot;)&#125; // yes$&#123;x?seq_contains(&quot;16&quot;)?string(&quot;yes&quot;, &quot;no&quot;)&#125; // no// seq_index_of：第一次出现的索引&lt;#assign x = [&quot;red&quot;, 16, &quot;blue&quot;, &quot;cyan&quot;, &quot;blue&quot;]&gt; $&#123;x?seq_index_of(&quot;blue&quot;)&#125; // 2// sort_by：排序（升序）&lt;#list movies?sort_by(&quot;showtime&quot;) as movie&gt;&lt;/#list&gt;// sort_by：排序（降序）&lt;#list movies?sort_by(&quot;showtime&quot;)?reverse as movie&gt;&lt;/#list&gt;// 具体介绍：// 不排序的情况：&lt;#list movies as moive&gt; &lt;a href=&quot;$&#123;moive.url&#125;&quot;&gt;$&#123;moive.name&#125;&lt;/a&gt;&lt;/#list&gt;//要是排序，则用&lt;#list movies?sort as movie&gt; &lt;a href=&quot;$&#123;movie.url&#125;&quot;&gt;$&#123;movie.name&#125;&lt;/a&gt;&lt;/#list&gt;// 这是按元素的首字母排序。若要按list中对象元素的某一属性排序的话，则用&lt;#list moives?sort_by([&quot;name&quot;]) as movie&gt; &lt;a href=&quot;$&#123;movie.url&#125;&quot;&gt;$&#123;movie.name&#125;&lt;/a&gt;&lt;/#list&gt;//这个是按list中对象元素的[name]属性排序的，是升序，如果需要降序的话，如下所示：&lt;#list movies?sort_by([&quot;name&quot;])?reverse as movie&gt; &lt;a href=&quot;$&#123;movie.url&#125;&quot;&gt;$&#123;movie.name&#125;&lt;/a&gt;&lt;/#list&gt; 12、Map对象123456789// 创建map&lt;#assign scores = &#123;&quot;语文&quot;:86,&quot;数学&quot;:78&#125;&gt;// Map连接运算符&lt;#assign scores = &#123;&quot;语文&quot;:86,&quot;数学&quot;:78&#125; + &#123;&quot;数学&quot;:87,&quot;Java&quot;:93&#125;&gt;// Map元素输出emp.name // 全部使用点语法emp[&quot;name&quot;] // 使用方括号 13、FreeMarker支持如下转义字符:\” ：双引号(u0022)\’ ：单引号(u0027)\ ：反斜杠(u005C)\n ：换行(u000A)\r ：回车(u000D)\t ：Tab(u0009)\b ：退格键(u0008)\f ：Form feed(u000C)\l ：&lt;\g ：&gt;\a ：&amp;\{ ：{\xCode ：直接通过4位的16进制数来指定Unicode码,输出该unicode码对应的字符. 如果某段文本中包含大量的特殊符号,FreeMarker提供了另一种特殊格式:可以在指定字符串内容的引号前增加r标记,在r标记后的文件将会直接输出.看如下代码:${r”${foo}”} // 输出 ${foo}${r”C:/foo/bar”} // 输出 C:/foo/bar 14、include指令123456// include指令的作用类似于JSP的包含指令:&lt;#include &quot;/test.ftl&quot; encoding=&quot;UTF-8&quot; parse=true&gt;// 在上面的语法格式中,两个参数的解释如下:encoding=&quot;GBK&quot; // 编码格式parse=true // 是否作为ftl语法解析,默认是true，false就是以文本方式引入,注意:在ftl文件里布尔值都是直接赋值的如parse=true,而不是parse=&quot;true&quot; 15、import指令123// 类似于jsp里的import,它导入文件，然后就可以在当前文件里使用被导入文件里的宏组件&lt;#import &quot;/libs/mylib.ftl&quot; as my&gt;// 上面的代码将导入/lib/common.ftl模板文件中的所有变量,交将这些变量放置在一个名为com的Map对象中，&quot;my&quot;在freemarker里被称作namespace 17、compress 压缩1234// 用来压缩空白空间和空白的行 &lt;#compress&gt; ... &lt;/#compress&gt; 1234567&lt;#t&gt; // 去掉左右空白和回车换行 &lt;#lt&gt;// 去掉左边空白和回车换行 &lt;#rt&gt;// 去掉右边空白和回车换行 &lt;#nt&gt;// 取消上面的效果 18、escape,noescape 对字符串进行HTML编码1234567891011// escape指令导致body区的插值都会被自动加上escape表达式,但不会影响字符串内的插值,只会影响到body内出现的插值,使用escape指令的语法格式如下:&lt;#escape x as x?html&gt; First name: $&#123;firstName&#125; &lt;#noescape&gt;Last name: $&#123;lastName&#125;&lt;/#noescape&gt; Maiden name: $&#123;maidenName&#125; &lt;/#escape&gt;// 相同表达式First name: $&#123;firstName?html&#125; Last name: $&#123;lastName&#125; Maiden name: $&#123;maidenName?html&#125; ———————————- 高级语法 ———————————-1、global全局赋值语法123456789&lt;#global name=value&gt; &lt;#global name1=value1 name2=value2 ... nameN=valueN&gt; &lt;#global name&gt; capture this &lt;/#global&gt;// 利用这个语法给变量赋值，那么这个变量在所有的namespace中是可见的，如果这个变量被当前的assign语法覆盖如&lt;#global x=2&gt;&lt;#assign x=1&gt;在当前页面里x=2将被隐藏，或者通过$&#123;.globals.x&#125; 来访问 2、setting 语法123456789101112131415// 用来设置整个系统的一个环境 locale // zh_CN 中文环境number_format boolean_format date_format , time_format , datetime_format time_zone classic_compatible// 例1：&lt;#setting number_format=&quot;percent&quot;/&gt; // 设置数字默认输出方式(&apos;percent&apos;,百分比)// 例2：// 假如当前是匈牙利的设置，然后修改成美国$&#123;1.2&#125; // 输出1,2&lt;#setting locale=&quot;en_US&quot;&gt; $&#123;1.2&#125; // 输出1.2,因为匈牙利是采用&quot;, &quot;作为十进制的分隔符，美国是用&quot;. &quot; 3、macro宏指令例子1： 12345678910&lt;#-- 定义宏 --&gt;&lt;#macro test foo bar=&quot;Bar&quot; baaz=-1&gt; Text: $&#123;foo&#125;, $&#123;bar&#125;, $&#123;baaz&#125;&lt;/#macro&gt;&lt;#-- 使用宏 --&gt;&lt;@test foo=&quot;a&quot; bar=&quot;b&quot; baaz=5*5/&gt; // 输出：Text: a, b, 25&lt;@test foo=&quot;a&quot; bar=&quot;b&quot;/&gt; // 输出：Text: a, b, -1&lt;@test foo=&quot;a&quot; baaz=5*5-2/&gt; // 输出：Text: a, Bar, 23&lt;@test foo=&quot;a&quot;/&gt; // 输出：Text: a, Bar, -1 例子2： 1234567891011&lt;#-- 定义一个循环输出的宏 --&gt;&lt;#macro list title items&gt; $&#123;title&#125; &lt;#list items as x&gt; *$&#123;x&#125; &lt;/#list&gt; &lt;/#macro&gt; &lt;#-- 使用宏 --&gt;&lt;@list items=[&quot;mouse&quot;, &quot;elephant&quot;, &quot;python&quot;] title=&quot;Animals&quot;/&gt;// 输出Animals *mouse *elephant *python 例子3： 123456789101112131415&lt;#-- 嵌套宏 --&gt;&lt;#macro border&gt; &lt;table&gt; &lt;#nested&gt; &lt;/table&gt;&lt;/#macro&gt;&lt;#-- 嵌套宏使用 --&gt;&lt;@border&gt; &lt;tr&gt;&lt;td&gt;hahaha&lt;/td&gt;&lt;/tr&gt;&lt;/@border&gt; 输出结果：&lt;table&gt; &lt;tr&gt;&lt;td&gt;hahaha&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 例子4：在nested指令中使用循环变量时,可以使用多个循环变量,看如下代码: 12345678910111213141516&lt;#-- 循环嵌套宏 --&gt;&lt;#macro repeat count&gt; &lt;#list 1..count as x&gt; &lt;#nested x, x/2, x==count&gt; // 使用nested指令时指定了三个循环变量 &lt;/#list&gt;&lt;/#macro&gt;&lt;#-- 使用宏 --&gt;&lt;@repeat count = 4; c, halfc, last&gt; $&#123;c&#125;. $&#123;halfc&#125;&lt;#if last&gt; Last!&lt;/#if&gt;&lt;/@repeat&gt;// 输出结果：// 1. 0.5// 2. 1// 3. 1.5// 4. 2 Last! freemarker 宏嵌套nested 的使用: 4、结束macro指令1234567891011// return指令用于结束macro指令&lt;#-- 创建宏 --&gt;&lt;#macro book&gt; spring &lt;#return&gt; j2ee&lt;/#macro&gt;&lt;#-- 使用宏 --&gt;&lt;@book /&gt;// 上面的代码输出:spring,而j2ee位于return指令之后,不会输出.]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分别使用原生Ajax 和Jquery的方式发送请求]]></title>
    <url>%2F2018%2F08%2F19%2FAjaxAndJquery%2F</url>
    <content type="text"><![CDATA[分别使用原生Ajax 和Jquery的方式发送请求Ajax 是什么? “Asynchronous Javascript And XML”（异步JavaScript和XML）， 并不是新的技术，只是把原有的技术，整合到一起而已。 12341.使用CSS和XHTML来表示。2. 使用DOM模型来交互和动态显示。3.使用XMLHttpRequest来和服务器进行异步通信。4.使用javascript来绑定和调用。 有什么用? 咱们的网页如果想要刷新局部内容。 那么需要重新载入整个网页。用户体验不是很好。 就是为了解决局部刷新的问题。 保持其他部分不动，只刷新某些地方。 内部原理诚如前面所说的， Ajax 并不是一项新技术。而是包装了现有的技术，然后使用他们来完成工作而已。 那么现在给大家举个例子， 还是以咱们的判断用户名是否已被注册为例。 传统方式： 123451. 输入用户名，2. 点击一个按钮，校验。3. 把数据提交给服务器4. 服务器在后台帮助我们完成校验，并且反馈信息。5. 我们在浏览器上提示用户，给出结果 Ajax方式： 123456789ajax方式与前面的方式其实从要做的事情来说，是一样的。 ajax也没有牛到，不用去访问服务器就知道你的用户名是否已被占用。那么它是如何工作的呢?1. 通过JS 获取咱们的输入框文本内容 document.getElementById(&quot;username&quot;).value2. 通过XmlHttpRequest 去执行请求。 XmlHttpRequest 其实就是 XML + http + Request 的组合。3. 请求结束后，收到结果， 再使用 js 去完成提示。 4. 可以在顺便配合 css 样式来增加提示效果。 Ajax 的请求/响应与服务器上的 Web 应用程序打交道的是 JavaScript 技术，而不是直接提交给那个应用程序的 HTML 表单。发出请求如何使用XMLHttpRequest 对象?首先–需要一个能够调用JavaScript 方法 的Web 页面 。接下来就是在所有 Ajax 应用程序中基本都雷同的流程： 1、从 Web 表单中获取需要的数据。2、建立要连接的 URL。3、打开到服务器的连接。4、设置服务器在完成后要运行的函数。5、发送请求。 数据请求 Get123456789101112131415161718192021222324252627282930313233343536373839//创建对象function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125; //2.发送请求 //执行get请求 function get() &#123; //1. 创建xmlhttprequest 对象 var request = ajaxFunction(); //2. 发送请求。 // http://localhost:8080/day16/demo01.jsp //http://localhost:8080/day16/DemoServlet01 /* 参数一： 请求类型 GET or POST 参数二： 请求的路径 参数三： 是否异步， true or false */ request.open(&quot;GET&quot; ,&quot;/day16/DemoServlet01&quot; ,true ); request.send();&#125; 12345678910111213141516171819202122如果发送请求的同时，还想获取数据，那么代码如下//执行get请求function get() &#123; //1. 创建xmlhttprequest 对象 var request = ajaxFunction(); //2. 发送请求 request.open(&quot;GET&quot; ,&quot;/day16/DemoServlet01?name=aa&amp;age=18&quot; ,true ); //3. 获取响应数据 注册监听的意思。 一会准备的状态发生了改变，那么就执行 = 号右边的方法 request.onreadystatechange = function()&#123; //前半段表示 已经能够正常处理。 再判断状态码是否是200，已经处理请求 if(request.readyState == 4 &amp;&amp; request.status == 200)&#123; //弹出响应的信息 alert(request.responseText); &#125; &#125; request.send();&#125; 数据请求 Post1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script type=&quot;text/javascript&quot;&gt;//1. 创建对象function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125;function post() &#123; //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open( &quot;POST&quot;, &quot;/day16/DemoServlet01&quot;, true ); //如果不带数据，写这行就可以了 //request.send(); //如果想带数据，就写下面的两行 //如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); //带数据过去 ， 在send方法里面写表单数据。 request.send(&quot;name=aobama&amp;age=19&quot;);&#125;&lt;/script&gt; 1234567891011121314151617181920//需要获取数据function post() &#123; //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open( &quot;POST&quot;, &quot;/day16/DemoServlet01&quot;, true ); //想获取服务器传送过来的数据， 加一个状态的监听。 request.onreadystatechange=function()&#123; if(request.readyState==4 &amp;&amp; request.status == 200)&#123; alert(&quot;post：&quot;+request.responseText); &#125; &#125; //如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); //带数据过去 ， 在send方法里面写表单数据。 request.send(&quot;name=aobama&amp;age=19&quot;); &#125; JQuery的方式实现请求与相应load123&lt;a href=&quot;&quot; onclick=&quot;load()&quot;&gt;使用JQuery执行load方法&lt;/a&gt;有两次刷新， 先走 onClick的方法，取到数据回来之后，赋值显示。 接着 走 href=&quot;&quot;的路径，但是这个属性没有给值，所以会把当前的页面重新再刷新一次。所以导致看不见值。 12345//找到这个元素， 去执行加载的动作， 加载/day16/DemoServlet02 ， 得到的数据，赋值显示$(&quot;#aaa&quot;).load(&quot;/day16/DemoServlet02&quot; , function(responseText , statusTXT , xhr) &#123; //找到id为text01的元素， 设置它的value属性值为 responseText 对应的值 $(&quot;#aaa&quot;).val(responseText); &#125;); Get123$.get(&quot;/day16/DemoServlet02&quot; , function(data ,status) &#123; $(&quot;#div01&quot;).text(data); &#125;); 赋值显示 val(“aa”); 只能放那些标签带有value属性 html(“aa”); —写html代码 text(“aa”); 其实没有什么区别，如果想针对这分数据做html样式处理，那么只能用html() post123456function post() &#123; $.post("/day16/DemoServlet02", &#123;name:"zhangsan",age:18&#125;,function(data,status) &#123; //想要放数据到div里面去。 --- 找到div $("#div01").html(data); &#125;); &#125; load &amp; get&amp;post比较 load $(“#元素id”).load(url地址); 1$(&quot;#div1&quot;).load(serlvet); ---&gt; 使用的get请求，回来赋值的时候， 使用text（）;去赋值 get 语法格式 ： $.get(URL,callback); 123使用案例： $.get(&quot;/day16/DemoServlet02&quot; , function(data ,status) &#123; $(&quot;#div01&quot;).text(data);&#125;); post 语法格式：$.post(URL,data,callback); 123456function post() &#123; $.post(&quot;/day16/DemoServlet02&quot;, &#123;name:&quot;zhangsan&quot;,age:18&#125;,function(data,status) &#123; //想要放数据到div里面去。 --- 找到div $(&quot;#div01&quot;).html(data); &#125;);&#125; 使用JQuery去实现校验用户名1234567891011121314151617function checkUserName() &#123; //1. 获取输入框的内容 var name = $(&quot;#name&quot;).val(); //2. 发送请求 $.post(&quot;/day16/CheckUserNameServlet&quot; , &#123;name:name&#125; , function(data , status)&#123; //alert(data); if(data == 1)&#123;//用户名存在 //alert(&quot;用户名存在&quot;); $(&quot;#span01&quot;).html(&quot;&lt;font color=&apos;red&apos;&gt;用户名已被注册&lt;/font&gt;&quot;); &#125;else&#123; //alert(&quot;用户名可用&quot;); $(&quot;#span01&quot;).html(&quot;&lt;font color=&apos;green&apos;&gt;用户名可以使用&lt;/font&gt;&quot;); &#125; &#125; ); //3. 输出响应的数据到页面上。&#125;]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Ajax</tag>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery基础知识学习总结]]></title>
    <url>%2F2018%2F08%2F19%2FjQuery%2F</url>
    <content type="text"><![CDATA[jQuery基础知识学习总结什么JQuery: jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等 使用jQuery完成页面定时弹出广告定时器: setInterval clearInterval setTimeout clearTimeout 显示: img.style.display = “block” 隐藏: img.style.display = “none” img 对象 style属性: style对象 使用jQuery完成表格的隔行换色获得所有的行 table.rows[] 修改行的颜色 row.bgColor =&quot;red&quot; row.style.backgroundColor = &quot;black&quot; row.style.background = &quot;red&quot; &quot;background-color:red&quot; &quot;background:red&quot; 使用jQuery完成复选框的全选效果checked属性 如何获取所有复选框: document.getElementsByName get Elements By Name 数据库里面 使用jQuery完成省市联动效果JS中的数组: [&quot;城市&quot;] new Array() DOM树操作: 创建节点: document.createElement 创建文本节点: document.createTextNode 添加节点: appendChild 使用jQuery完成下列列表左右选择select下拉列表 multiple 允许多选 ondblclick : 双击事件 for循环遍历,一边遍历一边移除出现的问题 使用jQuery完成表单的校验(扩展)事件: 获得焦点事件: onfocus 失去焦点事件: onblur 按键抬起事件: onkeyup 鼠标移入: onmouseenter 鼠标移出: onmouseout JS引入外部文件 : script 使用jQuery完成页面定时弹出广告JQ的入门 1234567891011121314151617181920212223242526272829&lt;script&gt; //js文档加载完成的事件 window.onload = function()&#123; alert("window.onload 111"); &#125; window.onload = function()&#123; alert("window.onload 222"); &#125; /*文档加载完成的事件*/ jQuery(document).ready(function()&#123; alert("jQuery(document).ready(function()"); &#125;); /* jQuery 简写成 $ */ $(document).ready(function()&#123; alert("$(document).ready(function()"); &#125;); /* 最简单的写法 */ $(function()&#123; alert("$(function()&#123;"); &#125;); &lt;/script&gt; 【JQ中根据ID查找元素】 1234全都是根据选择器去找的#ID&#123;&#125;.类名&#123;&#125;$("#ID的名称") 【JQ和JS之间的转换】 JQ对象,只能调用JQ的属性和方法 JS对象 只能调用JS的属性和方法 12345678910111213141516171819function changeJS()&#123; var div = document.getElementById("div1");// div.innerHTML = "JS成功修改了内容" //将JS对象转成JQ对象 $(div).html("转成JQ对象来修改内容") &#125; $(function()&#123; //给按钮绑定事件 $("#btn2").click(function()&#123; //找到div1// $("#div1").html("JQ方式成功修改了内容"); //将JQ对象转成JS对象来调用 var $div = $("#div1");// var jsDiv = $div.get(0); var jsDiv = $div[0]; jsDiv.innerHTML="jq转成JS对象成功"; &#125;); &#125;); JQ的开发步骤: (将我们页面的JS代码和HTML页面代码进行分离) 123451. 导入JQ相关的文件2. 文档加载完成事件: $(function) : 页面初始化的操作: 绑定事件, 启动页面定时器3. 确定相关操作的事件4. 事件触发函数5. 函数里面再去操作相关的元素 显示和隐藏 img.style.display 【JQ中的动画效果】 1234567show()hide()slideUpslideDownfadeInfadeOutanimate : 自定义动画 步骤分析： 导入JQ的文件 编写JQ的文档加载事件 启动定时器 setTimeout(“”,3000); 编写显示广告的函数 在显示广告里面再启动一个定时器 编写隐藏广告的函数 代码实现1234567891011121314&lt;script&gt; //显示广告 function showAd()&#123; $("#img1").slideDown(2000); setTimeout("hideAd()",3000); &#125; //隐藏广告 function hideAd()&#123; $("#img1").slideUp(2000); &#125; $(function()&#123; //文档加载完成才这么做 setTimeout("showAd()",3000); &#125;);&lt;/script&gt; jQuery中的选择器让我们能够更加精确找到我们要操作的元素 基本选择器 ID选择器 : #ID的名称 类选择器: 以 . 开头 .类名 元素选择器: 标签的名称 通配符选择器: * 选择器,选择器: 选择器1,选择器2 基本选择器的案例12345678910111213141516171819202122232425262728293031323334&lt;!-- - ID选择器 : #ID的名称 - 类选择器: 以 . 开头 .类名 - 元素选择器: 标签的名称 - 通配符选择器: * - 选择器,选择器: 选择器1,选择器2 --&gt; &lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 $("#btn1").click(function()&#123; $("#two").css("background-color","palegreen"); &#125;); //找出mini类的所有元素 $("#btn2").click(function()&#123; $(".mini").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("div").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("*").css("background-color","palegreen"); &#125;); /*选择器分组*/ //找出mini类 和 span元素 $("#btn5").click(function()&#123; $(".mini,span").css("background-color","palegreen"); &#125;); &#125;); &lt;/script&gt; JQ中的层级选择器 子元素选择器: 选择器1 &gt; 选择器2 后代选择器: 选择器1 儿孙 相邻兄弟选择器 : 选择器1 + 选择器2 : 找出紧挨着的一个弟弟 找出所有弟弟: 选择器1~ 选择器2 : 找出所有的弟弟 123456789101112131415161718192021&lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 //找出body下面的子div $("#btn1").click(function()&#123; $("body &gt; div").css("background-color","palegreen"); &#125;); //找出body下面的所有div $("#btn2").click(function()&#123; $("body div").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("#one+div").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("#two~div").css("background-color","palegreen"); &#125;); &#125;);&lt;/script&gt; JQ中的基本过滤器12345678910111213141516171819202122232425&lt;script&gt; $(function()&#123; /&lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 //过滤出所有div中第一个元素 $("#btn1").click(function()&#123; $("div:first").css("background-color","palegreen"); &#125;); //过滤出所有div中偶数位的div $("#btn2").click(function()&#123; $("div:even").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("div:odd").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("div:gt(2)").css("background-color","palegreen"); &#125;); &#125;);&lt;/script&gt; JQ中的属性选择器123456789101112$(function()&#123;//找到有name属性的input $("#btn1").click(function()&#123; $("input[name]").attr("checked",true); &#125;); $("#btn2").click(function()&#123; $("input[name='accept']").attr("checked",true); &#125;); $("#btn3").click(function()&#123; $("input[name='newsletter'][value='Hot Fuzz']").attr("checked",true); &#125;);&#125;); JQ中的表单过滤器123456&lt;script&gt; //1.文档加载事件 $(function()&#123; $(":text").css("background-color","pink"); &#125;);&lt;/script&gt; 使用JQ完成表格的隔行换色步骤分析: 导入JQ的包 文档加载完成函数: 页面初始化 获得所有的行 : 元素选择器 根据行号去修改颜色 代码实现:123456789 $(function()&#123; //获得所有的行 : 元素选择器 $("tbody &gt; tr:even").css("background-color","#CCCCCC"); //修改基数行 $("tbody &gt; tr:odd").css("background-color","#FFF38F");// $("tbody &gt; tr").css("background-color","#FFF38F"); &#125;); 使用JQ完成省市联动效果技术分析: 准备工作 : 城市信息的数据 添加节点 : appendChild (JS) append : 添加子元素到末尾 appendTo : 给自己找一个爹,将自己添加到别人家里 prepend : 在子元素前面添加 after : 在自己的后面添加一个兄弟 遍历的操作: 步骤分析: 导入JQ的文件 文档加载事件:页面初始化 进一步确定事件: change事件 函数: 得到当前选中省份 得到城市, 遍历城市数据 将遍历出来的城市添加到城市的select中 代码实现:123456789101112131415161718$(function()&#123; $("#province").change(function()&#123;// alert(this.value); //得到城市信息 var cities = provinces[this.value]; //清空城市select中的option /*var $city = $("#city"); //将JQ对象转成JS对象 var citySelect = $city.get(0) citySelect.options.length = 0;*/ $("#city").empty(); //采用JQ的方式清空 //遍历城市数据 $(cities).each(function(i,n)&#123; $("#city").append("&lt;option&gt;"+n+"&lt;/option&gt;"); &#125;); &#125;); &#125;); 使用JQ完成下拉列表左右选择步骤分析123451. 导入JQ的文件2. 文档加载函数 :页面初始化3.确定事件 : 点击事件 onclick4. 事件触发函数1. 移动被选中的那一项到右边 代码实现123456789101112131415&lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $("#a1").click(function()&#123; //找到被选中的那一项 //将被选中项添加到右边 $("#rightSelect").append($("#leftSelect option:selected")); &#125;); //将左边所有商品移动到右边 $("#a2").click(function()&#123; $("#rightSelect").append($("#leftSelect option")); &#125;); &#125;);&lt;/script&gt; 使用JQ完成表单的校验(扩展)技术分析 trigger triggerHandler is() 步骤分析 首先给必填项,添加尾部添加一个小红点 获取用户输入的信息,做相应的校验 事件: 获得焦点, 失去焦点, 按键抬起 表单提交的事件 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;link rel="stylesheet" href="../css/style.css" /&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 1. 首先给必填项,添加尾部添加一个小红点 2. 获取用户输入的信息,做相应的校验 3. 事件: 获得焦点, 失去焦点, 按键抬起 4. 表单提交的事件 Jq的方式来实现: 1. 导入JQ的文件 2. 文档加载事件: 在必填项后天加一个小红点 3. 表单校验确定事件: blur focus keyup 4. 提交表单 submit --&gt; &lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; //默认做一些页面初始化 //动态在必填项后面添加小红点 $(".bitian").after("&lt;font class='high'&gt;*&lt;/font&gt;"); //给必填项绑定事件 $(".bitian").blur(function()&#123; //首先获取用户当前输入的值 var value = this.value; //123 //清空上一次提示的信息 $(this).parent().find(".formtips").remove(); //判断当前的值是哪一项输入的值 if($(this).is("#username"))&#123; //判断是否是用户名输入项 if(value.length &lt; 6)&#123; $(this).parent().append("&lt;span class='formtips onError'&gt;用户名太短了&lt;/span&gt;"); &#125;else&#123; $(this).parent().append("&lt;span class='formtips onSuccess'&gt;用户名够用&lt;/span&gt;"); &#125; &#125; if($(this).is("#password"))&#123; //判断是否是密码输入项 if(value.length &lt; 6)&#123; $(this).parent().append("&lt;span class='formtips onError'&gt;,密码太短了&lt;/span&gt;"); &#125;else&#123; $(this).parent().append("&lt;span class='formtips onSuccess'&gt;密码够用&lt;/span&gt;"); &#125; &#125; &#125;).focus(function()&#123; $(this).triggerHandler("blur"); &#125;).keyup(function()&#123; $(this).triggerHandler("blur"); &#125;) //给表单提交绑定事件 $("form").submit(function()&#123; //触发所有必填项的校验 $(".bitian").trigger("focus"); //找到错误信息的个数 if($(".onError").length &gt; 0)&#123; return false; &#125; return true; &#125;); &#125;); /* $(function()&#123; // 在所有必填项后天加一个小红点 * $(".bitian").after("&lt;font class='high'&gt;*&lt;/font&gt;"); //事件绑定 $(".bitian").blur(function()&#123;// var value = this.value; var value = $(this).val(); //清空当前必填项后面的span // $(".formtips").remove(); $(this).parent().find(".formtips").remove(); //获得当前事件是谁的 if($(this).is("#username"))&#123; //校验用户名 if(value.length &lt; 6)&#123; $(this).parent().append("&lt;span class='formtips onError'&gt;用户名太短了&lt;/span&gt;"); &#125;else&#123; $(this).parent().append("&lt;span class='formtips onSuccess'&gt;用户名够用&lt;/span&gt;"); &#125; &#125; if($(this).is("#password"))&#123; //校验密码 if(value.length &lt; 3)&#123; $(this).parent().append("&lt;span class='formtips onError'&gt;密码太短了&lt;/span&gt;"); &#125;else&#123; $(this).parent().append("&lt;span class='formtips onSuccess'&gt;密码够用&lt;/span&gt;"); &#125; &#125; &#125;).focus(function()&#123; $(this).triggerHandler("blur"); &#125;).keyup(function()&#123; $(this).triggerHandler("blur"); &#125;); // $(".bitian").blur(function()&#123;&#125;).focus(function()&#123;&#125;).keyup(function()&#123;&#125;) //给表单绑定提交事件 $("form").submit(function()&#123; //触发必填项的校验逻辑 $(".bitian").trigger("focus"); var length = $(".onError").length if(length &gt; 0)&#123; return false; &#125; return true; &#125;); &#125;);*/ &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="../index.html"&gt; &lt;div&gt; 用户名:&lt;input type="text" class="bitian" id="username" /&gt; &lt;/div&gt; &lt;div&gt; 密码:&lt;input type="password" class="bitian" id="password" /&gt; &lt;/div&gt; &lt;div&gt; 手机号:&lt;input type="tel" /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="submit" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 使用JQuery发送请求局部刷新页面数据交换格式: json xml 什么是JSON JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。 JSON格式 JSON对象 12&#123; key1:value&#125; &#123;"username":"zhangsan","password":"123"&#125; JSON数组 1[&#123; key1:value&#125;,&#123; key1:value&#125;,&#123; key1:value&#125;] 内容总结:定时器 动画效果: show hide slideDown slideUp fadeIn fadeOut animate 基本选择器: ID选择器: #ID名称 类选择器: .类名 元素选择器: 元素/标签名称 通配符选择器: * 找出所有页面元素 包含页面上所有的标签 选择器分组 : 选择器1, 选择器2 [选择器1,选择器2] 层级选择器: 后代选择器: 选择器1 选择器2 找出所有的后代,儿子孙子曾孙 子元素选择器: 选择器1 &gt;选择器2 找出所有儿子 相邻兄弟选择器: 选择器1+选择器2 : 找出紧挨着自己那个弟弟 兄弟选择器 : 选择器1~选择器2 : 找出所有的弟弟 属性选择器: 选择器[属性名称] 12选择器[属性名称][属性名名]选择器[属性名称='属性值'][属性名称='属性值'][属性名称='属性值'] 表单选择器: :input 找出所有的输入项 : 不单单找出input textarea select :text 找出type类型为 text :password 基本过滤器: :even :odd :gt :lt :eq :first :last 表单对象属性: :selected :checked 123456789101112131415161718$(function) : 文档加载完成的事件css() : 修改css样式prop() : 修改属性/ 获取属性html() : 修改innerHTMLappend : 给自己添加子节点appendTo : 将自己添加到别人家,给自己找一个爹prepend : 在自己最前面添加子节点after : 在自己后面添加一个兄弟empty : 清空所有子节点$(cities).each(function(i,n)&#123; &#125;)$.each(arr,function(i,n)&#123; &#125;);]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootStrap基础知识学习]]></title>
    <url>%2F2018%2F08%2F16%2FBootStrap%2F</url>
    <content type="text"><![CDATA[BootStrap基础学习使用BootStrap开发一个响应式的页面出来BootStap概述 什么是BootStrap Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。 Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。Bootstrap一经推出后颇受欢迎，一直是GitHub上的热门开源项目，包括NASA的MSNBC（微软全国广播公司）的Breaking News都使用了该项目。国内一些移动开发者较为熟悉的框架，如WeX5前端开源框架等，也是基于Bootstrap源码进行性能优化而来 BootStrap结构 全局CSS bootStrap中已经定义好了一套CSS的样式表 组件 BootStrap定义的一套按钮,导航条等组件 JS插件 BootStrap定义了一套JS的插件,这些插件已经默认实现了很多种效果 BootStrap的入门开发 引入相关的头文件 12345678910&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;&lt;link rel="stylesheet" href="../css/bootstrap.css" /&gt;&lt;!--需要引入JQuery--&gt;&lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script type="text/javascript" src="../js/bootstrap.js" &gt;&lt;/script&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; BootStrap的布局容器 .container 类用于固定宽度并支持响应式布局的容器。 123&lt;div class=&quot;container&quot;&gt; ...&lt;/div&gt; .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。 123&lt;div class=&quot;container-fluid&quot;&gt; ...&lt;/div&gt; 校验表单扩展: trigger : 触发浏览器默认行为 triggerHandler : 不会触发 is : 判断 find : 查找 什么json: 轻量级的数据交换格式 json对象: {“username”:”zhangsan”} json数组: [ {“username”:”zhangsan”}, {“username”:”zhangsan”}, {“username”:”zhangsan”}] ajax异步请求: 同步和异步 row Bootstrap 栅格系统的工作原理： “行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。 通过“行（row）”在水平方向创建一组“列（column）”。 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。 类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。 通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding BootStrap的栅格系统 响应式设计: 这种设计依赖于CSS3中的媒体查询 栅格样式: 设备分辨率大于1200 使用lg样式 设备分辨率大于992 &lt; 1200 使用md样式 设备分辨率大于768 &lt; 992 使用sm样式 设备分辨率小于768使用xs样式 BootStrap的全局CSS 定义了一套CSS 对页面中的元素进行定义 列表元素,表单,按钮,图片 简单案例实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 准备工作: &lt;meta name='viewport'&gt; 1.导入bootstrap css文件 2.导入JQuery 3.bootstrap.js 4.写一个div class = container 支持响应式的布局容器 --&gt; &lt;link rel="stylesheet" href="../css/bootstrap.min.css"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt; &lt;script src="../js/jquery-1.11.0.js"&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src="../js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-4"&gt; &lt;img src="../img/logo2.png" /&gt; &lt;/div&gt; &lt;div class="col-md-4 hidden-xs"&gt; &lt;img src="../img/header.png" /&gt; &lt;/div&gt; &lt;div class="col-md-4"&gt; &lt;a href="#"&gt;登录&lt;/a&gt; &lt;a href="#"&gt;注册&lt;/a&gt; &lt;a href="#"&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--菜单--&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;nav class="navbar navbar-inverse" role="navigation"&gt; &lt;div class="container-fluid"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt;首页&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt; &lt;a href="#"&gt;手机数码&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;鞋靴箱包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;电脑办公&lt;/a&gt; &lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown"&gt;所有分类 &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu" role="menu"&gt; &lt;li&gt; &lt;a href="#"&gt;手机数码&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;鞋靴箱包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;电脑办公&lt;/a&gt; &lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;Separated link&lt;/a&gt; &lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;One more separated link&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-right" role="search"&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control" placeholder="请输入要搜索的商品"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;!-- /.navbar-collapse --&gt; &lt;/div&gt; &lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt; &lt;!-- Indicators --&gt; &lt;ol class="carousel-indicators"&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class="carousel-inner" role="listbox"&gt; &lt;div class="item active"&gt; &lt;img src="../img/1.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="../img/2.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="../img/3.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;!--最新商品这里--&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;h3&gt;最新商品&lt;img src="../images/title2.jpg"/&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--商品部分 --&gt; &lt;div class="row"&gt; &lt;!--左边div--&gt; &lt;div class="col-md-2 hidden-sm hidden-xs"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%" /&gt; &lt;/div&gt; &lt;!--右边div--&gt; &lt;div class="col-md-10"&gt; &lt;!--上面部分--&gt; &lt;div class="row"&gt; &lt;!--中等广告图--&gt; &lt;div class="col-md-6"&gt; &lt;img src="../products/hao/middle01.jpg" width="100%" /&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--下面部分--&gt; &lt;div class="row"&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;img src="../products/hao/ad.jpg" width="100%" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--最新商品这里--&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;h3&gt;最新商品&lt;img src="../images/title2.jpg"/&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--商品部分 --&gt; &lt;div class="row"&gt; &lt;!--左边div--&gt; &lt;div class="col-md-2 hidden-sm hidden-xs"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%" /&gt; &lt;/div&gt; &lt;!--右边div--&gt; &lt;div class="col-md-10"&gt; &lt;!--上面部分--&gt; &lt;div class="row"&gt; &lt;!--中等广告图--&gt; &lt;div class="col-md-6"&gt; &lt;img src="../products/hao/middle01.jpg" width="100%" /&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--下面部分--&gt; &lt;div class="row"&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--页脚广告--&gt; &lt;div&gt; &lt;img src="../image/footer.jpg" width="100%" /&gt; &lt;/div&gt; &lt;!--网站声明--&gt; &lt;div style="text-align: center;"&gt; &lt;a href="http://www.itheima.com"&gt;关于我们&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;联系我们&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;招贤纳士&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;法律声明&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;友情链接&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;支付方式&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;配送方式&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;服务声明&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;广告声明&lt;/a&gt; &lt;br /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>BootStrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础知识学习]]></title>
    <url>%2F2018%2F08%2F16%2FjavaScript%2F</url>
    <content type="text"><![CDATA[JavaScript基础知识学习概述JavaScript概述什么是javascript: JavaScript一种直译式脚本语言， 什么是脚本语言? java源代码 ----&gt; 编译成.class文件 -----&gt; java虚拟机中才能执行 脚本语言: 源码 -------- &gt; 解释执行 js由我们的浏览器来解释执行 HTML: 决定了页面的框架 CSS: 用来美化我们的页面 JS: 提供用户的交互的 JS的组成:ECMAScript : 核心部分 ,定义js的语法规范 DOM: document Object Model 文档对象模型 , 主要是用来管理页面的 BOM : Browser Object Model 浏览器对象模型, 前进,后退,页面刷新, 地址栏, 历史记录, 屏幕宽高 JS的语法:变量弱类型: var i = true 区分大小写 语句结束之后的分号 ,可以有,也可以没有 写在script标签 JS的数据类型: 基本类型 string number boolean undefine null 引用类型 对象, 内置对象 类型转换 js内部自动转换 JS的运算符和语句: 运算符和java 一样 “===” 全等号: 值和类型都必须相等 == 值相等就可以了 语句和java 一样 JS的输出 alert() 直接弹框 document.write() 向页面输出 console.log() 向控制台输出 innerHTML: 向页面输出 获取页面元素: document.getElementById(“id的名称”); JS声明变量: var 变量的名称 = 变量的值 JS声明函数: var 函数的名称 = function(){ } function 函数的名称(){ } JS开发步骤1231. 确定事件2. 事件要触发函数,所以我们是要声明函数3. 函数里面通常是去做一些交互才操作, 弹框, 修改页面内容,动态去添加一些东西 使用JS完成简单的数据校验使用JS完成对注册页面的简单数据校验,不允许出现用户名或密码为空的情况 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /* 1. 确认事件: 表单提交事件 onsubmit事件 2. 事件所要触发的函数: checkForm 3. 函数中要干点事情 1. 校验用户名, 用户不能为空, 长度不能小于6位 1.获取到用户输入的值 */ function checkForm()&#123; //获取用户名输入项 var inputObj = document.getElementById("username"); //获取输入项的值 var uValue = inputObj.value;// alert(uValue); //用户名长度不能6位 "" if(uValue.length &lt; 6 )&#123; alert("对不起,您的长度太短!"); return false; &#125; //密码长度大于6 和确认必须一致 //获取密码框输入的值 var input_password = document.getElementById("password"); var uPass = input_password.value; if(uPass.length &lt; 6)&#123; alert("对不起,您还是太短啦!"); return false; &#125; //获取确认密码框的值 var input_repassword = document.getElementById("repassword"); var uRePass = input_repassword.value; if(uPass != uRePass)&#123; alert("对不起,两次密码不一致!"); return false; &#125; //校验手机号 var input_mobile = document.getElementById("mobile"); var uMobile = input_mobile.value; // if(!/^[1][3578][0-9]&#123;9&#125;$/.test(uMobile))&#123; alert("对不起,您的手机号无法识别!"); return false; &#125; //校验邮箱: /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/ var inputEmail = document.getElementById("email"); var uEmail = inputEmail.value; if(!/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/.test(uEmail))&#123; alert("对不起,邮箱不合法"); return false; &#125; return true; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="JS开发步骤.html" onsubmit="return checkForm()"&gt; &lt;div&gt;用户名:&lt;input id="username" type="text" /&gt;&lt;/div&gt; &lt;div&gt;密码:&lt;input id="password" type="password" /&gt;&lt;/div&gt; &lt;div&gt;确认密码:&lt;input id="repassword" type="password" /&gt;&lt;/div&gt; &lt;div&gt;手机号码:&lt;input id="mobile" type="number" /&gt;&lt;/div&gt; &lt;div&gt;邮箱:&lt;input id="email" type="text" /&gt;&lt;/div&gt; &lt;div&gt;&lt;input type="submit" value="注册" /&gt;&lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 使用JS完成图片的轮播效果步骤分析:1234561. 确定事件: 文档加载完成的事件 onload2. 事件要触发 : init()3. 函数里面要做一些事情:(通常会去操作元素,提供交互) 1. 开启定时器: 执行切换图片的函数 changeImg()4. changeImg() 1. 获得要切换图片的那个元素 代码实现:1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /* 当页面加载完成的时候, 动态切换图片 1.确定事件: 2.事件所要触发的函数 */ var index = 1; //切换图片的函数 function changeAd()&#123; //获取要操作的img var img = document.getElementById("imgAd"); img.src = "../img/"+(index%3+1)+".jpg"; //0,1,2 //1,2,3 index++; &#125; function init()&#123; //启动定时器 setInterval("changeAd()",3000); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload="init()"&gt; &lt;img src="../img/1.jpg" id="imgAd"/&gt; &lt;/body&gt;&lt;/html&gt; 完成页面定时弹出图片技术分析 定时器 setInterval : 每隔多少毫秒执行一次函数 setTimeout: 多少毫秒之后执行一次函数 clearInterval clearTimeout 显示广告 img.style.display = “block” 隐藏广告 img.style.display = “none” 步骤分析 确定事件: 页面加载完成的事件 onload 事件要触发函数: init() init函数里面做一件事: 启动一个定时器 : setTimeout() 显示一个广告 再去开启一个定时5秒钟之后,关闭广告 代码实现1234567891011121314151617181920212223&lt;script&gt; function init()&#123; setTimeout("showAD()",3000); &#125; function showAD()&#123; //首先要获取要操作的img var img = document.getElementById("img1"); //显示广告 img.style.display = "block"; //再开启定时器,关闭广告 setTimeout("hideAD()",3000); &#125; function hideAD()&#123; //首先要获取要操作的img var img = document.getElementById("img1"); //隐藏广告 img.style.display = "none"; &#125; &lt;/script&gt; 完成完成表单的校验【JS中的常用事件】 onfocus 事件: 获得焦点事件 onblur : 失去焦点 onkeyup : 按键抬起事件 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 引入外部的js文件 --&gt; &lt;script type="text/javascript" src="../js/regutils.js" &gt;&lt;/script&gt; &lt;script&gt; /* 1. 确定事件 : onfocus 2. 事件要驱动函数 3. 函数要干一些事情: 修改span的内容 */ function showTips(spanID,msg)&#123; //首先要获得要操作元素 span var span = document.getElementById(spanID); span.innerHTML = msg; &#125; /* 校验用户名: 1.事件: onblur 失去焦点 2.函数: checkUsername() 3.函数去显示校验结果 */ function checkUsername()&#123; //获取用户输入的内容 var uValue = document.getElementById("username").value; //对输入的内容进行校验 //获得要显示结果的span var span = document.getElementById("span_username"); if(uValue.length &lt; 6)&#123; //显示校验结果 span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,太短&lt;/font&gt;"; return false; &#125;else&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;恭喜您,可用&lt;/font&gt;"; return true; &#125; &#125; /* 密码校验 */ function checkPassword()&#123; //获取密码输入 var uPass = document.getElementById("password").value; var span = document.getElementById("span_password"); //对密码输入进行校验 if(uPass.length &lt; 6)&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,太短&lt;/font&gt;"; return false; &#125;else&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;恭喜您,够用&lt;/font&gt;"; return true; &#125; &#125; /* 确认密码校验 * */ function checkRePassword()&#123; //获取密码输入 var uPass = document.getElementById("password").value; //获取确认密码输入 var uRePass = document.getElementById("repassword").value; var span = document.getElementById("span_repassword"); //对密码输入进行校验 if(uPass != uRePass)&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,两次密码不一致&lt;/font&gt;"; return false; &#125;else&#123; span.innerHTML = ""; return true; &#125; &#125; /* 校验邮箱 * */ function checkMail()&#123; var umail = document.getElementById("email").value; var flag = checkEmail(umail); var span = document.getElementById("span_email"); //对邮箱输入进行校验 if(flag)&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;恭喜您,可用&lt;/font&gt;"; return true; &#125;else&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,邮箱格式貌似有问题&lt;/font&gt;"; return false; &#125; &#125; function checkForm()&#123; var flag = checkUsername() &amp;&amp; checkPassword() &amp;&amp; checkRePassword() &amp;&amp; checkMail(); return flag; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="../01-自动轮播图片/图片自动轮播.html" onsubmit="return checkForm()" &gt; 用户名:&lt;input type="text" id="username" onfocus="showTips('span_username','用户名长度不能小于6')" onblur="checkUsername()" onkeyup="checkUsername()" /&gt;&lt;span id="span_username"&gt;&lt;/span&gt;&lt;br /&gt; 密码:&lt;input type="password" id="password" onfocus="showTips('span_password','密码长度不能小于6')" onblur="checkPassword()" onkeyup="checkPassword()"/&gt;&lt;span id="span_password"&gt;&lt;/span&gt;&lt;br /&gt; 确认密码:&lt;input type="password" id="repassword" onfocus="showTips('span_repassword','两次密码必须一致')" onblur="checkRePassword()" onkeyup="checkRePassword()" /&gt;&lt;span id="span_repassword"&gt;&lt;/span&gt;&lt;br /&gt; 邮箱:&lt;input type="text" id="email" onfocus="showTips('span_email','邮箱格式必须正确')" onblur="checkMail()" /&gt;&lt;span id="span_email"&gt;&lt;/span&gt;&lt;br /&gt; 手机号:&lt;input type="text" id="text" /&gt;&lt;br /&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 定时器: setInterval(&quot;test()&quot;,3000) 每隔多少毫秒执行一次函数 setTimeout(&quot;test()&quot;,3000) 多少毫秒之后执行一次函数 timerID 上面定时器调用之后 clearInterval() clearTimeout() 切换图片 img.src = &quot;图片路径&quot; 事件: 文档加载完成的事件 onload事件 显示广告 : img.style.display = “block” 隐藏广告: img.style.display =”none” 引入一个外部js文件 1&lt;script src="js文件的路径" type="text/javascript"/&gt; 表单校验中常用的事件: 获得焦点事件: onfocus 失去焦点事件 onblur 按键抬起事件: onkeyup JS开发步骤 1231. 确定事件2. 事件要触发函数: 定义函数3. 函数通常都要去做一些交互: 点击, 修改图片, 动态修改innerHTML属性... innerTEXT 表格隔行换色实现步骤 确定事件: 文档加载完成 onload 事件要触发函数: init() 函数:操作页面的元素要操作表格中每一行动态的修改行的背景颜色 代码实现1234567891011121314151617&lt;script &gt; function init()&#123; //得到表格 var tab = document.getElementById("tab"); //得到表格中每一行 var rows = tab.rows; //便利所有的行,然后根据奇数 偶数 for(var i=1; i &lt; rows.length; i++)&#123; var row = rows[i]; //得到其中的某一行 if(i%2==0)&#123; row.bgColor = "yellow"; &#125;else&#123; row.bgColor = "red" &#125; &#125; &#125;&lt;/script&gt; 复选框的全选和全不选使用事件 : onclick点击事件 实现步骤全选和全不选步骤分析: 1.确定事件: onclick 单机事件2.事件触发函数: checkAll()3.函数要去做一些事情: 获得当前第一个checkbox的状态 获得所有分类项的checkbox 修改每一个checkbox的状态 代码实现123456789101112131415function checkAll()&#123;// 获得当前第一个checkbox的状态 var check1 = document.getElementById("check1"); //得到当前checked状态 var checked = check1.checked;// 获得所有分类项的checkbox// var checks = document.getElementsByTagName("input"); var checks = document.getElementsByName("checkone");// alert(checks.length); for(var i = 0; i &lt; checks.length; i++)&#123;// 修改每一个checkbox的状态 var checkone = checks[i]; checkone.checked = checked; &#125; &#125; DOM操作什么是DOM: Document Object Model : 管理我们的文档 增删改查规则 【HTML中的DOM操作】 12345678910111213141516171819202122232425262728293031一些常用的 HTML DOM 方法： getElementById(id) - 获取带有指定 id 的节点（元素） appendChild(node) - 插入新的子节点（元素） removeChild(node) - 删除子节点（元素） 一些常用的 HTML DOM 属性： innerHTML - 节点（元素）的文本值 parentNode - 节点（元素）的父节点 childNodes - 节点（元素）的子节点 attributes - 节点（元素）的属性节点 查找节点：getElementById() 返回带有指定 ID 的元素。 getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。 getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。 增加节点：createAttribute() 创建属性节点。 createElement() 创建元素节点。 createTextNode() 创建文本节点。 insertBefore() 在指定的子节点前面插入新的子节点。 appendChild() 把新的子节点添加到指定节点。 删除节点：removeChild() 删除子节点。 replaceChild() 替换子节点。 修改节点：setAttribute() 修改属性setAttributeNode() 修改属性节点 简答的实例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /* 准备工作 : 准备数据 */ var provinces = [ ["深圳市","东莞市","惠州市","广州市"], ["长沙市","岳阳市","株洲市","湘潭市"], ["厦门市","福州市","漳州市","泉州市"] ]; /* 1. 确定事件: onchange 2. 函数: selectProvince() 3. 函数里面要搞事情了 得到当前操作元素 得到当前选中的是那一个省份 从数组中取出对应的城市信息 动态创建城市元素节点 添加到城市select中 */ function selectProvince()&#123; var province = document.getElementById("province"); //得到当前选中的是哪个省份 //alert(province.value); var value = province.value; //从数组中取出对应的城市信息 var cities = provinces[value]; var citySelect = document.getElementById("city"); //清空select中的option citySelect.options.length = 0; for (var i=0; i &lt; cities.length; i++) &#123;// alert(cities[i]); var cityText = cities[i]; //动态创建城市元素节点 &lt;option&gt;东莞市&lt;/option&gt; //创建option节点 var option1 = document.createElement("option"); // &lt;option&gt;&lt;/option&gt; //创建城市文本节点 var textNode = document.createTextNode(cityText) ;// 东莞市 //将option节点和文本内容关联起来 option1.appendChild(textNode); //&lt;option&gt;东莞市&lt;/option&gt; // 添加到城市select中 citySelect.appendChild(option1); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--选择省份--&gt; &lt;select onchange="selectProvince()" id="province"&gt; &lt;option value="-1"&gt;--请选择--&lt;/option&gt; &lt;option value="0"&gt;广东省&lt;/option&gt; &lt;option value="1"&gt;湖南省&lt;/option&gt; &lt;option value="2"&gt;福建省&lt;/option&gt; &lt;/select&gt; &lt;!--选择城市--&gt; &lt;select id="city"&gt;&lt;/select&gt; &lt;/body&gt;&lt;/html&gt; 使用JS控制下拉列表左右选择代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 步骤分析 1. 确定事件: 点击事件 :onclick事件 2. 事件要触发函数 selectOne 3. selectOne要做一些操作 (将左边选中的元素移动到右边的select中) 1. 获取左边Select中被选中的元素 2. 将选中的元素添加到右边的Select中就可以 --&gt; &lt;script&gt; function selectOne()&#123;// 1. 获取左边Select中被选中的元素 var leftSelect = document.getElementById("leftSelect"); var options = leftSelect.options; //找到右侧的Select var rightSelect = document.getElementById("rightSelect"); //遍历找出被选中的option for(var i=0; i &lt; options.length; i++)&#123; var option1 = options[i]; if(option1.selected)&#123; // 2. 将选中的元素添加到右边的Select中就可以 rightSelect.appendChild(option1); &#125; &#125; &#125; //将左边所有的商品移动到右边 function selectAll()&#123;// 1. 获取左边Select中被选中的元素 var leftSelect = document.getElementById("leftSelect"); var options = leftSelect.options; //找到右侧的Select var rightSelect = document.getElementById("rightSelect"); //遍历找出被选中的option for(var i=options.length - 1; i &gt;=0; i--)&#123; var option1 = options[i]; rightSelect.appendChild(option1); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table border="1px" width="400px"&gt; &lt;tr&gt; &lt;td&gt;分类名称&lt;/td&gt; &lt;td&gt;&lt;input type="text" value="手机数码"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;分类描述&lt;/td&gt; &lt;td&gt;&lt;input type="text" value="这里面都是手机数码"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;分类商品&lt;/td&gt; &lt;td&gt; &lt;!--左边--&gt; &lt;div style="float: left;"&gt; 已有商品&lt;br /&gt; &lt;select multiple="multiple" id="leftSelect" ondblclick="selectOne()"&gt; &lt;option&gt;华为&lt;/option&gt; &lt;option&gt;小米&lt;/option&gt; &lt;option&gt;锤子&lt;/option&gt; &lt;option&gt;oppo&lt;/option&gt; &lt;/select&gt; &lt;br /&gt; &lt;a href="#" onclick="selectOne()"&gt; &amp;gt;&amp;gt; &lt;/a&gt; &lt;br /&gt; &lt;a href="#" onclick="selectAll()"&gt; &amp;gt;&amp;gt;&amp;gt; &lt;/a&gt; &lt;/div&gt; &lt;!--右边--&gt; &lt;div style="float: right;"&gt; 未有商品&lt;br /&gt; &lt;select multiple="multiple" id="rightSelect"&gt; &lt;option&gt;苹果6&lt;/option&gt; &lt;option&gt;肾7&lt;/option&gt; &lt;option&gt;诺基亚&lt;/option&gt; &lt;option&gt;波导&lt;/option&gt; &lt;/select&gt; &lt;br /&gt; &lt;a href="#"&gt; &amp;lt;&amp;lt; &lt;/a&gt; &lt;br /&gt; &lt;a href="#"&gt; &amp;lt;&amp;lt;&amp;lt; &lt;/a&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;input type="submit" value="提交"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 知识点总结:定时器: setInterval setTimeout clearInterval clearTimeout 控制图片显示隐藏 img.style.display = &quot;block&quot; img.style.display = &quot;none&quot; 表单中常用的事件: onfocus: 获取焦点事件 onblur : 失去焦点的事件 onkeyup: 按键抬起的事件 onclick: 单击事件 ondblclick: 双击事件 表格隔行换色,鼠标移入和移除要变色: onmouseenter: 鼠标移入 onmouseout: 鼠标移出 onload: 文档加载完成事件 onsubmit: 提交 onchange: 下拉列表内容改变 checkbox.checked 选中状态 DOM的文档操作: 添加节点: appendChild 创建节点: document.createElement 创建文本节点: document.createTextNode() JS开发步骤: 1231. 确认事件2. 事件触发函数3. 函数里面要做一些交互]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS与简单的js基础知识学习]]></title>
    <url>%2F2018%2F08%2F15%2FCSS%2F</url>
    <content type="text"><![CDATA[CSS与简单的js基础知识学习学习了一段时间的后端的知识，在开发项目的时候对于前端慢慢的学看的也七七八八，现在就重新系统的学习下基础知识,也能减少查手册的时间。 CSS简单语法CSS的简单语法: 在一个style标签中,去编写CSS内容,最好将style标签写在这个head标签中 123456&lt;style&gt; 选择器&#123; 属性名称:属性的值; 属性名称2: 属性的值2; &#125;&lt;/style&gt; CSS选择器: 帮助我们找到我们要修饰的标签或者元素 元素选择: 1234元素的名称&#123; 属性名称:属性的值; 属性名称:属性的值;&#125; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; span&#123; color:blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;简单的demo&lt;/span&gt; &lt;span&gt;简单的demo&lt;/span&gt; &lt;span&gt;简单的demo&lt;/span&gt; &lt;span&gt;简单的demo&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; ID选择器: 12345以#号开头 ID在整个页面中必须是唯一的s#ID的名称&#123; 属性名称:属性的值; 属性名称:属性的值;&#125; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #div1&#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--请将JAVAEE颜色改成红色--&gt; &lt;div id=&quot;div1&quot;&gt;JAVAEE&lt;/div&gt; &lt;div&gt;IOS&lt;/div&gt; &lt;div&gt;ANDROID&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 类选择器: 12345以 . 开头 .类的名称&#123; 属性名称:属性的值; 属性名称:属性的值;&#125; 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .shuiguo&#123; color: yellow; &#125; .shucai&#123; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;shuiguo&quot;&gt;香蕉&lt;/div&gt; &lt;div class=&quot;shucai&quot;&gt;黄瓜&lt;/div&gt; &lt;div class=&quot;shuiguo&quot;&gt;苹果&lt;/div&gt; &lt;div class=&quot;shucai&quot;&gt;茄子&lt;/div&gt; &lt;div class=&quot;shuiguo&quot;&gt;橘子&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 后代选择器 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; h1 &gt; em&#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; This is a &lt;em&gt;儿子&lt;/em&gt; &lt;strong&gt; &lt;em&gt;孙子&lt;/em&gt; &lt;/strong&gt; heading &lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; CSS的引入方式: ​ 外部样式: 通过link标签引入一个外部的css文件 ​ 内部样式: 直接在style标签内编写CSS代码 &lt;div class=&quot;shuiguo&quot; style=&quot;color:yellow&quot;&gt;香蕉&lt;/div&gt; ​ 行内样式: 直接在标签中添加一个style属性, 编写CSS样式 CSS浮动 : 浮动的元素会脱离正常的文档流,在正常的文档流中不占空间 123456789float属性: left rightclear属性: 清除浮动 both : 两边都不允许浮动 left: 左边不允许浮动 right : 右边不允许浮动流式布局 简单例子:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .logo&#123; float: left; width: 33%; /*border-width: 1px; border-style: solid; border-color: red;*/ height: 60px; line-height: 60px; /* border: 1px solid red;*/ &#125; .amenu&#123; color: white; text-decoration: none; height: 50px; line-height: 50px; &#125; .product&#123; float: left; text-align: center; width: 16%; height: 240px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. 创一个最外层div 2. 第一部份: LOGO部分: 嵌套三个div 3. 第二部分: 导航栏部分 : 放置5个超链接 4. 第三部分: 轮播图 5. 第四部分: 6. 第五部分: 直接放一张图片 7. 第六部分: 抄第四部分的 8. 第七部分: 放置一张图片 9. 第八部分: 放一堆超链接 --&gt; &lt;div&gt; &lt;!--2. 第一部份: LOGO部分: 嵌套三个div--&gt; &lt;div&gt; &lt;div class="logo"&gt; &lt;img src="../img/logo2.png"/&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;img src="../img/header.png"/&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;a href="#"&gt;登录&lt;/a&gt; &lt;a href="#"&gt;注册&lt;/a&gt; &lt;a href="#"&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--清除浮动--&gt; &lt;div style="clear: both;"&gt;&lt;/div&gt; &lt;!--3. 第二部分: 导航栏部分 : 放置5个超链接--&gt; &lt;div style="background-color: black; height: 50px;"&gt; &lt;a href="#" class="amenu"&gt;首页&lt;/a&gt; &lt;a href="#" class="amenu"&gt;手机数码&lt;/a&gt; &lt;a href="#" class="amenu"&gt;电脑办公&lt;/a&gt; &lt;a href="#" class="amenu"&gt;鞋靴箱包&lt;/a&gt; &lt;a href="#" class="amenu"&gt;香烟酒水&lt;/a&gt; &lt;/div&gt; &lt;!--4. 第三部分: 轮播图--&gt; &lt;div&gt; &lt;img src="../img/1.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--5. 第四部分:--&gt; &lt;div&gt; &lt;div&gt;&lt;h2&gt;最新商品&lt;img src="../img/title2.jpg"/&gt;&lt;/h2&gt;&lt;/div&gt; &lt;!--左侧广告图--&gt; &lt;div style="width: 15%; height: 480px; float: left;"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%"/&gt; &lt;/div&gt; &lt;!-- 右侧商品 --&gt; &lt;div style="width: 84%; height: 480px;float: left;"&gt; &lt;div style="height: 240px; width: 50%; float: left;"&gt; &lt;img src="../products/hao/middle01.jpg" height="100%" width="100%" /&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--6. 第五部分: 直接放一张图片--&gt; &lt;div&gt; &lt;img src="../products/hao/ad.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--7. 第六部分: 抄第四部分的--&gt; &lt;div&gt; &lt;div&gt;&lt;h2&gt;最新商品&lt;img src="../img/title2.jpg"/&gt;&lt;/h2&gt;&lt;/div&gt; &lt;!--左侧广告图--&gt; &lt;div style="width: 15%; height: 480px; float: left;"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%"/&gt; &lt;/div&gt; &lt;!-- 右侧商品 --&gt; &lt;div style="width: 84%; height: 480px;float: left;"&gt; &lt;div style="height: 240px; width: 50%; float: left;"&gt; &lt;img src="../products/hao/middle01.jpg" height="100%" width="100%" /&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--8. 第七部分: 放置一张图片--&gt; &lt;div&gt; &lt;img src="../img/footer.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--9. 第八部分: 放一堆超链接--&gt; &lt;div style="text-align: center;"&gt; &lt;a href="#"&gt;关于我们&lt;/a&gt; &lt;a href="#"&gt;联系我们&lt;/a&gt; &lt;a href="#"&gt;招贤纳士&lt;/a&gt; &lt;a href="#"&gt;法律声明&lt;/a&gt; &lt;a href="#"&gt;友情链接&lt;/a&gt; &lt;a href="#"&gt;支付方式&lt;/a&gt; &lt;a href="#"&gt;配送方式&lt;/a&gt; &lt;a href="#"&gt;服务声明&lt;/a&gt; &lt;a href="#"&gt;广告声明&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 扩展: CSS的优先级 按照选择器搜索精确度来编写:行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 就近原则: 哪个离得近,就选用哪个的样式 CSS: 层叠样式表 主要作用: 美化页面2. 将页面美化和HTML代码进行分离,提高代码的服用型 选择器: 元素选择器: 标签的名称{} 类选择器: 以. 开头 .类的名称 ID选择器: 以#开头 , #ID的名称 (ID必须是页面上面唯一) CSS浮动: float : left, right 不再占有正常文档流中的空间 , 流式布局 clear : both left right ​ CSS中的其它选择器 选择器分组: 选择器1,选择器2{ 属性的名称:属性的值} 属性选择器: 1234a[title]a[titile='aaa']a[href][title]a[href][title='aaa'] 后代选择器: 爷爷选择器 孙子选择器 找出所有的后代 子元素选择器: 父选择器 &gt; 儿子选择器 伪类选择器: 通常都是用在A标签上 使用DIV+CSS完成页面的优化CSS的盒子模型: 万物皆盒子 内边距: padding-top: padding-right: padding-bottom: padding-left: 1234padding:10px; 上下左右都是10pxpadding:10px 20px; 上下是10px 左右是20pxpadding: 10px 20px 30px; 上 10px 右20px 下30px 左20pxpadding: 10px 20px 30px 40px; 上右下左, 顺时针的方向 外边距: margin-top: margin-right: margin-bottom: margin-left: CSS绝对定位: ​ position: absolute ​ top: 控制距离顶部的位置 ​ left: 控制距离左边的位置 代码实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="../css/main.css"/&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. 总共是5部分 2. 第一部分是LOGO部分 3. 第二部分是导航菜单 4. 第三部分是注册部分 5. 第四部分是FOOTER图片 6. 第五部分是一堆超链接 --&gt; &lt;div&gt; &lt;!--2. 第一部分是LOGO部分--&gt; &lt;div&gt; &lt;div class="logo"&gt; &lt;img src="../img/logo2.png" /&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;img src="../img/header.png" /&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;a href="#"&gt;登录&lt;/a&gt; &lt;a href="#"&gt;注册&lt;/a&gt; &lt;a href="#"&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--清除浮动--&gt; &lt;div style="clear: both;"&gt;&lt;/div&gt; &lt;!--3. 第二部分是导航菜单--&gt; &lt;div style="background-color: black; height: 50px;"&gt; &lt;a href="#" class="amenu"&gt;首页&lt;/a&gt; &lt;a href="#" class="amenu"&gt;手机数码&lt;/a&gt; &lt;a href="#" class="amenu"&gt;电脑办公&lt;/a&gt; &lt;a href="#" class="amenu"&gt;鞋靴箱包&lt;/a&gt; &lt;a href="#" class="amenu"&gt;香烟酒水&lt;/a&gt; &lt;/div&gt; &lt;!--4. 第三部分是注册部分--&gt; &lt;div style="background: url(../image/regist_bg.jpg);height: 500px;"&gt; &lt;div style="position:absolute;top:200px;left:350px;border: 5px solid darkgray;width: 50%;height: 50%;background-color: white;"&gt; &lt;table width="60%" align="center"&gt; &lt;tr&gt; &lt;td colspan="2"&gt;&lt;font color="blue" size="6"&gt;会员注册&lt;/font&gt;USER REGISTER&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type="text"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type="password"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码:&lt;/td&gt; &lt;td&gt;&lt;input type="password"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;email:&lt;/td&gt; &lt;td&gt;&lt;input type="email"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;姓名:&lt;/td&gt; &lt;td&gt;&lt;input type="text"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt;&lt;input type="radio" name="sex"/&gt; 男 &lt;input type="radio" name="sex"/&gt; 女 &lt;input type="radio" name="sex"/&gt; 妖 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;出生日期:&lt;/td&gt; &lt;td&gt;&lt;input type="date"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码:&lt;/td&gt; &lt;td&gt;&lt;input type="text"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="submit" value="注册"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--5. 第四部分是FOOTER图片--&gt; &lt;div&gt; &lt;img src="../img/footer.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--9. 第四部分: 放一堆超链接--&gt; &lt;div style="text-align: center;"&gt; &lt;a href="#"&gt;关于我们&lt;/a&gt; &lt;a href="#"&gt;联系我们&lt;/a&gt; &lt;a href="#"&gt;招贤纳士&lt;/a&gt; &lt;a href="#"&gt;法律声明&lt;/a&gt; &lt;a href="#"&gt;友情链接&lt;/a&gt; &lt;a href="#"&gt;支付方式&lt;/a&gt; &lt;a href="#"&gt;配送方式&lt;/a&gt; &lt;a href="#"&gt;服务声明&lt;/a&gt; &lt;a href="#"&gt;广告声明&lt;/a&gt; &lt;br /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 上面用到的CSS部分的技术:​ CSS: 层叠样式表. ​ CSS作用: 美化页面,提高代码的复用性 ​ 选择器: ​ 需要掌握的: ​ 元素选择器: 标签的名称 ​ 类选择器: 以 . 开头 ​ ID选择器: 以#开头, #ID的名称 ID必须是唯一的 ​ 优先级: 按照选择精确度: 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 ​ 就近原则 ​ 扩展选择器: ​ 选择器分组: 选择器1,选择器2 以逗号隔开 ​ 后代选择器: 爷爷 孙子 中间以空格隔开 ​ 子元素选择器: 爸爸 &gt; 儿子 ​ 属性选择器: 选择器[属性的名称=’’] ​ 伪类选择器: 超链接标签上使用 ​ 浮动: float属性 left right ​ 清除浮动: clear: both left right ​ 盒子模型: 顺时针 : 上右下左 ​ padding : 内边距 ,控制的是盒子内容的距离 ​ margin : 外边距 控制盒子与盒子之间的距离 ​ 绝对定位: ​ position: absolute ​ top: ​ left:]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下重启网卡报错]]></title>
    <url>%2F2018%2F08%2F09%2FLinuxNetworkRestartError%2F</url>
    <content type="text"><![CDATA[重启网卡报Job for network.service failed because the control process exited with error code. 错误centos7下重启网卡 1systemctl restart network 然后报错 Job for network.service failed because the control process exited with error code. See “systemctl status network.service” and “journalctl -xe” for details. 解决方法： 执行 1systemctl stop NetworkManager 然后执行 1systemctl disable NetworkManager 然后重启网卡 1systemctl restart network 看一下网卡的状态 1ifconfig 如图：]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>NetWork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习之高并发接口优化]]></title>
    <url>%2F2018%2F08%2F09%2FSecurityOptimise%2F</url>
    <content type="text"><![CDATA[SpringBoot学习之高并发接口优化—–秒杀接口地址隐藏(验证码)+接口限流防刷秒杀接口地址隐藏思路：秒杀开始之前，先去请求接口获取秒杀地址。 123- 接口改造，带上PathVariable参数- 添加生成地址的接口- 秒杀收到请求，先验证PathVariable 随机生成一个字符串，作为地址加在url上，然后生成的时候，存入 redis缓存中，根据前端请求的url获取path。 判断与缓存中的字符串是否一致，一致就认为对的。就可以执行秒杀操作，否则失败。 对于秒杀接口，不是直接去请求秒杀的这个接口了， 而是先请求下获取path。之后拼接成秒杀地址。 前端代码： 1234567891011121314151617181920212223function getMiaoshaPath() &#123; goodsId:$("#goodsId").val(), g_showLoading(); $.ajax(&#123; url:"/miaosha/path", type:"GET", data:&#123; goodsId:$("#goodsId").val(), verifyCode:$("#verifyCode").val() &#125;, success:function (data) &#123; if(data.code == 0)&#123; var path = data.data; doMiaosha(path); &#125;else &#123; layer.msg(data.msg); &#125; &#125;, error:function() &#123; layer.msg("客户端请求错误"); &#125; &#125;);&#125; 对应的后端代码： 12345678910111213141516171819@AccessLimit(seconds = 5,maxCount = 5, needLogin = true)@RequestMapping(value = "/path",method = RequestMethod.GET)@ResponseBodypublic Result&lt;String&gt; getSecKillPath(HttpServletRequest request, SecKillUser user, @RequestParam("goodsId") long goodsId, @RequestParam(value = "verifyCode", defaultValue = "0") int verifyCode)&#123; if (user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; //验证码的校验 boolean check = secKillService.checkVerifyCode(user,goodsId,verifyCode); if (!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL); &#125; //生成path String path = secKillService.createSecKillPath(user,goodsId); return Result.success(path);&#125; 生成path，存入redis中 12345678public String createSecKillPath(SecKillUser user, Long goodsId) &#123; if (user == null || goodsId &lt;= 0)&#123; return null; &#125; String str = MD5Util.md5(UUIDUtil.uuid() + "123456"); redisService.set(SecKillKey.getPath,user.getId()+"_"+goodsId,str); return str; &#125; 秒杀接口，先拿到这个path验证一下是否正确，正确再进入下面的逻辑： 12345//验证pathboolean check = secKillService.checkPath(user,goodsId,path);if (!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL);&#125; 具体的验证，就是取出缓存中的path，与前端传来的path进行对比，相等，说明是这个用户发来的请求： 1234567891011121314/*** 验证秒杀接口参数* @param user* @param goodsId* @param path* @return*/public boolean checkPath(SecKillUser user, long goodsId, String path) &#123; if (user == null || path == null)&#123; return false; &#125; String pathOld = redisService.get(SecKillKey.getPath,""+user.getId()+"_"+goodsId,String.class); return path.equals(pathOld);&#125; 然后前端拼接出秒杀的地址 1234567891011121314151617181920function doMiaosha(path)&#123; $.ajax(&#123; url:"/miaosha/"+path+"/do_miaosha", type:"POST", data:&#123; goodsId:$("#goodsId").val() &#125;, success:function(data)&#123; if(data.code == 0)&#123; // window.location.href="/order_detail.htm?orderId="+data.data.id; getMiaoShaResult($("#goodsId").val()); &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125; 公式验证码思路：点击秒杀之前，先输入验证码，分散用户的请求 12 前端增加获取验证码显示验证码输入验证码上传。 1234567&lt;div class="row"&gt; &lt;div class="form-inline"&gt; &lt;img id="verifyCodeImg" width="80" height="32" style="display: none" onclick="refreshVerifyCode()"/&gt; &lt;input id="verifyCode" class="form-control" style="display: none"/&gt; &lt;button class="btn btn-primary" type="button" id="buyButton"onclick="getMiaoshaPath()"&gt;立即秒杀&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 增加返回验证码的接口 12345678910111213141516171819202122232425/** * 获取验证码 * @param response * @param user * @param goodsId * @return */ @RequestMapping(value = "/verifyCode",method = RequestMethod.GET) @ResponseBody public Result&lt;String&gt; getMiaoshaVerifyCode(HttpServletResponse response, SecKillUser user, @RequestParam("goodsId") long goodsId)&#123; if (user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; BufferedImage image = secKillService.createSecKillVerifyCode(user,goodsId); try&#123; OutputStream out = response.getOutputStream(); //输出流 ImageIO.write(image,"JPEG",out); //图片写入输出流 out.flush(); out.close(); return null; &#125;catch (Exception e)&#123; e.printStackTrace(); return Result.error(CodeMsg.SECKILL_FAILED); &#125; &#125; 在每次秒杀的时候，要先判断这个验证码是否正确 12345//验证码的校验boolean check = secKillService.checkVerifyCode(user,goodsId,verifyCode);if (!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL);&#125; 生成数字验证码并存入redis中，判断也是从redis中取出来判断 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public BufferedImage createSecKillVerifyCode(SecKillUser user, long goodsId) &#123; if (user == null || goodsId &lt;= 0)&#123; return null; &#125; int width = 80; int height = 32; //生成图片 BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = image.getGraphics(); // 背景 g.setColor(new Color(0xDCDCDC)); g.fillRect(0, 0, width, height); // 背景上生成矩形框 g.setColor(Color.black); g.drawRect(0, 0, width - 1, height - 1); // 随机数 Random rdm = new Random(); // 生成干扰点 for (int i = 0; i &lt; 50; i++) &#123; int x = rdm.nextInt(width); int y = rdm.nextInt(height); g.drawOval(x, y, 0, 0); &#125; // 生成验证码 String verifyCode = generateVerifyCode(rdm); g.setColor(new Color(0, 100, 0)); g.setFont(new Font("Candara", Font.BOLD, 24)); g.drawString(verifyCode, 8, 24); g.dispose(); //把验证码存到redis中 int rnd = calc(verifyCode); redisService.set(SecKillKey.getSecKillVerifyCode, user.getId()+","+goodsId, rnd); //输出图片 return image; &#125; private static char[] ops = new char[] &#123;'+', '-', '*'&#125;; /** * 生成验证码公式 * + - * * */ private String generateVerifyCode(Random rdm) &#123; int num1 = rdm.nextInt(10); int num2 = rdm.nextInt(10); int num3 = rdm.nextInt(10); char op1 = ops[rdm.nextInt(3)]; char op2 = ops[rdm.nextInt(3)]; String exp = ""+ num1 + op1 + num2 + op2 + num3; return exp; &#125; /** * Java ScriptEngine 解析js计算验证码 * @param exp 验证码 * @return */ private static int calc(String exp) &#123; try &#123; ScriptEngineManager manager = new ScriptEngineManager(); ScriptEngine engine = manager.getEngineByName("JavaScript"); return (Integer)engine.eval(exp); &#125;catch(Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; 前端在function getMiaoshaPath()这个函数中将结果传到后端，后端在这个获取真正秒杀链接的时候进行判断是否正确： 1verifyCode:$("#verifyCode").val() 后端接收验证码验证 123456789101112131415161718@AccessLimit(seconds = 5,maxCount = 5, needLogin = true) @RequestMapping(value = "/path",method = RequestMethod.GET) @ResponseBody public Result&lt;String&gt; getMiaoshaPath(HttpServletRequest request, SecKillUser user, @RequestParam("goodsId") long goodsId, @RequestParam(value = "verifyCode", defaultValue = "0") int verifyCode)&#123; if (user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; //验证码的校验 boolean check = secKillService.checkVerifyCode(user,goodsId,verifyCode); if (!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL); &#125; String path = secKillService.createSecKillPath(user,goodsId); return Result.success(path); &#125; redis中取出生成时存入的验证码并与前端传进来的验证码做校验 1234567891011121314151617181920/** * 验证码的验证 * @param user 用户 * @param goodsId 商品id * @param verifyCode 验证码 * @return */ public boolean checkVerifyCode(SecKillUser user, long goodsId, int verifyCode) &#123; if (user == null || goodsId &lt;= 0)&#123; return false; &#125; Integer codeOld = redisService.get(SecKillKey.getSecKillVerifyCode, user.getId()+&quot;,&quot;+goodsId, Integer.class); if (codeOld == null || codeOld - verifyCode != 0)&#123; return false; &#125; //把当前的验证码清除 redisService.delete(SecKillKey.getSecKillVerifyCode, user.getId()+&quot;,&quot;+goodsId); return true; &#125; 接口限流防刷思路：对接口做限流 可以使用拦截器减少对业务的侵入 点击秒杀之后，首先是生成path，那假如我们对这个接口进行限制：5秒之内用户只能点击5次。 这放在redis中是非常好实现的，因为redis有个自增(自减)和缓存时间，可以很好地实现这个效果。 这里使用注解的方式来实现接口的限流防刷，使用注解的话就可以做成通用的方法，在你想使用限流防刷的接口就可以添加上该注解 假设，我想在5秒内最多请求5次，并且必须要登陆：相应的注解就是这样的： 1@AccessLimit(seconds = 5,maxCount = 5,needLogin = true) 首先是实现这个注解： 12345678910111213141516171819package com.springboot.SecKill.access;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import static java.lang.annotation.ElementType.METHOD;/** * 注解 * @author WilsonSong * @date 2018/8/9/009 */@Retention(RetentionPolicy.RUNTIME)@Target(METHOD)public @interface AccessLimit &#123; int seconds(); int maxCount(); boolean needLogin() default true;&#125; 要想这个注解能够生效，必须要配置拦截器AccessInterceptor： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.springboot.SecKill.access;import com.alibaba.fastjson.JSON;import com.springboot.SecKill.domain.SecKillUser;import com.springboot.SecKill.redis.AccessKey;import com.springboot.SecKill.redis.RedisService;import com.springboot.SecKill.result.CodeMsg;import com.springboot.SecKill.result.Result;import com.springboot.SecKill.service.SecKillUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.StringUtils;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.OutputStream;/** * 拦截器 * @author WilsonSong * @date 2018/8/9/009 */@Servicepublic class AccessInterceptor extends HandlerInterceptorAdapter&#123; @Autowired SecKillUserService secKillUserService; @Autowired RedisService redisService; //方法执行前执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if(handler instanceof HandlerMethod)&#123; SecKillUser user = getUser(request,response); UserContext.setUser(user); //把用户保存在本地线程变量中,并且该user与线程绑定一直执行到结束 HandlerMethod handlerMethod = (HandlerMethod)handler; AccessLimit accessLimit = handlerMethod.getMethodAnnotation(AccessLimit.class); //取方法上的注解 if (accessLimit == null)&#123; return true; &#125; int seconds = accessLimit.seconds(); int maxCount = accessLimit.maxCount(); boolean needLogin = accessLimit.needLogin(); String key = request.getRequestURI(); if (needLogin)&#123; if (user == null)&#123; render(response,CodeMsg.SESSION_ERROR); return false; &#125; key +="_" + user.getId(); &#125;else &#123; //da nothing &#125; //访问次数限制 访问次数存入内存 AccessKey accessKey = AccessKey.withExpires(seconds); Integer count = redisService.get(accessKey,key, Integer.class); if (count == null)&#123; redisService.set(accessKey,key, 1); &#125;else if (count &lt; maxCount)&#123; redisService.incr(accessKey,key); &#125;else &#123; render(response,CodeMsg.ACCESS_LIMIT_REACHED); return false; &#125; &#125; return true; &#125; /** * 返回客户端的错误信息 * @param response * @param cm * @throws Exception */ public void render(HttpServletResponse response,CodeMsg cm) throws Exception&#123; response.setContentType("application/json;charset=UTF-8"); //返回的数据的编码方式 OutputStream outputStream = response.getOutputStream(); String str = JSON.toJSONString(Result.error(cm)); outputStream.write(str.getBytes("UTF-8")); outputStream.flush(); outputStream.close(); &#125; /** * 通过cookie获取用户 * @param request * @param response * @return */ private SecKillUser getUser(HttpServletRequest request, HttpServletResponse response)&#123; String paramToken = request.getParameter(SecKillUserService.COOKIE_NAME_TOKEN); String cookieToken = getCookieValue(request,SecKillUserService.COOKIE_NAME_TOKEN); if (StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken))&#123; return null; &#125; String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken; return secKillUserService.getByToken(response,token); &#125; /** * 获取cookie * @param request * @param cookieName * @return */ private String getCookieValue(HttpServletRequest request,String cookieName)&#123; Cookie[] cookies = request.getCookies(); if(cookies == null || cookies.length &lt;= 0)&#123; return null; &#125; for (Cookie cookie : cookies)&#123; if (cookie.getName().equals(cookieName))&#123; return cookie.getValue(); &#125; &#125; return null; &#125;&#125; 要想这个拦截器工作，我们要重写WebMvcConfigurerAdapter中的addInterceptors方法，将我们的拦截器添加进去就可以了： 123public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(accessInterceptor);&#125; 这样，利用注解和拦截器就实现了接口通用的限流功能。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>接口优化，秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习之秒杀接口优化]]></title>
    <url>%2F2018%2F08%2F08%2FAPIIOptimise%2F</url>
    <content type="text"><![CDATA[使用RabbitMQ改写秒杀功能实现思路思路：减少数据库访问 具体的实现流程就是 1234567891.系统初始化，把商品库存数量加载到Redis2.收到请求，Redis预减库存，库存不足，直接返回，否则33.请求入队，立即返回排队中4.请求出队，生成订单，减少库存5.客户端轮询，是否秒杀成功 其中4和5是同时并发处理的。 具体实现系统初始化，把商品库存数量加载到Redis如何在初始化的时候就将库存数据存入缓存中 通过实现InitializingBean接口中的一个方法:afterPropertiesSet() 系统初始化会首先调用该函数： 12345678910111213141516/** * 系统初始化会调用该函数 * @throws Exception */ @Override public void afterPropertiesSet() throws Exception &#123; List&lt;GoodsVo&gt; goodsVoList = goodsService.listGoodsVo(); if (goodsVoList == null)&#123; return; &#125; for (GoodsVo goodsVo:goodsVoList)&#123; //预先把商品库存加载到redis中 redisService.set(GoodsKey.getSeckillGoodsStock,""+goodsVo.getId(),goodsVo.getStockCount()); localOverMap.put(goodsVo.getId(),false); &#125; &#125; 收到请求，Redis预减库存，库存不足，直接返回，否则请求入队，立即返回排队中首先需要一个RabbitMQ的队列 使用Direct交换机模式 12345678/** * Direct 交换机模式 */ //队列 @Bean public Queue secKill_QUEUE() &#123; return new Queue(SECKILL_QUEUE,true); &#125; 队列消息的发送 123456public void sendSecKillMessage(SecKillMessage secKillMessage) &#123; String msg = RedisService.Bean2String(secKillMessage); logger.info(&quot;send SecKill message: &quot; + msg); amqpTemplate.convertAndSend(MQConfig.SECKILL_QUEUE, msg); &#125; 秒杀的实现 1234567891011121314151617//预先减库存long stock = redisService.decr(GoodsKey.getSeckillGoodsStock,""+goodsId);if (stock &lt; 0)&#123;localOverMap.put(goodsId,true);return Result.error(CodeMsg.SECKILL_OVER);&#125;//判断是否已经秒杀到了SecKillOrder order = orderService.getOrderByUserIdGoodsId(user.getId(),goodsId);if (order != null)&#123;return Result.error( CodeMsg.SECKILL_REPEATE);&#125;//压入RabbitMQ队列SecKillMessage secKillMessage = new SecKillMessage();secKillMessage.setUser(user);secKillMessage.setGoodsId(goodsId);mqSender.sendSecKillMessage(secKillMessage);return Result.success(0); //排队中 请求出队，生成订单，减少库存其实就是RabbitMQ的队列出队去处理相关的业务 1234567891011121314151617181920212223@RabbitListener(queues = MQConfig.SECKILL_QUEUE) public void receive(String message)&#123; logger.info("receive message" + message); SecKillMessage secKillMessage = RedisService.String2Bean(message,SecKillMessage.class); SecKillUser user = secKillMessage.getUser(); long goodsId = secKillMessage.getGoodsId(); //判断库存 GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId); int stock = goods.getStockCount(); if (stock &lt;= 0)&#123; return; &#125; //判断是否已经秒杀到了 SecKillOrder order = orderService.getOrderByUserIdGoodsId(user.getId(),goodsId); if (order != null)&#123; return; &#125; //减库存 下订单 写入秒杀订单 //订单的详细信息 OrderInfo orderInfo = secKillService.secKill(user, goods); &#125; 客户端轮询，是否秒杀成功123456789101112131415161718192021//秒杀的结果 /** * orderId:秒杀成功 * -1： 秒杀失败 * 0：排队中 * @param model * @param user * @param goodsId * @return */ @RequestMapping(value = "/result",method = RequestMethod.GET) @ResponseBody public Result&lt;Long&gt; miaoshaResult(Model model, SecKillUser user, @RequestParam("goodsId") long goodsId)&#123; model.addAttribute("user",user); if (user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; long result = secKillService.getSecKillResult(user.getId(),goodsId); return Result.success(result); &#125; secKillService.getSecKillResult(): 1234567891011121314151617181920212223//获取结果 /** * orderId :成功 * -1:失败 * 0： 排队中 * @param userId * @param goodsId * @return */ public long getSecKillResult(Long userId, long goodsId) &#123; SecKillOrder order = orderService.getOrderByUserIdGoodsId(userId,goodsId); if (order != null)&#123; return order.getOrderId(); &#125;else &#123; boolean isOver = getGoodsOver(goodsId); if (isOver)&#123; return -1; &#125;else &#123; return 0; &#125; &#125; &#125; 这里涉及到了redis的访问，就是redis中有商品的数量，通过该参数判断卖没卖完，当一次性来了多于商品数目的请求的时候，redis预减库存，减为负数，其实在这个时候在来商品购买请求的时候就不需要在访问redis了。因为商品已经卖完了，这个时候就做一个标记，先判断内存这个标记，如果库存已经小于0了，就不再访问redis，这样就减少了redis的访问次数。 没有订单有两种情况，卖完了失败，和排队中, 在上面的秒杀那做个标记。这个商品是否秒杀完了。存入redis中。 之后去判断是否存在这个key就知道是哪种情况,这样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//事务，原子性操作 @Transactional public OrderInfo secKill(SecKillUser user, GoodsVo goods) &#123; //减库存 下订单 写入秒杀订单 必须是同时完成的 boolean success = goodsService.reduceStock(goods); //减库存成功了才进行下订单 if (success) &#123; return orderService.createOrder(user, goods); &#125;else&#123; //说明商品秒杀完了。做一个标记 setGoodsOver(goods.getId()); return null; &#125; &#125; //获取结果 /** * orderId :成功 * -1:失败 * 0： 排队中 * @param userId * @param goodsId * @return */ public long getSecKillResult(Long userId, long goodsId) &#123; SecKillOrder order = orderService.getOrderByUserIdGoodsId(userId,goodsId); if (order != null)&#123; return order.getOrderId(); &#125;else &#123; boolean isOver = getGoodsOver(goodsId); if (isOver)&#123; return -1; &#125;else &#123; return 0; &#125; &#125; &#125; public void setGoodsOver(Long goodsId) &#123; redisService.set(SecKillKey.isGoodsOver,""+goodsId,true); &#125; public boolean getGoodsOver(Long goodsId) &#123; return redisService.exists(SecKillKey.isGoodsOver,""+goodsId); &#125;&#125; 相对应的前端的修改 原来的detail页面中秒杀事件函数： 12345678910111213141516171819function doMiaosha()&#123; $.ajax(&#123; url:"/miaosha/do_miaosha", type:"POST", data:&#123; goodsId:$("#goodsId").val(), &#125;, success:function(data)&#123; if(data.code == 0)&#123; window.location.href="/order_detail.htm?orderId="+data.data.id; &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125; 秒杀到商品就直接返回，现在后端改为消息队列，所以需要增加函数进行判断，必要时需要轮询： 12345if(data.code == 0)&#123; window.location.href="/order_detail.htm?orderId="+data.data.id;&#125;else&#123; layer.msg(data.msg);&#125; 所以将其改为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//其他的部分省略...if(data.code == 0)&#123; //window.location.href="/order_detail.htm?orderId="+data.data.id; //秒杀到商品的时候，这个时候不是直接返回成功，后端是进入消息队列，所以前端是轮询结果，显示排队中 getMiaoshaResult($("#goodsId").val());&#125;else&#123; layer.msg(data.msg);&#125;...function getMiaoshaResult(goodsId) &#123; g_showLoading(); $.ajax(&#123; url:"/miaosha/result", type:"GET", data:&#123; goodsId:$("#goodsId").val(), &#125;, success:function(data)&#123; if(data.code == 0)&#123; var result = data.data; //失败--- -1 if(result &lt;= 0)&#123; layer.msg("对不起，秒杀失败！"); &#125; //排队等待，轮询--- 0 else if(result == 0)&#123;//继续轮询 setTimeout(function () &#123; getMiaoshaResult(goodsId); &#125;,50); &#125; //成功---- 1 else &#123; layer.msg("恭喜你，秒杀成功，查看订单?",&#123;btn:["确定","取消"]&#125;, function () &#123; window.location.href="/order_detail.htm?orderId="+result; &#125;, function () &#123; layer.closeAll(); &#125; ); &#125; &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125; 压测测试环境 1g + 4核 + 50000个请求]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之安装RabbitMQ（踩坑）及RabbitMQ原理和使用详解]]></title>
    <url>%2F2018%2F08%2F08%2FRabbitMQ%2F</url>
    <content type="text"><![CDATA[SpringBoot之安装RabbitMQ（踩坑）及RabbitMQ原理和使用详解安装RabbitMQ安装环境centos7 + RabbitMQ 3.7.7 + OTP 21.0 Source File 1.安装erlang: （1）.下载: http://www.erlang.org/downloads （2）.安装依赖yum install ncurses-devel （3）.解压tar xf otp_src_21.0.tar.gz （4）.安装目录./configure –prefix=/usr/local/erlang –without-javac （5）编译make （6）安装make install （7）验证安装是否成功 ​ cd /usr/local/erlang/bin/ 执行./erl 2.安装rabbitmq rabbitmq解压即可用 （1）解压xz -d rabbitmq-server-generic-unix-3.7.7.tar.xz tar xf rabbitmq-server-generic-unix-3.7.7.tar （2）安装依赖: 123yum install python -yyum install xmlto -yyum install python-simplejson -y （3）启动: cd rabbitmq/sbin/ ./rabbitmq-server 正常到这里就完成安装了，但是我的并没有，报错了 踩坑（报错四部曲）（1）启动报错啊 显示./rabbitmq-server:行85: erl: 未找到命令 解决办法执行 vim /etc/profile 在文件中添加: ERL_HOME=/usr/local/erlang export PATH=$PATH:$ERL_HOME/bin （2）再启动还报错 显示错误如下： 123456789101112Error description: init:do_boot/3 init:start_em/1 rabbit:start_it/1 line 450 rabbit:broker_start/0 line 324 rabbit_plugins:prepare_plugins/1 line 289 rabbit_plugins:ensure_dependencies/1 line 263throw:&#123;error,&#123;missing_dependencies,[crypto,ssl], [amqp10_client,cowboy,cowlib,rabbitmq_aws, rabbitmq_management, rabbitmq_management_agent,rabbitmq_shovel, rabbitmq_trust_store]&#125;&#125; 解决方法： 应该是缺少依赖，openssl的两个包 看一下自己的Linux下有没有 which openssl 我的里面是有的，显示 /usr/bin/openssl 看一下版本 openssl version 版本有点老，可能是这个原因。 重新安装spenssl https://www.openssl.org/source/ 安装的话就找个教程就完事了 （3）安装完再启动还报错 错误信息： 1/usr/local/openssl/bin/openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory 其实就是找不到libssl.so.1.1 可以做一个软连接 假如你的libssl.so.1.1 文件在/usr/local/openssl/lib/下面，可以这样做 ln -s /usr/local/openssl/lib/libssl.so.1.1 /usr/lib64/libssl.so.1.1 ln -s /usr/local/openssl/lib/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1 完成后看一下当前版本 openssl version 显示OpenSSL 1.1.0g 2 Nov 2017 然后重启一般就可以了 （4）还报错，和2一样的错误 然而我的还是还是不行，怎么办，重装erlang, 然后启动rabbitmq就好使了。 会看到log tail -f /usr/local/rabbitmq/var/log/rabbitmq/rabbit@localhost.log 看一下启动起来没有,一般是在5672端口启动的，可以看一下5672端口有没有在监听 netstat -nap | grep 5672 也可以执行 ps -ef | gerp rabbitmq 看RabbitMQ相关的服务有没有启动 关闭RabbitMQ ./rabbitmqctl stop 把rabbitmq-server 写到环境变量中 vim /etc/profile 在文件中写入 export PATH=$PATH:/usr/local/ruby/bin:/usr/local/erlang/bin:/usr/local/rabbitmq/sbin 怎么让RabbitMQ在后台运行: ./rabbitmq-server -detached RabbitMQ基本原理讲解基础概念的前面，我们先来整体构造一个结构图，这样会方便们更好地去理解RabbitMQ的基本原理。 通过上面这张应用相结合的结构图既能够清晰的看清楚整体的send Message到Receive Message的一个大致的流程。当然上面有很多名词都相比还没有介绍到，不要着急接下来我们就开始对其进行详细的讲解。 QueueQueue（队列）RabbitMQ的作用是存储消息，队列的特性是先进先出。上图可以清晰地看到Client A和Client B是生产者，生产者生产消息最终被送到RabbitMQ的内部对象Queue中去，而消费者则是从Queue队列中取出数据。可以简化成表示为： 生产者Send Message “A”被传送到Queue中，消费者发现消息队列Queue中有订阅的消息，就会将这条消息A读取出来进行一些列的业务操作。这里只是一个消费正对应一个队列Queue，也可以多个消费者订阅同一个队列Queue，当然这里就会将Queue里面的消息平分给其他的消费者，但是会存在一个一个问题就是如果每个消息的处理时间不同，就会导致某些消费者一直在忙碌中，而有的消费者处理完了消息后一直处于空闲状态，因为前面已经提及到了Queue会平分这些消息给相应的消费者。这里我们就可以使用prefetchCount来限制每次发送给消费者消息的个数。详情见下图所示： 这里的prefetchCount=1是指每次从Queue中发送一条消息来。等消费者处理完这条消息后Queue会再发送一条消息给消费者。 Exchange我们在开篇的时候就留了一个坑，就是那个应用结构图里面，消费者Client A和消费者Client B是如何知道我发送的消息是给Queue1还是给Queue2，有没有过这个问题，那么我们就来解开这个面纱，看看到底是个什么构造。首先明确一点就是生产者产生的消息并不是直接发送给消息队列Queue的，而是要经过Exchange（交换器），由Exchange再将消息路由到一个或多个Queue，当然这里还会对不符合路由规则的消息进行丢弃掉，这里指的是后续要谈到的Exchange Type。那么Exchange是怎样将消息准确的推送到对应的Queue的呢？那么这里的功劳最大的当属Binding，RabbitMQ是通过Binding将Exchange和Queue链接在一起，这样Exchange就知道如何将消息准确的推送到Queue中去。简单示意图如下所示： 在绑定（Binding）Exchange和Queue的同时，一般会指定一个Binding Key，生产者将消息发送给Exchange的时候，一般会产生一个Routing Key，当Routing Key和Binding Key对应上的时候，消息就会发送到对应的Queue中去。那么Exchange有四种类型，不同的类型有着不同的策略。也就是表明不同的类型将决定绑定的Queue不同，换言之就是说生产者发送了一个消息，Routing Key的规则是A，那么生产者会将Routing Key=A的消息推送到Exchange中，这时候Exchange中会有自己的规则，对应的规则去筛选生产者发来的消息，如果能够对应上Exchange的内部规则就将消息推送到对应的Queue中去。那么接下来就来详细讲解下Exchange里面类型。 Exchange Typefanout fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。 上图所示，生产者（P）生产消息1将消息1推送到Exchange，由于Exchange Type=fanout这时候会遵循fanout的规则将消息推送到所有与它绑定Queue，也就是图上的两个Queue最后两个消费者消费。 direct direct类型的Exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中 当生产者（P）发送消息时Rotuing key=booking时，这时候将消息传送给Exchange，Exchange获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的Queue，这时发现Queue1和Queue2都符合，就会将消息传送给这两个队列，如果我们以Rotuing key=create和Rotuing key=confirm发送消息时，这时消息只会被推送到Queue2队列中，其他Routing Key的消息将会被丢弃。 topic 前面提到的direct规则是严格意义上的匹配，换言之Routing Key必须与Binding Key相匹配的时候才将消息传送给Queue，那么topic这个规则就是模糊匹配，可以通过通配符满足一部分规则就可以传送。它的约定是： routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit” binding key与routing key一样也是句点号“. ”分隔的字符串 binding key中可以存在两种特殊字符“”与“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词（可以是零个） 当生产者发送消息Routing Key=F.C.E的时候，这时候只满足Queue1，所以会被路由到Queue中，如果Routing Key=A.C.E这时候会被同是路由到Queue1和Queue2中，如果Routing Key=A.F.B时，这里只会发送一条消息到Queue2中。 headers headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。该类型的Exchange没有用到过（不过也应该很有用武之地），所以不做介绍。 总结成表格： 类型名称 类型描述 Fandout 把所有发送到该Exchange的消息路由到所有与它绑定的Queue中 Direct Routing Key==Binding Key Topic 模糊匹配 Headers Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。 Binding所谓绑定就是将一个特定的 Exchange 和一个特定的 Queue 绑定起来。Exchange 和Queue的绑定可以是多对多的关系。 通信过程假设P1和C1注册了相同的Broker，Exchange和Queue。P1发送的消息最终会被C1消费。基本的通信流程大概如下所示： P1生产消息，发送给服务器端的Exchange Exchange收到消息，根据ROUTINKEY，将消息转发给匹配的Queue1 Queue1收到消息，将消息发送给订阅者C1 C1收到消息，发送ACK给队列确认收到消息 Queue1收到ACK，删除队列中缓存的此条消息 Consumer收到消息时需要显式的向rabbit broker发送basic.ack消息或者consumer订阅消息时设置auto_ack参数为true。在通信过程中，队列对ACK的处理有以下几种情况： 如果consumer接收了消息，发送ack,rabbitmq会删除队列中这个消息，发送另一条消息给consumer。 如果cosumer接受了消息, 但在发送ack之前断开连接，rabbitmq会认为这条消息没有被deliver,在consumer在次连接的时候，这条消息会被redeliver。 如果consumer接受了消息，但是程序中有bug,忘记了ack,rabbitmq不会重复发送消息。 rabbitmq2.0.0和之后的版本支持consumer reject某条（类）消息，可以通过设置requeue参数中的reject为true达到目地，那么rabbitmq将会把消息发送给下一个注册的consumer。 SpringBoot集成RabbitMQ(1)添加依赖 12345&lt;!--rabbitmq--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; (2)添加配置 1234567891011121314151617181920212223#rabbitmqspring.rabbitmq.host=192.168.78.133spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.virtual-host=/#消费者数量#消费者队列的数量spring.rabbitmq.listener.simple.concurrency= 10spring.rabbitmq.listener.simple.max-concurrency= 10#消费者每次从队列获取的消息数量spring.rabbitmq.listener.simple.prefetch= 1#消费者自动启动spring.rabbitmq.listener.simple.auto-startup=true#消费失败，自动重新入队spring.rabbitmq.listener.simple.default-requeue-rejected= true#启用发送重试#队列的发送者，队列满了就重置spring.rabbitmq.template.retry.enabled=truespring.rabbitmq.template.retry.initial-interval=1000 spring.rabbitmq.template.retry.max-attempts=3spring.rabbitmq.template.retry.max-interval=10000spring.rabbitmq.template.retry.multiplier=1.0 配置去这里找： https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/ 每个配置的详细信息是什么： https://github.com/spring-projects/spring-boot/blob/v2.0.4.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java 配置完成之后，RabbitMQ有4种交换机模式，下面分别实现下。 4种交换机模式实现Direct、Topic、Fanout和Headers模式的实现如下： （1）初始化队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.springboot.SecKill.rabbitmq;import org.springframework.amqp.core.*;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.retry.annotation.Backoff;import java.util.HashMap;import java.util.Map;/** * rabbitMQ配置初始化 * @author WilsonSong * @date 2018/8/8 */@Configurationpublic class MQConfig &#123; public static final String QUEUE = "queue"; public static final String TOPIC_QUEUE1 = "topic.queue1"; public static final String TOPIC_QUEUE2 = "topic.queue2"; public static final String FANOUT_QUEUE1 = "fanout.queue1"; public static final String FANOUT_QUEUE2 = "fanout.queue2"; public static final String HEADERS_QUEUE = "headers.queue"; public static final String TOPIC_EXCHANGE = "topicExchange"; public static final String FANOUT_EXCHANGE = "fanoutExchange"; public static final String HEADERS_EXCHANGE = "headersExchange"; /** * Direct 交换机模式 */ //队列 @Bean public Queue queue() &#123; return new Queue(QUEUE,true); &#125; /** * Topic 交换机模式 */ @Bean public Queue topicQueue1()&#123; return new Queue(TOPIC_QUEUE1,true); &#125; @Bean public Queue topicQueue2()&#123; return new Queue(TOPIC_QUEUE2,true); &#125; @Bean public TopicExchange topicExchange()&#123; return new TopicExchange(TOPIC_EXCHANGE); &#125; /** * 绑定Exchange和queue */ @Bean public Binding topicBinding1()&#123; return BindingBuilder.bind(topicQueue1()).to(topicExchange()).with("topic.key1"); &#125; @Bean public Binding topicBinding2()&#123; return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with("topic.#"); //# 通配符，代表多个单词 &#125; /** * Fanout模式 交换机Exchange */ @Bean public Queue fanoutQueue1()&#123; return new Queue(FANOUT_QUEUE1,true); &#125; @Bean public Queue fanoutQueue2()&#123; return new Queue(FANOUT_QUEUE2,true); &#125; @Bean public FanoutExchange fanoutExchange()&#123; return new FanoutExchange(FANOUT_EXCHANGE); &#125; @Bean public Binding fanoutBinding1()&#123; return BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange()); &#125; @Bean public Binding fanoutBinding2()&#123; return BindingBuilder.bind(fanoutQueue2()).to(fanoutExchange()); &#125; /** * Header模式 交换机Exchange */ @Bean public HeadersExchange headersExchange()&#123; return new HeadersExchange(HEADERS_EXCHANGE); &#125; @Bean public Queue headersQueue()&#123; return new Queue(HEADERS_QUEUE,true); &#125; @Bean public Binding headersBinding()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("header1","value1"); map.put("header2","value2"); return BindingBuilder.bind(headersQueue()).to(headersExchange()).whereAll(map).match(); &#125;&#125; (2)消息发送者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.springboot.SecKill.rabbitmq;import com.springboot.SecKill.redis.RedisService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.amqp.core.Message;import org.springframework.amqp.core.MessageProperties;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * @author WilsonSong * @date 2018/8/8 */@Servicepublic class MQSender &#123; private static final Logger logger = LoggerFactory.getLogger(MQReceiver.class); @Autowired AmqpTemplate amqpTemplate; /** * Direct 交换机模式 */ //消息发送到队列 public void send(Object message)&#123; String msg = RedisService.Bean2String(message); logger.info("send topic message: " + msg); amqpTemplate.convertAndSend(MQConfig.QUEUE, msg); &#125; /** * Topic 交换机模式 */ public void sendTopic(Object message)&#123; String msg = RedisService.Bean2String(message); logger.info("send topic message: " + msg); amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE,"topic.key1",msg+"1"); amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE,"topic.key2",msg+"1"); &#125; /** * Fanout模式 交换机Exchange */ public void sendFanout(Object message)&#123; String msg = RedisService.Bean2String(message); logger.info("send fanout message: " + msg); amqpTemplate.convertAndSend(MQConfig.FANOUT_EXCHANGE,"",msg+"1"); &#125; /** * Header模式 交换机Exchange *"header1","value1"要与队列初始化的时候一样 */ public void sendHeaders(Object message)&#123; String msg = RedisService.Bean2String(message); logger.info("send headers message: " + msg); MessageProperties properties = new MessageProperties(); properties.setHeader("header1","value1"); properties.setHeader("header2","value2"); Message obj = new Message(msg.getBytes(),properties); amqpTemplate.convertAndSend(MQConfig.HEADERS_EXCHANGE,"",obj); &#125;&#125; (3)消息接收 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.springboot.SecKill.rabbitmq;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Service;/** * @author WilsonSong * @date 2018/8/8 */@Servicepublic class MQReceiver &#123; private static final Logger logger = LoggerFactory.getLogger(MQReceiver.class); /** * Direct 交换机模式 */ @RabbitListener(queues = MQConfig.QUEUE) public void receive(String message)&#123; logger.info("receive message" + message); &#125; /** * Topic 交换机模式 */ @RabbitListener(queues = MQConfig.TOPIC_QUEUE1) public void receiveTopic1(String message)&#123; logger.info("receive topic queue1 message: " + message); &#125; @RabbitListener(queues = MQConfig.TOPIC_QUEUE2) public void receiveTopic2(String message)&#123; logger.info("receive topic queue2 message: " + message); &#125; /** * Fanout模式 交换机Exchange */ @RabbitListener(queues = MQConfig.FANOUT_QUEUE1) public void receiveFanout1(String message)&#123; logger.info("receive fanout queue1 message: " + message); &#125; @RabbitListener(queues = MQConfig.FANOUT_QUEUE2) public void receiveFanout2(String message)&#123; logger.info("receive fanout queue2 message: " + message); &#125; /** * Header模式 交换机Exchange */ @RabbitListener(queues = MQConfig.HEADERS_QUEUE) public void receiveFanout2(byte[] message)&#123; logger.info("receive headers queue message: " + new String(message)); &#125;&#125; 启动程序，报错了 1Caused by: com.rabbitmq.client.AuthenticationFailureException: ACCESS_REFUSED - Login was refused using authentication mechanism PLAIN. For details see the broker logfile. 其实就是拒绝我们访问啊，因为我们定义的时候就是默认的用户名和密码 12spring.rabbitmq.username=guestspring.rabbitmq.password=guest 为什么默认的是这俩？ 看一下rabbitMQ的变量定义就知道了: 123456789/** * Login user to authenticate to the broker. */ private String username = "guest"; /** * Login to authenticate against the broker. */ private String password = "guest"; 怎么改呢？ 官网这么说的 “guest” user can only connect via localhost By default, the guest user is prohibited from connecting to the broker remotely; it can only connect over a loopback interface (i.e. localhost). This applies both to AMQP 0-9-1 and to any other protocols enabled via plugins. Any other users you create will not (by default) be restricted in this way. The recommended way to address this in production systems is to create a new user or set of users with the permissions to access the necessary virtual hosts. This can be done using CLI tools, HTTP API or definitions import. This is configured via the loopback_users item in the configuration file. If you wish to allow the guest user to connect from a remote host, you should set the loopback_users configuration to none. A complete RabbitMQ config file which does this would look like: loopback_users = none Or, in the classic config file format (rabbitmq.config): [{rabbit, [{loopback_users, []}]}]. 其实第二种就是在usr/local/rabbitmq/etc/rabbitmq下新建rabbitmq.config文件，添加 [{rabbit, [{loopback_users, []}]}]. 重启rabbitmq在运行程序就可以了]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2踩坑之SpringWebContext方法过时]]></title>
    <url>%2F2018%2F08%2F05%2FSpringWebContext%2F</url>
    <content type="text"><![CDATA[SpringWebContext方法过时今天在做项目的时候，为了优化访问速度，应对高并发，想把页面信息全部获取出来存到redis缓存中，这样每次访问就不用客户端进行渲染了，速度能快不少。 想用thymeleafViewResolver.getTemplateEngine().process(&quot;goodslist.html&quot;,ctx);函数实现，里面有一个ctx参数，这个参数就是WebContext 然后定义这个变量 SpringWebContext ctx = new SpringWebContext（......） 哎，这个方法在SpringBoot1.X的时候还能有，在org.thymeleaf.spring4.context这个package下，在、SpringBoot2.X +thymeleaf3.0.9 中没有，想去找一下用什么来代替，直接去org.thymeleaf.spring4下面去找，没找到相同类型的，然后取找thymeleaf.spring5的API，还找不到，只能找到thymeleaf.spring4的API,。想想还要用，怎么办啊，总不能把版本切换了吧，那有些别的说不定也得改，自己写吧，自力更生艰苦奋斗。 找了之前的一个项目，然后找到了那里面的SpringWebContext是怎么写的，超过来就完了， 但是不行SpringWebContext继承的是org.thymeleaf.context下的WebContext方法，在SpringBoot2.0+thymeleaf3.0.9中定义成final类型的，不能继承，想想要不把库的代码改了，还是算了，再往上找，找到这个WebContext extends AbstractContext implements IWebContext，没有final，所以一层一层的找到之后，按照他的源码改了一下，自己重写了SpringWebContext方法，如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.springboot.SecKill.util;import org.springframework.context.ApplicationContext;import org.thymeleaf.context.AbstractContext;import org.thymeleaf.context.IWebContext;import javax.servlet.ServletContext;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.util.Locale;import java.util.Map;import java.util.HashMap;import java.util.concurrent.ConcurrentHashMap;/** * @author WilsonSong * @date 2018/8/5 */public class SpringWebContextUtil extends AbstractContext implements IWebContext &#123; private final HttpServletRequest request; private final HttpServletResponse response; private final ServletContext servletContext; public static final String BEANS_VARIABLE_NAME = "beans"; private static final ConcurrentHashMap&lt;ApplicationContext, HashMap&lt;String, Object&gt;&gt; variableMapPrototypes = new ConcurrentHashMap(); private final ApplicationContext applicationContext; public SpringWebContextUtil(final HttpServletRequest request, final HttpServletResponse response, final ServletContext servletContext, final Locale locale, final Map&lt;String, Object&gt; variables, final ApplicationContext appctx)&#123; super(locale,addSpringSpecificVariables(variables, appctx)); this.request = request; this.response = response; this.servletContext = servletContext; this.applicationContext = appctx; &#125; private static Map&lt;String, Object&gt; addSpringSpecificVariables(Map&lt;String, ?&gt; variables, ApplicationContext appctx) &#123; HashMap&lt;String, Object&gt; variableMapPrototype = (HashMap)variableMapPrototypes.get(appctx); if (variableMapPrototype == null) &#123; variableMapPrototype = new HashMap(20, 1.0F); ContexBeans beans = new ContexBeans(appctx); variableMapPrototype.put("beans", beans); variableMapPrototypes.put(appctx, variableMapPrototype); &#125; Map newVariables; synchronized(variableMapPrototype) &#123; newVariables = (Map)variableMapPrototype.clone(); &#125; if (variables != null) &#123; newVariables.putAll(variables); &#125; return newVariables; &#125; public ApplicationContext getApplicationContext() &#123; return this.applicationContext; &#125; public HttpServletRequest getRequest() &#123; return this.request; &#125; public HttpSession getSession() &#123; return this.request.getSession(false); &#125; public HttpServletResponse getResponse() &#123; return this.response; &#125; public ServletContext getServletContext() &#123; return this.servletContext; &#125;&#125; 其中的ContexBeans是自己定义的，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.springboot.SecKill.util;/** * @author WilsonSong * @date 2018/8/5 */import java.util.Arrays;import java.util.Collection;import java.util.LinkedHashSet;import java.util.Map;import java.util.Set;import java.util.Map.Entry;import org.springframework.context.ApplicationContext;import org.thymeleaf.util.Validate;public class ContexBeans implements Map&lt;String, Object&gt; &#123; private final ApplicationContext ctx; public ContexBeans(ApplicationContext ctx) &#123; Validate.notNull(ctx, &quot;Application Context cannot be null&quot;); this.ctx = ctx; &#125; public boolean containsKey(Object key) &#123; Validate.notNull(key, &quot;Key cannot be null&quot;); return this.ctx.containsBean(key.toString()); &#125; public Object get(Object key) &#123; Validate.notNull(key, &quot;Key cannot be null&quot;); return this.ctx.getBean(key.toString()); &#125; public Set&lt;String&gt; keySet() &#123; return new LinkedHashSet(Arrays.asList(this.ctx.getBeanDefinitionNames())); &#125; public int size() &#123; return this.ctx.getBeanDefinitionCount(); &#125; public boolean isEmpty() &#123; return this.ctx.getBeanDefinitionCount() &lt;= 0; &#125; public boolean containsValue(Object value) &#123; throw new UnsupportedOperationException(&quot;Method \&quot;containsValue\&quot; not supported in Beans object&quot;); &#125; public Object put(String key, Object value) &#123; throw new UnsupportedOperationException(&quot;Method \&quot;put\&quot; not supported in Beans object&quot;); &#125; public void putAll(Map&lt;? extends String, ?&gt; m) &#123; throw new UnsupportedOperationException(&quot;Method \&quot;putAll\&quot; not supported in Beans object&quot;); &#125; public Object remove(Object key) &#123; throw new UnsupportedOperationException(&quot;Method \&quot;remove\&quot; not supported in Beans object&quot;); &#125; public void clear() &#123; throw new UnsupportedOperationException(&quot;Method \&quot;clear\&quot; not supported in Beans object&quot;); &#125; public Collection&lt;Object&gt; values() &#123; throw new UnsupportedOperationException(&quot;Method \&quot;values\&quot; not supported in Beans object&quot;); &#125; public Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() &#123; throw new UnsupportedOperationException(&quot;Method \&quot;entrySet\&quot; not supported in Beans object&quot;); &#125;&#125; 这样就能用了。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2之秒杀页面优化及解决超卖问题]]></title>
    <url>%2F2018%2F08%2F05%2FSecKillPageOptimise%2F</url>
    <content type="text"><![CDATA[页面缓存+URL缓存+对象缓存页面缓存其实系统访问某个页面的时候，并不是直接使用系统渲染，而是先从缓存中获取找到数据之后就然后返回给客户端，要是没有找到就手动渲染这个模板，渲染完成之后再把数据返回给客户端，同时把数据缓存到redis中。 其实流程很简单：（1）取缓存 （2）手动渲染模板 （3）结果输出 关于手动渲染，官方的介绍是这么说的; If you use Thymeleaf, you also have a ThymeleafViewResolver named ‘thymeleafViewResolver’. It looks for resources by surrounding the view name with a prefix and suffix. The prefix is spring.thymeleaf.prefix, and the suffix is spring.thymeleaf.suffix. The values of the prefix and suffix default to ‘classpath:/templates/’ and ‘.html’, respectively. You can override ThymeleafViewResolver by providing a bean of the same name. 就是 Thymeleaf,的模板引擎的时候需要用ThymeleafViewResolver来实现资源的渲染，用的时候注入就可以了。 1234567891011121314151617181920212223/商品列表页 不返回页面，直接返回HTML的代码 @RequestMapping(value = "/to_list", produces = "text/html") @ResponseBody public String list(HttpServletRequest request, HttpServletResponse response, Model model, SecKillUser user)&#123; model.addAttribute("user",user); //查询商品列表 List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo(); model.addAttribute("goodsList", goodsList); //取缓存 String html = redisService.get(GoodsKey.getGoodsList,"",String.class); if (!StringUtils.isEmpty(html))&#123; return html; &#125; //缓存中没有数据的时候手动渲染 SpringWebContextUtil ctx = new SpringWebContextUtil(request, response, request.getServletContext(),request.getLocale(),model.asMap(),applicationContext); html = thymeleafViewResolver.getTemplateEngine().process("goodslist.html",ctx); if(!StringUtils.isEmpty(html))&#123; redisService.set(GoodsKey.getGoodsList,"",html); &#125; return html; &#125; 这里还踩到一个小坑，取页面信息的SpringWebContext在org.thymeleaf.spring5.context这个包下面已经没有了，被删除了;在org.thymeleaf.spring4.context下面是有的，自己重写了SpringWebContext这个类。为什么非要要重写，我单独写篇博客写一下，更清晰一些。 URL缓存其实说是URL缓存，真的是有点不太准确哈，其实和页面缓存是一样的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@RequestMapping(value = "/to_detail/&#123;goodsId&#125;", produces = "text/html") @ResponseBody public String detail(HttpServletRequest request, HttpServletResponse response,Model model, SecKillUser user, @PathVariable("goodsId") long goodsId)&#123; model.addAttribute("user",user); //取缓存 String html = redisService.get(GoodsKey.getGoodsDetail,""+goodsId,String.class); if (!StringUtils.isEmpty(html))&#123; return html; &#125; //手动渲染 GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId); model.addAttribute("goods",goods); //秒杀的详细信息 long startAt = goods.getStartDate().getTime(); long endAt = goods.getEndDate().getTime(); long now = System.currentTimeMillis(); //当前的时间 int SecKillStatus = 0; int remainSeconds = 0; if (now &lt; startAt)&#123; //秒杀未开始 SecKillStatus = 0; remainSeconds = (int)((startAt - now)/1000); &#125;else if (now &gt; endAt)&#123; //秒杀结束 SecKillStatus = 2; remainSeconds = -1; &#125;else &#123; SecKillStatus = 1; remainSeconds = 0; &#125; model.addAttribute("miaoshaStatus",SecKillStatus); model.addAttribute("remainSeconds",remainSeconds); //缓存中没有数据的时候手动渲染 SpringWebContextUtil ctx = new SpringWebContextUtil(request, response, request.getServletContext(), request.getLocale(),model.asMap(),applicationContext); html = thymeleafViewResolver.getTemplateEngine().process("goods_detail.html",ctx); if(!StringUtils.isEmpty(html))&#123; redisService.set(GoodsKey.getGoodsDetail,""+goodsId ,html); &#125; return html;&#125; 对象缓存对象缓存其实就是把缓存数据和对象放在缓存中，这样每次访问的时候从缓存中读取就可以了，就相应的减少了读取数据库的次数，从而提高了网站访问的速度 。 上面的页面缓存是设置有有效期的，因为页面信息可能随时会变，一直在缓存中中就页面的信息每次读出来就不一样了，但是对象就不一样了，这个不设置有效期，或者把有效期设置的很长。 这里做个简单的例子，把做秒杀商品的用户对象放在内存中 1234567891011121314public SecKillUser getUserById(long id)&#123; //取缓存 SecKillUser user = redisService.get(SecKillUserKey.getById,""+id, SecKillUser.class); if (user !=null)&#123; return user; &#125; //缓存中没有从数据库中取出来放入缓存中 user = secKillUserDao.getUserById(id); if (user != null)&#123; redisService.set(SecKillUserKey.getById,""+id, user); &#125; return user; &#125; 因为设置缓存中的对象数据永不过期，那有人更新了自己的密码或者用户名或者其他的信息怎么办，缓存也要随着更新,要不然就缓存数据不一致了。 1234567891011121314151617public boolean updatePassword(String token,long id, String formPasswordNew)&#123; SecKillUser user = getUserById(id); if (user == null)&#123; throw new GlobalException(CodeMsg.MOBILE_NOT_EXITS); &#125; SecKillUser user2Update = new SecKillUser(); user2Update.setId(id); user2Update.setPassword(MD5Util.fromPass2DBPass(formPasswordNew,user.getSalt())); secKillUserDao.update(user2Update); //修改缓存 redisService.delete(SecKillUserKey.getById,""+id); //更新缓存中的token user.setPassword(user2Update.getPassword()); redisService.set(SecKillUserKey.token,token, user); return true; &#125; 做了部分优化，测试一下，测试的Linux服务器为1g+4核。 没有优化之前 优化之后 可以看到并发已经上去了，QPS从1267上升到2218了。 页面静态优化 前后端分离先想一下我们在平常的开发中前后端交互的流程：其实服务端为动态页面作用很单一就是提供了网站需要展示的数据而已，服务端是不会创造一个新页面的。服务端提供的数据的类型也是很统一，要不就是服务端语言提供的基本数据类型例如：字符、数字、日期等等，要不就是复杂点的数据类型例如数组、列表、键值对等等，不过归属服务端的动态页面还需要服务端语言帮助做一件事情，那就是把服务端提供的数据整合到页面里，最终产生一个浏览器可以解析的html网页，这个操作无非就是使用服务端语言可以构造文件的能力构建一个符合要求的html文件而已。不过一个页面里需要动态变化的往往只是其中一部分，所以做服务端的动态页面开发时候我们可以直接写html代码，这些html代码就等于在构造页面展示的模板而已，而模板的空白处则是使用服务端数据填充，因此在java的web开发里视图层技术延生出了Thymeleaf，freemark这样的技术，我们将其称之为模板语言的由来。 由此可见，服务端MVC框架里抢夺的web前端的工作就是抢占了构建html模板的工作，那么我们在设计web前端的MVC框架时候对于和服务端对接这块只需要让服务端保持提供数据的特性即可。从这些论述里我们发现了，其实前端MVC框架要解决的核心问题应该有这两个,它们分别是： 核心问题一：让模板技术交由浏览器来做，让服务端只提供单纯的数据服务。 核心问题二：模板技术交由浏览器来承担，那么页面的动态性体现也就是根据不同的服务端数据进行页面部分刷新来完成的。 而这两个核心问题解决办法那就是使用ajax技术，ajax技术天生就符合解决这些问题的技术手段了。 简答来讲就是其实就是将页面缓存到客户的浏览器上，当用户访问页面的时候，仅从与服务器取数据，从本地缓存中取页面，节省网络流量。 12345678910111213141516171819202122232425262728293031//商品详情页 @RequestMapping(value="/detail/&#123;goodsId&#125;") @ResponseBody public Result&lt;GoodsDetailVo&gt; detail(HttpServletRequest request, HttpServletResponse response, Model model, SecKillUser user, @PathVariable("goodsId") long goodsId)&#123; GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId); //秒杀的详细信息 long startAt = goods.getStartDate().getTime(); long endAt = goods.getEndDate().getTime(); long now = System.currentTimeMillis(); //当前的时间 int secKillStatus = 0; int remainSeconds = 0; if (now &lt; startAt)&#123; //秒杀未开始 secKillStatus = 0; remainSeconds = (int)((startAt - now)/1000); &#125;else if (now &gt; endAt)&#123; //秒杀结束 secKillStatus = 2; remainSeconds = -1; &#125;else &#123; secKillStatus = 1; remainSeconds = 0; &#125; GoodsDetailVo vo = new GoodsDetailVo(); vo.setRemainSeconds(remainSeconds); vo.setSecKillStatus(secKillStatus); vo.setGoods(goods); vo.setUser(user); return Result.success(vo); &#125; 之前我们是把数据通过model.addAttributes()传递给页面的，然后返回的是HTML页面，这里直接就是@ResponseBody，返回的是页面上需要的一些数据，不需要整合把数据整合到页面中。 对应的前端HTML的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&lt;!DOCTYPE HTML&gt;&lt;html &gt;&lt;head&gt; &lt;title&gt;商品详情&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;!-- jquery --&gt; &lt;script type="text/javascript" src="./js/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- bootstrap --&gt; &lt;link rel="stylesheet" type="text/css" href="./bootstrap/css/bootstrap.min.css" /&gt; &lt;script type="text/javascript" src="./bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;!-- jquery-validator --&gt; &lt;script type="text/javascript" src="./jquery-validation/jquery.validate.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./jquery-validation/localization/messages_zh.min.js"&gt;&lt;/script&gt; &lt;!-- layer --&gt; &lt;script type="text/javascript" src="./layer/layer.js"&gt;&lt;/script&gt; &lt;!-- md5.js --&gt; &lt;script type="text/javascript" src="./js/md5.min.js"&gt;&lt;/script&gt; &lt;!-- common.js --&gt; &lt;script type="text/javascript" src="./js/common.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt;秒杀商品详情&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;span id="userTip"&gt; 您还没有登录，请登陆后再操作&lt;br/&gt;&lt;/span&gt; &lt;span&gt;没有收货地址的提示。。。&lt;/span&gt; &lt;/div&gt; &lt;table class="table" id="goodslist"&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td colspan="3" id="goodsName"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td colspan="3"&gt;&lt;img id="goodsImg" width="200" height="200" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;秒杀开始时间&lt;/td&gt; &lt;td id="startTime"&gt;&lt;/td&gt; &lt;td &gt; &lt;input type="hidden" id="remainSeconds" /&gt; &lt;span id="miaoshaTip"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;button class="btn btn-primary btn-block" type="button" id="buyButton"onclick="doMiaosha()"&gt;立即秒杀&lt;/button&gt; &lt;input type="hidden" name="goodsId" id="goodsId" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品原价&lt;/td&gt; &lt;td colspan="3" id="goodsPrice"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;秒杀价&lt;/td&gt; &lt;td colspan="3" id="miaoshaPrice"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;库存数量&lt;/td&gt; &lt;td colspan="3" id="stockCount"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;function doMiaosha()&#123; $.ajax(&#123; url:"/miaosha/do_miaosha", type:"POST", data:&#123; goodsId:$("#goodsId").val(), &#125;, success:function(data)&#123; if(data.code == 0)&#123; window.location.href="/order_detail.htm?orderId="+data.data.id; &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125;function render(detail)&#123; var miaoshaStatus = detail.secKillStatus; var remainSeconds = detail.remainSeconds; var goods = detail.goods; var user = detail.user; if(user)&#123; $("#userTip").hide(); &#125; $("#goodsName").text(goods.goodsName); $("#goodsImg").attr("src", goods.goodsImg); $("#startTime").text(new Date(goods.startDate).format("yyyy-MM-dd hh:mm:ss")); $("#remainSeconds").val(remainSeconds); $("#goodsId").val(goods.id); $("#goodsPrice").text(goods.goodsPrice); $("#miaoshaPrice").text(goods.miaoshaPrice); $("#stockCount").text(goods.stockCount); countDown();&#125;$(function()&#123; //countDown(); getDetail();&#125;);function getDetail()&#123; var goodsId = g_getQueryString("goodsId"); $.ajax(&#123; url:"/goods/detail/"+goodsId, type:"GET", success:function(data)&#123; if(data.code == 0)&#123; render(data.data); &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125;function countDown()&#123; var remainSeconds = $("#remainSeconds").val(); var timeout; if(remainSeconds &gt; 0)&#123;//秒杀还没开始，倒计时 $("#buyButton").attr("disabled", true); $("#miaoshaTip").html("秒杀倒计时："+remainSeconds+"秒"); timeout = setTimeout(function()&#123; $("#countDown").text(remainSeconds - 1); $("#remainSeconds").val(remainSeconds - 1); countDown(); &#125;,1000); &#125;else if(remainSeconds == 0)&#123;//秒杀进行中 $("#buyButton").attr("disabled", false); if(timeout)&#123; clearTimeout(timeout); &#125; $("#miaoshaTip").html("秒杀进行中"); &#125;else&#123;//秒杀已经结束 $("#buyButton").attr("disabled", true); $("#miaoshaTip").html("秒杀已经结束"); &#125;&#125;&lt;/script&gt;&lt;/html&gt; 可以看到这里把html中的原来的依赖于Thymeleaf的部分全部重写，直接从浏览器的缓存中取数据，填充页面。其实还需要做一个配置，就是把application.properties中添加上spring对于静态资源的配置，就是SPRING RESOURCES HANDLING的配置 12345678#staticspring.resources.add-mappings=truespring.resources.chain.cache=truespring.resources.cache.period=3600spring.resources.chain.enabled=truespring.resources.chain.gzipped=truespring.resources.chain.html-application-cache=truespring.resources.static-locations=classpath:/static/ 这样就完成了前后端的分离。 静态资源优化代码压缩 最常规的优化手段之一。 我们在平时开发的时候，JS脚本文件和CSS样式文件中的代码，都会依据一定的代码规范（比如javascript-standard-style）来提高项目的可维护性，以及团队之间合作的效率。 但是在项目发布现网后， 这些代码是给客户端（浏览器）识别的，此时代码的命名规范、空格缩进都已没有必要，我们可以使用工具将这些代码进行混淆和压缩，减少静态文件的大小 文件合并 在npm流行的今天，前端在进行项目开发的时候，往往会使用很多第三方代码库，比如jQuery，axios，weixin-js-sdk，lodash，bootstrap等等，每个库都有属于自己的脚本或者样式文件。 按照最老的方式的话，我们会用一些标签分别引入这些库文件，导致在打开一个页面的时候会发起几十个请求，这对于移动端来说是不可接受的。在减少文件请求数量方面大致有以下三方面：1、合并js脚本文件2、合并css样式文件3、合并css引用的图片，使用sprite雪碧图。 GZip 开启GZip，精简JavaScript，移除重复脚本，图像优化 CDN优化 简介：CDN（内容发布网络）,是一个加速用户获取数据的系统；既可以是静态资源，又可以是动态资源，这取决于我们的决策策略。经常大部分视频加速都依赖于CDN，比如优酷，爱奇艺等，据此加速； 原理：CDN部署在距离用户最近的网络节点上，用户上网的时候通过网络运营商（电信，长城等）访问距离用户最近的要给城域网网络地址节点上，然后通过城域网跳到主干网上，主干网则根据访问IP找到访问资源所在服务器，但是，很大一部分内容在上一层节点已经找到，此时不用往下继续查找，直接返回所访问的资源即可，减小了服务器的负担。一般互联网公司都会建立自己的CDN机群或者租用CDN。 这些就了解下原理，毕竟大部分是前端的。 关于这个还找到了一篇博客啊，仅供参考。 https://blog.csdn.net/zhangjs712/article/details/51166748 超卖问题超发的原因假设某个抢购场景中，我们一共只有100个商品，在最后一刻，我们已经消耗了99个商品，仅剩最后一个。这个时候，系统发来多个并发请求，这批请求读取到的商品余量都是99个，然后都通过了这一个余量判断，最终导致超发。（同文章前面说的场景） 在上面的这个图中，就导致了并发用户B也“抢购成功”，多让一个人获得了商品。这种场景，在高并发的情况下非常容易出现。 1.数据库唯一索引 就是分表，秒杀的订单和正常的订单是两张表，在数据库中建立用户id和商品id的唯一索引，防止用户插入重复的记录。 2. 悲观锁思路 解决线程安全的思路很多，可以从“悲观锁”的方向开始讨论。 悲观锁，也就是在修改数据的时候，采用锁定状态，排斥外部请求的修改。遇到加锁的状态，就必须等待。 虽然上述的方案的确解决了线程安全的问题，但是，别忘记，我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常。 3. FIFO队列思路 那好，那么我们稍微修改一下上面的场景，我们直接将请求放入队列中的，采用FIFO（First Input First Output，先进先出），这样的话，我们就不会导致某些请求永远获取不到锁。看到这里，是不是有点强行将多线程变成单线程的感觉哈。 然后，我们现在解决了锁的问题，全部请求采用“先进先出”的队列方式来处理。那么新的问题来了，高并发的场景下，因为请求很多，很可能一瞬间将队列内存“撑爆”，然后系统又陷入到了异常状态。或者设计一个极大的内存队列，也是一种方案，但是，系统处理完一个队列内请求的速度根本无法和疯狂涌入队列中的数目相比。也就是说，队列内的请求会越积累越多，最终Web系统平均响应时候还是会大幅下降，系统还是陷入异常。 4. 乐观锁思路 这个时候，我们就可以讨论一下“乐观锁”的思路了。乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。这样的话，我们就不需要考虑队列的问题，不过，它会增大CPU的计算开销。但是，综合来说，这是一个比较好的解决方案。 有很多软件和服务都“乐观锁”功能的支持，例如Redis中的watch就是其中之一。通过这个实现，我们保证了数据的安全。 就是采用计数器的方式，用一个集合，存放每个商品以及其对应的数量，如果只是单纯的decr函数或者是incr函数，不能解决秒杀这种问题。因为有可能在并发的情况下，两个请求取到的数都是0，然后都加1，结果为1，实际上应该是2。那么这个时候建议利用乐观锁，实现自己的decr函数。 乐观锁的机制如同版本控制，如果修改的时候，要修改的value在redis中的值已经跟取出来时不一样，则修改失败。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>秒杀， 页面优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习之Windows和Linux下的JMeter压测和redis压测]]></title>
    <url>%2F2018%2F08%2F04%2FJMeter%2F</url>
    <content type="text"><![CDATA[SpringBoot学习之JMeter压测JMeter入门jmeter是apache公司基于java开发的一款开源压力测试工具，体积小，功能全，使用方便，是一个比较轻量级的测试工具，使用起来非常简单。因为jmeter是java开发的，所以运行的时候必须先要安装jdk才可以。jmeter是免安装的，拿到安装包之后直接解压就可以使用，同时它在linux/windows/macos上都可以使用。 jmeter可以做接口测试和压力测试。其中接口测试的简单操作包括做http脚本（发get/post请求、加cookie、加header、加权限认证、上传文件）、做webservice脚本、参数化、断言、关联（正则表达式提取器和处理json-json path extractor）和jmeter操作数据库等等。JMeter的官方网站：http://jmeter.apache.org/JMeter的参考手册：http://jmeter.apache.org/usermanual/get-started.html具体的使用参考官网就可以了。## Windows下的压测### Jmeter-http接口脚本一般分五个步骤:（1）添加线程组 （2）添加http请求 （3）在http请求中写入接入url、路径、请求方式和参数 （4）添加聚合报告 （5）调用接口、查看返回值（1）添加线程组：（2）添加http请求：（3）在http请求中写入接入url、路径、请求方式和参数 ：（4）添加聚合报告和图形结果或查看结果树：聚合报告只是总体的进行解析压测结果。（5）调用接口、查看返回值：同时启动1000个线程:### JMeter 自定义变量新建http请求，添加token:压测之后能够看到自己添加的token，还能看到返回的数据## JMeter读取自定义文件模拟多用户需要在线程组里面添加配置元件-CSV Data Set Config，添加文件和自定义文件中对应的变量名其中遇到文件结束符再次循环（Recycle on EOF）:设置True后，允许循环取值引入${userToken}，与你定义的变量名相同。## Linux下使用JMeter压测首先在Windows下创建一个压测，然后存为.jmx文件。上传至Linux下执行1./apache-jmeter-4.0/bin/jmeter.sh -n -t goods_list.jmx -l result.jtl 这样就可以得到 result.jtl数据了，可以查看结果 当然也可以直接在Linux下直接测试，我这是为了方便就这么做了。 redis 压测看一下redis服务是否在运行 12ps -ef | grep redis 执行： 1redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000 -c 100 就是100个并发 -n 100000 就是100000个请求。 看一下其中的一个结果 100000个请求在2.38s内完成，有4.12%的请求在1ms内完成，一秒大概完成41963.91个请求。以3字节大小测试。 再看这条命令： 1redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100 -q 就是quiet，输出少一些，-d 100是存取数据包为100字节大小的数据包，上面默认是3 字节存取的。看一下输出 只测试某些命令的性能 1redis-benchmark -t set,lpush -q -n 10000 -t set,lpush 是只测试set和lpush命令。 只测试某些数据存取的性能： 1redis-benchmark -q -n 10000 script load &quot;redis.call(&apos;set&apos;,&apos;foo&apos;,&apos;bar&apos;)&quot; 只对’set’,’foo’,’bar’该命令做压测。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot使用JSR303参数校验并进行全局异常处理]]></title>
    <url>%2F2018%2F08%2F02%2FJSR303%2F</url>
    <content type="text"><![CDATA[SpringBoot使用JSR303参数校验开发web项目有时候我们需要对controller层传过来的参数进行一些基本的校验，比如非空，非null，整数值的范围，字符串的个数，日期，邮箱等等。最常见的就是我们直接写代码校验，这样以后比较繁琐，而且不够灵活。 不能总是写繁琐的代码来实现吧。 使用JSR303来做参数校验就方便并且整洁很多了。 pop引入依赖12345&lt;!--JSR303校验的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; Controller中使用12345@RequestMapping("/login")//@Valid是JSR303校验public Result&lt;Boolean&gt; login(@Valid LoginVo loginVo)&#123; &#125; 校验实体123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.springboot.SecKill.vo;import com.springboot.SecKill.validator.IsMobile;import org.hibernate.validator.constraints.Length;import javax.validation.constraints.NotNull;/** * @author WilsonSong * @date 2018/8/2/002 */public class LoginVo &#123; @NotNull @IsMobile private String mobile; @NotNull @Length(min=32) private String password; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "LoginVo&#123;" + "mobile='" + mobile + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 自定义校验JSR303中给我们定义了一些常用的校验注解，如本文最后常用常用注解中所示，但是要是还不能满足学习怎么去自己定义注解呢？ 参照@NotNull这个校验注解的定义方法，@NotNull是这么定义的 12345678910111213141516171819202122232425262728293031323334353637//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package javax.validation.constraints;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import javax.validation.Constraint;import javax.validation.Payload;@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)@Retention(RetentionPolicy.RUNTIME)@Repeatable(NotNull.List.class)@Documented@Constraint( validatedBy = &#123;&#125;)public @interface NotNull &#123; String message() default "&#123;javax.validation.constraints.NotNull.message&#125;"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; @Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface List &#123; NotNull[] value(); &#125;&#125; 参照上面，我们实现自己的注解 12345678910111213141516171819202122232425262728package com.springboot.SecKill.validator;import javax.validation.Constraint;import javax.validation.Payload;import java.lang.annotation.*;/** * @author WilsonSong * @date 2018/8/2/002 */@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint( validatedBy = &#123;IsMobileValidator.class&#125;)public @interface IsMobile &#123; boolean required() default true; //校验不通过，提示默认的错误信息 String message() default "手机号码格式错误"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 实现具体校验器上面只是实现了自己定义的校验器的接口，具体的实现类如下： 123456789101112131415161718192021222324252627282930313233343536package com.springboot.SecKill.validator;import com.springboot.SecKill.util.ValidatorUtil;import org.springframework.util.StringUtils;import javax.validation.ConstraintValidator;import javax.validation.ConstraintValidatorContext;/** * JSR303具体的校验器 * @author WilsonSong * @date 2018/8/2/002 */public class IsMobileValidator implements ConstraintValidator&lt;IsMobile, String&gt; &#123; public boolean required = false; //初始化 @Override public void initialize(IsMobile constraintAnnotation) &#123; required = constraintAnnotation.required(); &#125; //校验 @Override public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) &#123; if(required)&#123; //值是必须的就判断是否合法 return ValidatorUtil.isMobile(s); //不为空就判断格式 &#125;else &#123; //若不必须就判断是否有值 if (StringUtils.isEmpty(s))&#123; return true; &#125;else &#123; return ValidatorUtil.isMobile(s); //不为空就判断格式 &#125; &#125; &#125;&#125; 异常处理参数校验不通过就会产生错误信息，显示一大串例如 1&#123;"timestamp":"2018-08-02T13:07:50.890+0000","status":400,"error":"Bad Request","errors":[&#123;"codes":["IsMobile.loginVo.mobile","IsMobile.mobile","IsMobile.java.lang.String","IsMobile"],"arguments":[&#123;"codes":["loginVo.mobile","mobile"],"arguments":null,"defaultMessage":"mobile","code":"mobile"&#125;,true],"defaultMessage":"手机号码格式错误","objectName":"loginVo","field":"mobile","rejectedValue":"22111111111","bindingFailure":false,"code":"IsMobile"&#125;],"message":"Validation failed for object='loginVo'. Error count: 1","path":"/login/do_login"&#125; 为了方便查看，统一进行异常处理 1234567891011121314151617181920212223242526272829303132333435363738package com.springboot.SecKill.exception;import com.springboot.SecKill.result.CodeMsg;import com.springboot.SecKill.result.Result;import org.springframework.validation.ObjectError;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import org.springframework.validation.BindException;import java.util.List;/** * @author WilsonSong * @date 2018/8/2/002 */@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123; @ExceptionHandler(value = Exception.class) //拦截所有的异常 public Result&lt;String&gt; exceptionHandler(HttpServletRequest httpServletRequest, Exception e)&#123; // 参数校验异常 if(e instanceof BindException)&#123; BindException ex = (BindException)e; List&lt;ObjectError&gt; errors = ex.getAllErrors(); ObjectError error= errors.get(0); String msg = error.getDefaultMessage(); return Result.error(CodeMsg.BIND_ERROR.fillArgs(msg)); &#125;else &#123; //其他异常 return Result.error(CodeMsg.SERVER_ERROR); &#125; &#125;&#125; 全局的异常处理上面的知识参数检验时候的异常处理，但是在工程中很多的异常，用全局的异常处理更加方便维护。 首先定义一个全局的异常 1234567891011121314151617181920212223242526272829303132package com.springboot.SecKill.exception;import com.springboot.SecKill.result.CodeMsg;/** * @author WilsonSong * @date 2018/8/2/002 */public class GlobalException extends RuntimeException &#123; private static final long serialVersionUID = 1L; private CodeMsg cm; public GlobalException (CodeMsg cm)&#123; super(cm.toString()); this.cm = cm; &#125; public static long getSerialVersionUID() &#123; return serialVersionUID; &#125; public CodeMsg getCm() &#123; return cm; &#125; public void setCm(CodeMsg cm) &#123; this.cm = cm; &#125;&#125; 然后在全局异常处理器中添加这个全局的异常，也就是在GlobalExceptionHandler类中添加 1234if(e instanceof GlobalException)&#123; GlobalException ex = (GlobalException) e; return Result.error(ex.getCm()); &#125; 然后在产生异常的地方直接抛出全局异常就可以了 123if (loginVo == null)&#123; throw new GlobalException(CodeMsg.SERVER_ERROR); &#125; CodeMsg.SERVER_ERROR是自己定义的异常信息。 常用注解1234567891011121314151617@Null 被注释的元素必须为null@NotNull 被注释的元素不能为null@AssertTrue 被注释的元素必须为true@AssertFalse 被注释的元素必须为false@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Size(max,min) 被注释的元素的大小必须在指定的范围内。@Digits(integer,fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内@Past 被注释的元素必须是一个过去的日期@Future 被注释的元素必须是一个将来的日期@Pattern(value) 被注释的元素必须符合指定的正则表达式。@Email 被注释的元素必须是电子邮件地址@Length 被注释的字符串的大小必须在指定的范围内@NotEmpty 被注释的字符串必须非空@Range 被注释的元素必须在合适的范围内]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JSR303</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2.0集成Redis详解及踩过的坑（Could not get a resource from the pool）]]></title>
    <url>%2F2018%2F08%2F02%2FRedis%2F</url>
    <content type="text"><![CDATA[SpringBoot2.0集成Redis首先安装的过程就不提了。上一个项目的redis是配置在Windows下的，集成很简单，也没有做什么配置。这次为了进行测试，装在了linux下。在SpringBoot集成的过程中遇到了一些小坑，分享一下。 pom文件中添加依赖12345678910111213&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入Json依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt; 可以看到除了Redis我还加入了JSON的依赖，这是因为我之后读取出来的数据要转换成JSON串的格式，数据可读，方便开发。 application.properties文件中添加配置12345678910111213#redis配置#Linux主机地址spring.redis.host=192.168.78.131#端口spring.redis.port=6379#超时时间，msspring.redis.timeout=3000#连接池的最大连接数spring.redis.jedis.pool.max-active=10#链接的最大等待时间msspring.redis.jedis.pool.max-wait=3000#连接池中的最大的等待数量spring.redis.jedis.pool.max-idle=10 在SpringBoot2.0的版本中timeout变成了Duration类型的，从其源码中我们可以看一下是怎么定义的: 123public void setTimeout(Duration timeout) &#123; this.timeout = timeout; &#125; 所以正常的写法应该是： 1spring.redis.timeout=3000ms 但是这样也带来了一个问题，下面再说这个问题是什么，这里先按照初始的定义，不会报错的 正常的人可能还会在配置文件中添加redis的密码的配置，没有密码的话就不要添加这个配置，就算默认为空也会导致出现错误，不能实现OAuth认证，要是有密码的话就添加上并写上自己的密码。 1spring.redis.password= Redis的自定义初始化首先写redisConfig的文件，读取application.properties文件中yml的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.springboot.SecKill.redis;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import org.springframework.stereotype.Component;/** * Redis的配置 * @author WilsonSong * @date 2018/8/1/001 *///作为组件扫描进来@Component//读取配置文件@Configuration@ConfigurationProperties(prefix = "spring.redis")public class RedisConfig &#123; private String host; //主机 private int port; //端口 private int timeout; //超时时间 @Value("$&#123;spring.redis.jedis.pool.max-active&#125;") private int maxActive; //连接池最大线程数 @Value("$&#123;spring.redis.jedis.pool.max-wait&#125;") private long maxWait; //等待时间 @Value("$&#123;spring.redis.jedis.pool.max-idle&#125;") private int maxIdle;//最大空闲连接 public String getHost() &#123; return host; &#125; public void setHost(String host) &#123; this.host = host; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125; public int getTimeout() &#123; return timeout; &#125; public void setTimeout(int timeout) &#123; this.timeout = timeout; &#125; public int getMaxActive() &#123; return maxActive; &#125; public void setMaxActive(int maxActive) &#123; this.maxActive = maxActive; &#125; public long getMaxWait() &#123; return maxWait; &#125; public void setMaxWait(long maxWait) &#123; this.maxWait = maxWait; &#125; public int getMaxIdle() &#123; return maxIdle; &#125; public void setMaxIdle(int maxIdle) &#123; this.maxIdle = maxIdle; &#125;&#125; 上面用了两种方式来读取application.properties中的配置，一种是直接设置@ConfigurationProperties(prefix = “spring.redis”)，然后变量名与application.properties中的变量名一样，这样就可以读出来了，然后像max-wait这种变量名没法定义啊，所以又用了@Value(“${spring.redis.jedis.pool.max-idle}”)这种注解的方式来读取，当然你可以全部影注解的方式来读取，注意过程中的每一个变量的基本数据类型定义准确。maxWait和timeout这两个本来都是Duration类型的，但是这里分别写成long和int类型的。一会儿再解释这个问题。 过程中需要从redis连接池中获取redis服务，所以这里初始化jedisPool的配置 123456789101112131415161718192021222324252627282930313233package com.springboot.SecKill.redis;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.stereotype.Service;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * @author WilsonSong * @date 2018/8/1/001 */@Servicepublic class RedisPoolFactory &#123; @Autowired RedisConfig redisConfig; /** * redis连接池的一些配置 * @return */ @Bean public JedisPool JedisPoolFactory()&#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxIdle(redisConfig.getMaxIdle()); poolConfig.setMaxTotal(redisConfig.getMaxActive()); poolConfig.setMaxWaitMillis((redisConfig.getMaxWait())); JedisPool jedisPool = new JedisPool(poolConfig, redisConfig.getHost(),redisConfig.getPort(),redisConfig.getTimeout()); return jedisPool; &#125;&#125; 这里解释下maxWait和timeout这两个数据类型的问题。首先 1poolConfig.setMaxWaitMillis((redisConfig.getMaxWait())); 用到了maxWait这个变量，看一下setMaxWaitMillis（）函数的源码 123public void setMaxWaitMillis(long maxWaitMillis) &#123; this.maxWaitMillis = maxWaitMillis; &#125; maxWaitMillis这个变量是long类型的，所以执勤才那么定义。 同理 1JedisPool jedisPool = new JedisPool(poolConfig, redisConfig.getHost(),redisConfig.getPort(),redisConfig.getTimeout()); 这里面有用到redisConfig.getTimeout()，看一下JedisPool是怎么初始化的 123public JedisPool(GenericObjectPoolConfig poolConfig, String host, int port, int timeout) &#123; this(poolConfig, host, port, timeout, (String)null, 0, (String)null); &#125; 可以看到timeout是int类型的，你要一开始定义成Duration类型的，然后可能过程中会涉及到数据类型的强制准换，会不会报错不知道，有兴趣的可以试一下。 最后就是初始化redis的方法如get,set等等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163package com.springboot.SecKill.redis;import com.alibaba.fastjson.JSON;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;/** * @author WilsonSong * @date 2018/8/1 */@Servicepublic class RedisService &#123; private static final Logger logger = LoggerFactory.getLogger(RedisService.class); @Autowired JedisPool jedisPool; public &lt;T&gt; T get(KeyPrefix prefix, String key, Class&lt;T&gt; clazz)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); //生成real key String realKey = prefix.getPrefix() + key; String str = jedis.get(realKey); T t = String2Bean(str, clazz); return t; &#125;catch (Exception e)&#123; logger.error("redis连接池异常"+e.getMessage()); return null; &#125;finally &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125; &#125; public &lt;T&gt; boolean set(KeyPrefix prefix,String key, T value)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); String value_new = Bean2String(value); if (value_new == null || value_new.length() &lt;0)&#123; return false; &#125; //生成real key String realKey = prefix.getPrefix() + key; //过期时间 int seconds = prefix.expireSeconds(); if (seconds &lt;= 0)&#123; jedis.set(realKey, value_new); &#125;else &#123; jedis.setex(realKey,seconds,value_new); &#125; return true; &#125;catch (Exception e)&#123; logger.error("redis连接池异常"+e.getMessage()); return false; &#125;finally &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125; &#125; //key 是否存在 public &lt;T&gt; Boolean exists(KeyPrefix prefix, String key)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); //生成real key String realKey = prefix.getPrefix() + key; return jedis.exists(realKey); &#125;catch (Exception e)&#123; logger.error("redis连接池异常"+e.getMessage()); return null; &#125;finally &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125; &#125; //增加key对应的值 public &lt;T&gt; Long incr(KeyPrefix prefix, String key)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); //生成real key String realKey = prefix.getPrefix() + key; return jedis.incr(realKey); &#125;catch (Exception e)&#123; logger.error("redis连接池异常"+e.getMessage()); return null; &#125;finally &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125; &#125; //减少key对应的对象的值 public &lt;T&gt; Long decr(KeyPrefix prefix, String key)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); //生成real key String realKey = prefix.getPrefix() + key; return jedis.decr(realKey); &#125;catch (Exception e)&#123; logger.error("redis连接池异常"+e.getMessage()); return null; &#125;finally &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125; &#125; //bean对象准换为String private &lt;T&gt; String Bean2String(T value) &#123; if (value == null)&#123; return null; &#125; Class&lt;?&gt; clazz = value.getClass(); if (clazz == int.class || clazz == Integer.class)&#123; return ""+value; &#125;else if (clazz == String.class)&#123; return (String)value; &#125;else if (clazz == long.class || clazz == Long.class)&#123; return ""+value; &#125;else &#123; return JSON.toJSONString(value); &#125; &#125; //String转换为bean private &lt;T&gt; T String2Bean(String str, Class&lt;T&gt; clazz) &#123; if (str == null || str.length() &lt;0 || clazz == null)&#123; return null; &#125; if (clazz == int.class || clazz == Integer.class)&#123; return (T)Integer.valueOf(str); &#125;else if (clazz == String.class)&#123; return (T)str; &#125;else if (clazz == long.class || clazz == Long.class)&#123; return (T)Long.valueOf(str); &#125;else &#123; return JSON.toJavaObject(JSON.parseObject(str),clazz); &#125; &#125;&#125; 最后在controller中编写一个方法实现对service层的调用即可，就不赘述了。 踩过的坑运行程序发现报出异常 Could not get a resource from the pool。 其实也就是在执行 jedis = jedisPool.getResource();这一步时出错了 首先第一种可能是你的redis服务没开启，检查下。 确认开启了之后就修改你的redis.conf文件，把bind 127.0.0.1改成bind 0.0.0.0， ​ 也就是把redis的访问权限有只能本机访问改成所有的都能访问。 最后可能的原因有你的Linux的防火墙没有开放Redis的端口，可以配置打开，也可以直接关掉防火墙，我这里直接关掉了Linux的防火墙。 我用的是centos7 永久关闭防火墙的方法 1234//临时关闭systemctl stop firewalld//禁止开机启动systemctl disable firewalld 这样你再测试下，要是还不能用还有别的原因，可以自己上网去看一下具体怎么解决。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F01%2FHashTable%2F</url>
    <content type="text"><![CDATA[哈希表设计思想及实现定义哈希表在《算法4》这本书中是这么介绍的：哈希表其实又叫散列表，是算法在时间和空间上做出权衡的经典例子。如果一个表所有的键都是小整数，我们就可以用一个数组来实现无序的符号表，将键作为数组的索引而数组中i出存储的值就是它对应的值。其实散列表的思想也是这样的，只不过他的键的类型更加复杂，是这种简易方法的一种扩展。 使用散列查找分为两步： 用散列函数将被查找的键转换为数组的一个索引。理想情况下，不同的键值都会转换成为不同的索引值，但是一般情况下我们会遇到多个键对应相同的索引值，这也就是所谓的散列冲突。 处理碰撞冲突的情况，常用得方法有两种：拉链法（链地址法）和线性探测法，下面也会介绍这两种方法。 哈希函数其实要设计一个哈希表首先要做的就是散列函数的计算，通过散列函数就可以将键转换为数组的索引。其实哈希函数的设计是一个非常常见的一个研究方向，就像在我们的网络安全的密码设计的过程中，散列函数就是一个非常重要的理论。但是这里介绍的是最一般的哈希函数的设计思想。 哈希函数其实就是将键准换为索引，那么这里的键可以用什么数据类型呢？其实常见的基本数据类型都可以，甚至是我们自己定义的数据类型也是可以的。下面将分开展开介绍。 正整数对于小正整数的话直接用就可以了，对于小负整数的话进行一定的偏移就可以了，例如-100 - 100 —&gt; 0 - 200 对于大整数散列最常用的方法是除留余数法。 例如一个身份证号：332112200007076666这个的话取模，让他模10000，取后4位6666作为索引，这样带来好处是节省空间，因为我们显然不可能开辟那么大的空间去让身份证号称为索引，太浪费空间了。但是这样也带来了一定的问题就是碰撞冲突的问题。还有一个问题就是直接取模的话容易造成键值的分布不均匀。所以一般采用的方式是模一个大素数，为什么是模一个素数就可以避免不均匀的情况，这个其实是数论里的问题，不探讨，知道方法就可以了。 关于上面的情况举个例子介绍下： 1234510 % 4 = 2 10 % 7 = 320 % 4 = 0 20 % 7 = 630 % 4 = 2 30 % 7 = 240 % 4 = 0 40 % 7 = 550 % 4 = 2 50 % 7 = 1 那素数怎么取呢？给出一般的参考的取值 浮点数浮点数的话其实也是转换成为整数，然后使用除留余数法。 那浮点数怎么转换成为整数呢？我们知道浮点数其实在计算机中是二进制数存在的，将二进制数变为整数就可以了。 字符串其实字符串我们也可以将其看成是大整数来处理。 举个例子：$$166 = 1 10^2 + 6 10^1+ 6*10^0$$ $$code = cB^3+oB^2+dB^1+eB^0$$ $$hash(code) =(cB^3+oB^2+dB^1+eB^0)\%M$$ $$hash(code) =((((cB)+o)B+d)*B+e))\%M$$ $$hash(code) =((((c\%M)B+o)\%MB+d)\%M*B+e))\%M$$ 其实左后就准换成为上面公式的样子，其中B表示进制，M表示模的素数。 其实转换成代码就是下面这样的： 123int hash = 0;for(int i = 0; i &lt; s.length(); i++ ) hash = (hash * B + s.charAt(i))%M 组合类型所谓的组合类型也就是自定义的数据类型，也是可以转换成为大整数来处理。 例如我定义了一个Student的数据类型 Student：name , number,score: 计算student的散列值如下：$$hash(student) = (((student.name\%M)B + student.number)\%MB + student.socre)\%M$$ 链地址法（拉链法）链地址法的原理时如果遇到冲突，他就会在原地址新建一个空间，然后以链表结点的形式插入到该空间。下面从百度上截取来一张图片，可以很清晰明了反应下面的结构。比如说我有一堆数据{1,12,26,337,353…}，而我的哈希算法是H(key)=key mod 16，第一个数据1的哈希值f(1)=1，插入到1结点的后面，第二个数据12的哈希值f(12)=12，插入到12结点，第三个数据26的哈希值f(26)=10，插入到10结点后面，第4个数据337，计算得到哈希值是1，遇到冲突，但是依然只需要找到该1结点的最后链结点插入即可，同理353。 把一个值得hash值转换为一个数组的索引的代码如下： 123private int hash(K key)&#123; return (key.hashCode() &amp; 0x7ffffff)%M;&#125; 通过&amp; 0x7ffffff这种方式就可以将符号位屏蔽，也就是说我们就算是传入负数也没有关系。 上面的图是每个地址存的是一个链表，在java8中当冲突达到一定的数量的时候就会将链表转换为红黑树，我们下面的实现用地址存一个TreeMap（java中的TreeMap的底层其实就是用红黑树来实现的）来具体的实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.TreeMap;public class HashTable&lt;K, V&gt; &#123; private TreeMap&lt;K, V&gt;[] hashtable; private int size; private int M; public HashTable(int M)&#123; this.M = M; size = 0; hashtable = new TreeMap[M]; for(int i = 0 ; i &lt; M ; i ++) hashtable[i] = new TreeMap&lt;&gt;(); &#125; public HashTable()&#123; this(97); &#125; private int hash(K key)&#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public int getSize()&#123; return size; &#125; public void add(K key, V value)&#123; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(map.containsKey(key)) map.put(key, value); else&#123; map.put(key, value); size ++; &#125; &#125; public V remove(K key)&#123; V ret = null; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(map.containsKey(key))&#123; ret = map.remove(key); size --; &#125; return ret; &#125; public void set(K key, V value)&#123; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(!map.containsKey(key)) throw new IllegalArgumentException(key + " doesn't exist!"); map.put(key, value); &#125; public boolean contains(K key)&#123; return hashtable[hash(key)].containsKey(key); &#125; public V get(K key)&#123; return hashtable[hash(key)].get(key); &#125;&#125; 动态空间处理我们上实现的时候把M的值取成了固定值，这个时候我们来分析下他的时间复杂度： 如果放入哈希表中的元素的个数使N，每个地址中存放的元素的个数是N/M的，然后每个地址中存放的是TreeMap，也就是底层是红黑树，对于一个红黑树的查询一个元素的时间复杂度是O(logN/M)的。然而对于哈希表其实是查询的复杂度应该是O(1)的复杂度，因为底层就是数组，直接索引一个数组中的值也就是O(1)的复杂度。 但是这里明显不符合啊？其实就是开辟的空间是固定的导致的，我们需要进行动态空间处理。怎么处理呢？其实就是把和动态数组的处理是一样的。当元素的个数大于阈值的时候就扩大空间，小于阈值时就压缩空间，具体如下： 当平均每个地址承载的元素多过一定程度时就扩容：n/M &gt;= upperTol; 当平均每个地址承载的元素少于一定程度时就缩容：n/M &lt; lowerTol; 扩容的时候怎么去扩大，扩大成多少呢？因为空间的大小其实也就是我们要模的那个值，所以选取扩大空间大小是有要求的。其实扩大的参考值就是上面给出素数取值时一般参考的取值。 具体的实现如下： 123456789101112131415private void resize(int newM)&#123; TreeMap&lt;K, V&gt;[] newHashTable = new TreeMap[newM]; for(int i = 0 ; i &lt; newM ; i ++) newHashTable[i] = new TreeMap&lt;&gt;(); int oldM = M; this.M = newM; for(int i = 0 ; i &lt; oldM ; i ++)&#123; TreeMap&lt;K, V&gt; map = hashtable[i]; for(K key: map.keySet()) newHashTable[hash(key)].put(key, map.get(key)); &#125; this.hashtable = newHashTable; &#125; 开放地址法实现哈希表的另一种方式就是用大小为M的数组保存N个键值对，其中M &gt; N。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法给统称为开放地址散列表。 其实就是使用开放地址法来解决碰撞冲突的问题。具体的开放地址法是怎么来解决碰撞冲突的，书上给出的解释是这样的： 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import java.util.TreeMap;public class HashTable&lt;K extends Comparable&lt;K&gt;, V&gt; &#123; private final int[] capacity = &#123;53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469, 12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457, 1610612741&#125;; private static final int upperTol = 10; private static final int lowerTol = 2; private int capacityIndex = 0; private TreeMap&lt;K, V&gt;[] hashtable; private int size; private int M; public HashTable()&#123; this.M = capacity[capacityIndex]; size = 0; hashtable = new TreeMap[M]; for(int i = 0 ; i &lt; M ; i ++) hashtable[i] = new TreeMap&lt;&gt;(); &#125; private int hash(K key)&#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public int getSize()&#123; return size; &#125; public void add(K key, V value)&#123; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(map.containsKey(key)) map.put(key, value); else&#123; map.put(key, value); size ++; if(size &gt;= upperTol * M &amp;&amp; capacityIndex + 1 &lt; capacity.length)&#123; capacityIndex ++; resize(capacity[capacityIndex]); &#125; &#125; &#125; public V remove(K key)&#123; V ret = null; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(map.containsKey(key))&#123; ret = map.remove(key); size --; if(size &lt; lowerTol * M &amp;&amp; capacityIndex - 1 &gt;= 0)&#123; capacityIndex --; resize(capacity[capacityIndex]); &#125; &#125; return ret; &#125; public void set(K key, V value)&#123; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(!map.containsKey(key)) throw new IllegalArgumentException(key + " doesn't exist!"); map.put(key, value); &#125; public boolean contains(K key)&#123; return hashtable[hash(key)].containsKey(key); &#125; public V get(K key)&#123; return hashtable[hash(key)].get(key); &#125; private void resize(int newM)&#123; TreeMap&lt;K, V&gt;[] newHashTable = new TreeMap[newM]; for(int i = 0 ; i &lt; newM ; i ++) newHashTable[i] = new TreeMap&lt;&gt;(); int oldM = M; this.M = newM; for(int i = 0 ; i &lt; oldM ; i ++)&#123; TreeMap&lt;K, V&gt; map = hashtable[i]; for(K key: map.keySet()) newHashTable[hash(key)].put(key, map.get(key)); &#125; this.hashtable = newHashTable; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树思想详解及实现]]></title>
    <url>%2F2018%2F06%2F27%2FRedBlackTree%2F</url>
    <content type="text"><![CDATA[红黑树思想详解及实现从2-3树开始2-3树定义2-3树在《算法4》这本树中的定义是这样子的： 一棵2-3查找树或为一棵空树，或由以下节点组成： 2-节点，含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该节点，右链接指向的2-3树中的节点值都大于该节点。 3-节点，含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该节点，中连接指向的2-3树中的键值位于两个键值之间，右链接指向的2-3树的节点都大于该节点。 其实2-3树是一个绝对平衡的二分查找树，什么叫绝对平衡？就是叶子节点的高度是相同的，或者说任一节点到空节点的距离是相同的。 下图就是一棵2-3树： 2-3树如何维持绝对平衡2-3树维持平衡的过程其实就是当来一个一个节点的时候先与其要存储的位置的父亲节点进行融合，组成一个2节点，然后在来一个元素的话继续融合，然后这个时候其实这个节点是一个4节点，我们的2-3树中是没有4节点的，这个时候就将这个4节点退化成3个2节点。每次添加元素的时候都是这样的操作，当一个子节点添加成为4节点然后退化的时候成3个两节点的时候就需要将该根节点并到其父亲节点上。这样就可以保持树的平衡。 具体的的实现如下动画所示： 红黑树与2-3 树的等价性红黑树顾名思义红色和黑色的树，其实就是树中存在红色的节点和黑色的节点。那红色的节点和黑色的节点给带变什么意思呢？ 其实一个黑色的节点表示2-3树中的2-节点，一个黑色的节点加上其左孩子为红色的节点这两个节点表示3-节点。其实也就是黑色节点和作为其左孩子的红色节点是在树上的一层的。 然后看一个2-3树与红黑树等价的例子： 红黑树的性质 每个节点或者是红色的，或者是黑色的 根节点是黑色的 每一个叶子节点（最后的空节点）是黑色的 如果一个节点是红色的，其孩子节点都是黑色的 从任意一个节点到叶子节点经过的黑色的节点的数量是相同的 怎么理解这些性质呢？ 首先每个节点是红色或者黑色，红黑树中就这两种颜色的节点，没啥可说的。 然后是根节点是黑色的，为什么说根节点是黑色的呢？可以从2-3树的角度来理解，比方说2-3树的根节点是2-节点的，肯定是黑色的，然后手机3节点的也会退化成一个黑色节点带一个红色左孩子的节点，就算是空树，我们知道最后的空节点也是黑色的。这就与第3条性质吻合。 然后是叶子节点都是黑色的，也就是最后的空节点都是黑色的，其实他就是定义空的是黑色的。 接着是一个红色节点的两个孩子节点都是黑色的，首先反推一下，你想两个红色节连在一起，然后其父亲节点一定是有个黑色节点，那这样就对应成了2-3树中的4节点，明显是不成立的。然后正向看一下，对应2-3树中，一个红色节点肯定是一个3节点，其孩子节点要么是一个2节点要么是一个3节点，2节点的话肯定是黑色的，3节点的话也会是一个黑色节点带一个红色的左孩子节点，那链接在黑色节点上的肯定也是黑色的节点。 最后一条性质，从任意一个节点到叶子节点经过的黑色的节点的数量是相同的，红黑树是一颗绝对黑平衡的树，其实即使黑色节点构成的树是绝对平衡的，然后也可以从2-3树的角度理解，2-3树是一颗绝对平衡的树，不管2节点还是3-节点，其一定是由一个黑色节点的，所以黑色节点树就是绝对平衡的。所以从任意一个节点到叶子节点经过的黑色的节点的数量是相同的。 通过以上的定义我们就可以初始化一棵红黑树了 12345678910111213141516171819202122232425262728293031323334public class RedBlackTree&lt;K extends Comparable&lt;K&gt;, V&gt; &#123; private static final boolean BLACK = false; private static final boolean RED = true; /** * 树节点的底层实现 */ private class Node&#123; public K key; public V value; public boolean color; public Node leftNode; public Node rightnode; public Node(K key, V value)&#123; this.key = key; this.value = value; color = RED; //从红黑树的定义来看，每个节点初始化都是红色节点 leftNode = null; rightnode = null; &#125; &#125; private Node root; private int size; /** * 构造函数 */ public RedBlackTree()&#123; root = null; size = 0; &#125; 向红黑树中添加元素首先我们从2-3是树开始去理解添加元素的操作，要是向2-节点添加元素的话就是直接添加形成一个3-节点，要是向3-节点添加元素的话就是先形成4节点，然后退化成3个两节点，而且添加的话都是添加的红色的节点，然后通过一些列的变换可以让其变成符合要求的红黑树。 那向红黑树中添加元素需要考虑哪些问题呢？ 首先某一棵树中的根节点是黑色的，然后来一个元素，比他小，按照二分搜索树的规则，我们把它插入到根节点的左侧，并且是红色的节点，其实现在就相当于2-3树中的3-节点。正好满足要求不需要任何处理，直接添加即可。 当要插入的元素是大于黑色节点的话，需要将这个红色的节点插入到黑色节点的右侧，这时候是不满足红黑树的原则的，需要进行左旋转来让其满足红黑树的要求。 左旋转左旋转的具体过程如下： 其实就是将根节点作为原来孩子的左孩子节点。通过左旋转之后就可以使红黑树满足要求，但是还是需要对节点的颜色进行改变，因为当前的节点旋转之后节点的位置发生了改变，具体的就是让x节点的颜色变为原来节点的颜色，因为现在x是根节点了，原来根节点是什么颜色，现在x就是什么颜色。然后让原来的节点颜色变为红色，因为旋转之后还是3节点，为了保持其实3节点，所以就将原来的节点颜色变为红色。 具体代码实现如下： 123456789101112131415161718192021/** * 为了保持红黑树性质进行左旋转 // node x // / \ 左旋转 / \ // T1 x ---------&gt; node T3 // / \ / \ // T2 T3 T1 T2 * @param node node * @return */ private Node leftRotate(Node node)&#123; Node x = node.rightnode; node.rightnode = x.leftNode; x.leftNode = node; //变更节点的颜色，现在的根节点的颜色要与原来根节点颜色相同， //原来的根节点现在变成孩子节点，颜色是红色 x.color = node.color; node.color = RED; return x; &#125; 颜色反转插入元素的时候并不只会发生上面一种情况使其不满足红黑树的要求，例如向3节点中插入元素的时候，插入元素之后形成了具体就像下面这种情况： 那怎么去处理这样的情况呢？其实按照定义，这个4节点会退化成3个两节点，也就是让所有的树的节点的颜色变为黑色就可以了，但是3个两节点之后根节点我们还会向上去合并，所有将根节点变为红色。其实也就是我们将树节点的颜色反转一下就可以让其满足了红黑树的要求： 具体如下： 代码实现： 123456789/** * 颜色反转 * @param node node */ private void flipColors(Node node)&#123; node.leftNode.color = BLACK; node.rightnode.color = BLACK; node.color = RED; &#125; 右旋转还有一种添加元素导致的情况如下图： 其实也就是新添加的元素是添加在红色节点的左孩子上，这个时候就不满足红黑树中红色节点的左右孩子都是黑色的性质了，这个时候就需要右旋转处理。具体如下： 其实我们看右旋转完成之后，以为节点的颜色发生变化，还是和左旋转一样的方法去改变旋转后改变的节点的颜色。然后改变完成之后我们发现其是这时候树的样式是和颜色反转时候的情况是一样的，所以这时候进行一下颜色的反转就可以了。 具体的代码如下： 123456789101112131415161718192021/** * 为了保持红黑树性质进行右旋转 // node x // / \ 右旋转 / \ // x T2 -------&gt; y node // / \ / \ // y T1 T1 T2 * @param node node * @return */ private Node rightRotate(Node node)&#123; Node x = node.leftNode; // 右旋转 node.leftNode = x.rightnode; x.rightnode = node; x.color = node.color; node.color = RED; return x; &#125; 整合流程其实在添加元素的时候还有一种情况是需要考虑的，就是添加的元素添加的位置是红色节点的右孩子，这显然也是不满足红黑树的性质的。 这种情况怎么去处理呢？其实可以先37节点左旋转——&gt;然后42右旋转—-&gt;调整节点颜色——&gt;颜色反转其实完成了整个的操作，是添加进新的元素后的树也是满足红黑树的性质的。 具体的过程如下： 其实这个过程是组合了上面讨论的所有情况，所以既然这中情况是所有的问题都会考虑到的话，那其实就可以添加元素的时候组合成下面的过程： 也就是每次添加元素的时候只需要判断出现了那种情况，然后依次跳转到其需要进行的操作上去就可以了，不需要每个都进行重复的流程操作。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177package RedBlackTree;/** * 红黑树的底层简单实现 * @author WilsonSong * @date 2018/6/26 */public class RedBlackTree&lt;K extends Comparable&lt;K&gt;, V&gt; &#123; private static final boolean BLACK = false; private static final boolean RED = true; /** * 树节点的底层实现 */ private class Node&#123; public K key; public V value; public boolean color; public Node leftNode; public Node rightnode; public Node(K key, V value)&#123; this.key = key; this.value = value; color = RED; //从红黑树的定义来看，每个节点初始化都是红色节点 leftNode = null; rightnode = null; &#125; &#125; private Node root; private int size; /** * 构造函数 */ public RedBlackTree()&#123; root = null; size = 0; &#125; /** * 获取某个key对应的node * @param node node * @param key key * @return Node node */ public Node getNode(Node node,K key)&#123; if (node == null)&#123; return null; &#125; if (node.key.equals(key))&#123; return node; &#125;else if (node.key.compareTo(key) &gt; 0)&#123; return getNode(node.leftNode, key); &#125;else &#123; return getNode(node.rightnode, key); &#125; &#125; /** * 判断节点是否为红色 * @param node node * @return */ public boolean isRed(Node node)&#123; if (node == null)&#123; return BLACK; &#125; return node.color; &#125; /** * 为了保持红黑树性质进行左旋转 // node x // / \ 左旋转 / \ // T1 x ---------&gt; node T3 // / \ / \ // T2 T3 T1 T2 * @param node node * @return */ private Node leftRotate(Node node)&#123; Node x = node.rightnode; node.rightnode = x.leftNode; x.leftNode = node; //变更节点的颜色，现在的根节点的颜色要与原来根节点颜色相同， //原来的根节点现在变成孩子节点，颜色是红色 x.color = node.color; node.color = RED; return x; &#125; /** * 为了保持红黑树性质进行右旋转 // node x // / \ 右旋转 / \ // x T2 -------&gt; y node // / \ / \ // y T1 T1 T2 * @param node node * @return */ private Node rightRotate(Node node)&#123; Node x = node.leftNode; // 右旋转 node.leftNode = x.rightnode; x.rightnode = node; x.color = node.color; node.color = RED; return x; &#125; /** * 颜色反转 * @param node node */ private void flipColors(Node node)&#123; node.leftNode.color = BLACK; node.rightnode.color = BLACK; node.color = RED; &#125; /** * 添加元素 * @param key key * @param value value */ public void add(K key, V value)&#123; root = add(root, key, value); root.color = BLACK; //根节点的颜色一定是黑色的 &#125; /** * 递归的向以node为根节点的树中添加元素 * @param node node * @param key key * @param value value * @return 返回添加元素后的子树的根 */ private Node add(Node node, K key, V value)&#123; if (node == null)&#123; node = new Node(key, value); size ++; return node; &#125; if (node.key.compareTo(key) &gt; 0)&#123; node = add(node.leftNode, key, value); &#125;else if (node.key.compareTo(key) &lt; 0)&#123; node = add(node.rightnode, key, value); &#125;else &#123; node.value =value; &#125; //下面的每一步都要进行判断的，其实就是一个连接整合的过程 //右子树红色，左子树是黑色 if (isRed(node.rightnode) &amp;&amp; !isRed(node.leftNode)) node = leftRotate(node); //左子树为红色，左子树的左子树也为红色，右旋转 if (isRed(node.leftNode) &amp;&amp; isRed(node.leftNode.leftNode)) node = rightRotate(node); //左右子树均为红色，只要颜色反转即可 if (isRed(node.leftNode) &amp;&amp; isRed(node.rightnode)) flipColors(node); return node; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树， 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL树的思想及实现]]></title>
    <url>%2F2018%2F06%2F21%2FAVLTree%2F</url>
    <content type="text"><![CDATA[AVL树的思想及实现定义AVL树是高度平衡的二叉搜索树，按照二叉搜索树（Binary Search Tree）的性质，AVL首先要满足： 若它的左子树不为空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树。 AVL树的性质： 左子树和右子树的高度之差的绝对值不超过1 树中的每个左子树和右子树都是AVL树 每个节点都有一个平衡因子(balance factor–bf),任一节点的平衡因子是-1,0,1之一，(每个节点的平衡因子bf 等于右子树的高度减去左子树的高度 ) 下图就是一棵AVL Tree： 如下图，这棵树是非AVL树，因为其平衡因子是不满足要求的。 初始化AVL TreeAVL树是高度平衡的二分搜索树，所以其初始化的时候和二分搜索树是一样的，只不过因为要计算平衡因子，所以需要记录每个节点的高度。 1234567891011121314151617181920212223242526272829303132public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; &#123; /** * 节点私有类初始化 */ private class Node&#123; public K key; public V value; public int height; public Node leftNode; public Node rightNode; public Node(K key, V value)&#123; this.key = key; this.value = value; height = 1; leftNode = null; rightNode = null; &#125; &#125; private int size; //树空间 private Node root; //根节点 /** * 构造函数 */ public AVLTree()&#123; root = null; size = 0; &#125; 计算高度和平衡因子节点在初始化的时候的高度为1，然后树的初始化过程中会维护树的高度，所以获取节点的高度的话直接返回该节点的高度值就可以了。 平衡因子其实就是左子树的高度减去右子树的高度。 具体的实现如下： 123456789101112131415161718192021222324/** * 获取某一个节点的高度值 * @param node * @return */ public int getHeight(Node node)&#123; if (node == null)&#123; return 0; &#125; return node.height; &#125; /** * 获取某个节点的平衡因子 * 平衡因子其实就是左孩子的高度减去右孩子的高度,有正负 * @param node * @return */ public int balanceFactor(Node node)&#123; if (node == null)&#123; return 0; &#125; return getHeight(node.leftNode) - getHeight(node.rightNode); &#125; 验证二分搜索树的性质和平衡性AVL树是一颗高度平衡的二分搜索树，所以要满足二分搜索树的性质，也要满足平衡性。 验证是否是二分搜索树的话，二分搜索树的中序遍历之后的元素是满足顺序从大到小的顺序性的，所以可以用该性质来测试是否是二分搜索树。 平衡性就是判断平衡因子的绝对值是否大于0就可以了。 具体如下： 12345678910111213141516171819202122232425262728293031323334353637/** * 中序遍历 * @param node 以node为根的子树 * @param keys keys */ private void inOrder(Node node, ArrayList&lt;K&gt; keys)&#123; if (node == null)&#123; return; &#125; inOrder(node.leftNode, keys); //执行到node.leftNode == null的时候就跳出这一次的inOrder,执行下面的语句 keys.add(node.key); inOrder(node.rightNode,keys); &#125; /** * 是否是一颗平衡树 * @return */ public boolean isBalanced()&#123; return isBalanced(root); &#125; /** * 判断以node为根节点的树是否平衡 * 其实就是看树中每个节点的平衡因子的绝对值是否大于1 * @param node node * @return */ private boolean isBalanced(Node node)&#123; if (node == null)&#123; return true; &#125; if (balanceFactor(node) &gt; 1 || balanceFactor(node) &lt; -1)&#123; return false; &#125; return isBalanced(node.leftNode) &amp;&amp; isBalanced(node.rightNode); &#125; 维护平衡有的时候给树中添加或者删除元素的时候可能会破坏树的平衡，那怎么去维护书的平衡呢？ 右旋转当插入的元素位于不平衡节点的左侧的左侧的时候： 这个时候需要对8这个节点进行右旋转。 右旋转的具体的实现完成如下： 其实过程很简单就是将y的做节点换成x的有节点，然后x的右孩子指向y. 具体的过程如下： 12345678910111213141516171819202122232425/** * 对以node为根节点的树进行右旋转 // 对节点y进行向右旋转操作，返回旋转后新的根节点x // y x // / \ / \ // x T4 向右旋转 (y) z y // / \ - - - - - - - -&gt; / \ / \ // z T3 T1 T2 T3 T4 // / \ // T1 T2 * @param node node * @return 旋转后新的子树的根节点 */ public Node rightRoate(Node node)&#123; Node x = node.leftNode; Node T3 = x.rightNode; x.rightNode = node; node.leftNode = T3; //旋转完成之后更新树的高度,其实只有x和y的高度发生变化 x.height = Math.max(getHeight(x.leftNode), getHeight(x.rightNode)) + 1; node.height = Math.max(getHeight(node.leftNode), getHeight(node.rightNode)) + 1; return x; &#125; 左旋转当插入的元素位于不平衡节点的右侧的右侧的时候，需要进行左旋转，其实和右旋转是一个对称的过程，不在赘述，具体如下： 123456789101112131415161718192021222324/** * 对以node为根节点的树进行左旋转 // 对节点y进行向左旋转操作，返回旋转后新的根节点x // y x // / \ / \ // T1 x 向左旋转 (y) y z // / \ - - - - - - - -&gt; / \ / \ // T2 z T1 T2 T3 T4 // / \ // T3 T4 * @param node node * @return 返回旋转后新的子树的根 */ public Node leftRoate(Node node)&#123; Node x = node.rightNode; Node T2 = x.leftNode; x.leftNode = node; node.rightNode = T2; //旋转完成之后更新树的高度，其实只有x和y的高度发生变化 x.height = Math.max(getHeight(x.leftNode), getHeight(x.rightNode)) + 1; node.height = Math.max(getHeight(node.leftNode), getHeight(node.rightNode)) + 1; return x; &#125; 先左旋转后右旋转当插入的元素位于不平衡元素的左侧的右侧的时候需要先左旋转然后进行右旋转，为什么是这样的？ 如下图的情况： 对X进行了左旋转之后变成了上面介绍的需要进行右旋转的情况，这时候只需要在进行右旋转就可以维持平衡了。 先右旋转后左旋转当插入的元素位于不平衡元素的右侧的左侧的时候需要先左旋转然后进行右旋转，为什么是这样的？ 如下图的情况： 对X进行了右旋转之后变成了上面介绍的需要进行左旋转的情况，这时候只需要在进行左旋转就可以维持平衡了。 插入元素其实插入元素的过程是和二分搜索树是一样的，只不过AVL树多了一些操作，插入元素之后需要更新节点的高度，需要判断是否平衡，不平衡的话属于那种不平衡的情况需要进行什么操作来维护平衡？其实就是逻辑上的判断。 具体的实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 插入元素 * @param key * @param value */ public void add(K key, V value)&#123; root = add(root, key, value); &#125; /** * 向以node为根节点的树上插入 * @param node node * @param key key * @param value value * @return */ private Node add(Node node, K key, V value)&#123; if (node == null)&#123; node = new Node(key,value); size ++; return node; &#125; if (node.key.compareTo(key) &gt; 0)&#123; node.leftNode = add(node.leftNode, key, value); &#125;else if (node.key.compareTo(key) &lt; 0)&#123; node.rightNode = add(node.rightNode, key, value); &#125;else&#123; node.value = value; &#125; //更新树的高度 node.height = Math.max(getHeight(node.leftNode), getHeight(node.rightNode)) + 1; //LL if (balanceFactor(node) &gt; 1 &amp;&amp; (balanceFactor(node.leftNode) &gt; 0))&#123; node = rightRoate(node); &#125; //RR if (balanceFactor(node) &lt; -1 &amp;&amp; (balanceFactor(node.rightNode ) &gt; 0))&#123; node = leftRoate(node); &#125; //LR // y - y x // / \ / \ / \ // x T4 向左旋转(x) z T4 向右旋转 (y) z y // / \ - - - - - &gt; / \ - - - - - - - -&gt; / \ / \ // z T3 x T3 T1 T2 T3 T4 // / \ / \ // T1 T2 T1 T2 if (balanceFactor(node) &gt; 1 &amp;&amp; (balanceFactor(node.leftNode) &lt; 0))&#123; node.leftNode = leftRoate(node.leftNode); node = rightRoate(node); &#125; //RL // y - y z // / \ / \ / \ // T1 x 向右旋转(x) T1 z 向左旋转 (y) y x // / \ - - - - - &gt; / \ - - - - - - - -&gt; / \ / \ // z T4 T2 x T1 T2 T3 T4 // / \ / \ // T2 T3 T3 T4 if (balanceFactor(node) &lt; -1 &amp;&amp; (balanceFactor(node.rightNode) &gt; 0))&#123; node.rightNode = rightRoate(node.rightNode); node = leftRoate(node); &#125; return node; &#125; 删除元素其实删除元素的过程是和二分搜索树是一样的，删除叶子节点的话直接删除皆可以了，然后删除节点话需要找到该叶子节点的右子树中的最小值来重新成为该树的根节点，还有AVL树还多了一些操作，删除元素之后需要更新节点的高度，需要判断是否平衡，不平衡的话属于那种不平衡的情况需要进行什么操作来维护平衡？其实也还是逻辑上的判断。 具体实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * 删除某个节点对应的元素 * @param key * @return */ public V remove(K key)&#123; Node node = getNode(root,key); if (node == null)&#123; throw new IllegalArgumentException("Error"); &#125; root = remove(root, key); return node.value; &#125; /** * 返回树中最小的元素的节点 * @param node * @return */ public Node minimum(Node node)&#123; if (node == null)&#123; return null; &#125; if (node.leftNode == null)&#123; return node; &#125; return minimum(node.leftNode); &#125; /** * 删除node为节点的树中key的元素 * @param node * @param key * @return */ private Node remove(Node node, K key)&#123; if (node == null)&#123; return null; &#125; Node retNode; if (node.key.compareTo(key) &gt; 0)&#123; node.leftNode = remove(node.leftNode, key); retNode = node; &#125;else if (node.key.compareTo(key) &lt; 0)&#123; node.rightNode = remove(node.rightNode, key); retNode = node; &#125;else &#123; //左子树为空 if (node.leftNode == null)&#123; Node right = node.rightNode; node.rightNode = null; retNode = right; size--; &#125; //右子树为空 else if (node.rightNode == null)&#123; Node left = node.leftNode; node.leftNode = null; retNode = left; size --; &#125; //左右子树均不为空的时候 else &#123; // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.rightNode); successor.rightNode = remove(node.rightNode, successor.key); successor.leftNode = node.leftNode; node.leftNode = node.rightNode = null; retNode = successor; &#125; if (retNode == null)&#123; return null; &#125; retNode.height = Math.max(getHeight(retNode.rightNode), getHeight(retNode.leftNode)); //LL if (balanceFactor(retNode) &gt; 1 &amp;&amp; (balanceFactor(retNode.leftNode) &gt; 0))&#123; retNode = rightRoate(retNode); &#125; //RR if (balanceFactor(retNode) &lt; -1 &amp;&amp; (balanceFactor(retNode.rightNode ) &gt; 0))&#123; retNode = leftRoate(retNode); &#125; //LR if (balanceFactor(retNode) &gt; 1 &amp;&amp; (balanceFactor(retNode.leftNode) &lt; 0))&#123; retNode.leftNode = leftRoate(retNode.leftNode); retNode = rightRoate(retNode); &#125; //RL if (balanceFactor(node) &lt; -1 &amp;&amp; (balanceFactor(node.rightNode) &gt; 0))&#123; retNode.rightNode = rightRoate(retNode.rightNode); retNode = leftRoate(retNode); &#125; &#125; return retNode; &#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413package AVLTree;import java.util.ArrayList;/** * @author WilsonSong * @date 2018/6/20 */public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; &#123; /** * 节点私有类初始化 */ private class Node&#123; public K key; public V value; public int height; public Node leftNode; public Node rightNode; public Node(K key, V value)&#123; this.key = key; this.value = value; height = 1; leftNode = null; rightNode = null; &#125; &#125; private int size; //树空间 private Node root; //根节点 /** * 构造函数 */ public AVLTree()&#123; root = null; size = 0; &#125; /** * size * @return */ public int getSize()&#123; return size; &#125; /** * 树是否为空 * @return */ public boolean isEmpty()&#123; return size == 0; &#125; /** * 是否是二分搜索树 * 其实就是根据二分搜索树的性质中序遍历后是从小到大顺序排序，不满足该条件即不是二分搜索树 * @return */ public boolean isBST()&#123; ArrayList&lt;K&gt; keys = new ArrayList(); inOrder(root, keys); for ( int i = 1; i &lt; keys.size(); i++ )&#123; if (keys.get(i-1).compareTo(keys.get(i)) &gt; 0)&#123; return false; &#125; &#125; return true; &#125; /** * 中序遍历 * @param node 以node为根的子树 * @param keys keys */ private void inOrder(Node node, ArrayList&lt;K&gt; keys)&#123; if (node == null)&#123; return; &#125; inOrder(node.leftNode, keys); //执行到node.leftNode == null的时候就跳出这一次的inOrder,执行下面的语句 keys.add(node.key); inOrder(node.rightNode,keys); &#125; /** * 是否是一颗平衡树 * @return */ public boolean isBalanced()&#123; return isBalanced(root); &#125; /** * 判断以node为根节点的树是否平衡 * 其实就是看树中每个节点的平衡因子的绝对值是否大于1 * @param node node * @return */ private boolean isBalanced(Node node)&#123; if (node == null)&#123; return true; &#125; if (balanceFactor(node) &gt; 1 || balanceFactor(node) &lt; -1)&#123; return false; &#125; return isBalanced(node.leftNode) &amp;&amp; isBalanced(node.rightNode); &#125; /** * 获取某一个节点的高度值 * @param node * @return */ public int getHeight(Node node)&#123; if (node == null)&#123; return 0; &#125; return node.height; &#125; /** * 获取某个节点的平衡因子 * 平衡因子其实就是左孩子的高度减去右孩子的高度,有正负 * @param node * @return */ public int balanceFactor(Node node)&#123; if (node == null)&#123; return 0; &#125; return getHeight(node.leftNode) - getHeight(node.rightNode); &#125; /** * 对以node为根节点的树进行右旋转 // 对节点y进行向右旋转操作，返回旋转后新的根节点x // y x // / \ / \ // x T4 向右旋转 (y) z y // / \ - - - - - - - -&gt; / \ / \ // z T3 T1 T2 T3 T4 // / \ // T1 T2 * @param node node * @return 旋转后新的子树的根节点 */ public Node rightRoate(Node node)&#123; Node x = node.leftNode; Node T3 = x.rightNode; x.rightNode = node; node.leftNode = T3; //旋转完成之后更新树的高度,其实只有x和y的高度发生变化 x.height = Math.max(getHeight(x.leftNode), getHeight(x.rightNode)) + 1; node.height = Math.max(getHeight(node.leftNode), getHeight(node.rightNode)) + 1; return x; &#125; /** * 对以node为根节点的树进行左旋转 // 对节点y进行向左旋转操作，返回旋转后新的根节点x // y x // / \ / \ // T1 x 向左旋转 (y) y z // / \ - - - - - - - -&gt; / \ / \ // T2 z T1 T2 T3 T4 // / \ // T3 T4 * @param node node * @return 返回旋转后新的子树的根 */ public Node leftRoate(Node node)&#123; Node x = node.rightNode; Node T2 = x.leftNode; x.leftNode = node; node.rightNode = T2; //旋转完成之后更新树的高度，其实只有x和y的高度发生变化 x.height = Math.max(getHeight(x.leftNode), getHeight(x.rightNode)) + 1; node.height = Math.max(getHeight(node.leftNode), getHeight(node.rightNode)) + 1; return x; &#125; /** * 插入元素 * @param key * @param value */ public void add(K key, V value)&#123; root = add(root, key, value); &#125; /** * 向以node为根节点的树上插入 * @param node node * @param key key * @param value value * @return */ private Node add(Node node, K key, V value)&#123; if (node == null)&#123; node = new Node(key,value); size ++; return node; &#125; if (node.key.compareTo(key) &gt; 0)&#123; node.leftNode = add(node.leftNode, key, value); &#125;else if (node.key.compareTo(key) &lt; 0)&#123; node.rightNode = add(node.rightNode, key, value); &#125;else&#123; node.value = value; &#125; //更新树的高度 node.height = Math.max(getHeight(node.leftNode), getHeight(node.rightNode)) + 1; //LL if (balanceFactor(node) &gt; 1 &amp;&amp; (balanceFactor(node.leftNode) &gt; 0))&#123; node = rightRoate(node); &#125; //RR if (balanceFactor(node) &lt; -1 &amp;&amp; (balanceFactor(node.rightNode ) &gt; 0))&#123; node = leftRoate(node); &#125; //LR // y - y x // / \ / \ / \ // x T4 向左旋转(x) z T4 向右旋转 (y) z y // / \ - - - - - &gt; / \ - - - - - - - -&gt; / \ / \ // z T3 x T3 T1 T2 T3 T4 // / \ / \ // T1 T2 T1 T2 if (balanceFactor(node) &gt; 1 &amp;&amp; (balanceFactor(node.leftNode) &lt; 0))&#123; node.leftNode = leftRoate(node.leftNode); node = rightRoate(node); &#125; //RL // y - y z // / \ / \ / \ // T1 x 向右旋转(x) T1 z 向左旋转 (y) y x // / \ - - - - - &gt; / \ - - - - - - - -&gt; / \ / \ // z T4 T2 x T1 T2 T3 T4 // / \ / \ // T2 T3 T3 T4 if (balanceFactor(node) &lt; -1 &amp;&amp; (balanceFactor(node.rightNode) &gt; 0))&#123; node.rightNode = rightRoate(node.rightNode); node = leftRoate(node); &#125; return node; &#125; /** * 返回以node为根的子树的key所在的节点 * @param node * @param key * @return */ private Node getNode(Node node, K key)&#123; if (node == null)&#123; return null; &#125; if (node.key.equals(key))&#123; return node; &#125;else if (node.key.compareTo(key) &gt; 0)&#123; return getNode(node.leftNode, key); &#125;else &#123; return getNode(node.rightNode, key); &#125; &#125; /** * 是否包含k这个节点 * @param key key * @return */ public boolean contains(K key)&#123; return getNode(root, key) != null; &#125; /** * 返回key节点对应的value * @param key key * @return */ public V get(K key)&#123; Node node = getNode(root, key); return node == null? null : node.value; &#125; /** * 更新某个节点的值 * @param key * @param value */ public void set(K key, V value)&#123; Node node = getNode(root, key); if (node == null)&#123; throw new IllegalArgumentException("This key does not contains"); &#125; node.value = value; &#125; /** * 删除某个节点对应的元素 * @param key * @return */ public V remove(K key)&#123; Node node = getNode(root,key); if (node == null)&#123; throw new IllegalArgumentException("Error"); &#125; root = remove(root, key); return node.value; &#125; /** * 返回树中最小的元素的节点 * @param node * @return */ public Node minimum(Node node)&#123; if (node == null)&#123; return null; &#125; if (node.leftNode == null)&#123; return node; &#125; return minimum(node.leftNode); &#125; /** * 删除node为节点的树中key的元素 * @param node * @param key * @return */ private Node remove(Node node, K key)&#123; if (node == null)&#123; return null; &#125; Node retNode; if (node.key.compareTo(key) &gt; 0)&#123; node.leftNode = remove(node.leftNode, key); retNode = node; &#125;else if (node.key.compareTo(key) &lt; 0)&#123; node.rightNode = remove(node.rightNode, key); retNode = node; &#125;else &#123; //左子树为空 if (node.leftNode == null)&#123; Node right = node.rightNode; node.rightNode = null; retNode = right; size--; &#125; //右子树为空 else if (node.rightNode == null)&#123; Node left = node.leftNode; node.leftNode = null; retNode = left; size --; &#125; //左右子树均不为空的时候 else &#123; // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.rightNode); successor.rightNode = remove(node.rightNode, successor.key); successor.leftNode = node.leftNode; node.leftNode = node.rightNode = null; retNode = successor; &#125; if (retNode == null)&#123; return null; &#125; retNode.height = Math.max(getHeight(retNode.rightNode), getHeight(retNode.leftNode)); //LL if (balanceFactor(retNode) &gt; 1 &amp;&amp; (balanceFactor(retNode.leftNode) &gt; 0))&#123; retNode = rightRoate(retNode); &#125; //RR if (balanceFactor(retNode) &lt; -1 &amp;&amp; (balanceFactor(retNode.rightNode ) &gt; 0))&#123; retNode = leftRoate(retNode); &#125; //LR if (balanceFactor(retNode) &gt; 1 &amp;&amp; (balanceFactor(retNode.leftNode) &lt; 0))&#123; retNode.leftNode = leftRoate(retNode.leftNode); retNode = rightRoate(retNode); &#125; //RL if (balanceFactor(node) &lt; -1 &amp;&amp; (balanceFactor(node.rightNode) &gt; 0))&#123; retNode.rightNode = rightRoate(retNode.rightNode); retNode = leftRoate(retNode); &#125; &#125; return retNode; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL Tree</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集详解及底层实现]]></title>
    <url>%2F2018%2F06%2F16%2FUnionFind%2F</url>
    <content type="text"><![CDATA[并查集详解及底层实现定义并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。 并查集（Union/Find）从名字可以看出，主要涉及两种基本操作:合并和查找。这说明，初始时并查集中的元素是不相交的，经过一系列的基本操作(Union)，最终合并成一个大的集合。 而在某次合并之后，有一种合理的需求：某两个元素是否已经处在同一个集合中了？因此就需要Find操作。 并查集的基本的数据表示：每个元素id的对应一个集合。 然后这种结构使用数组来存储，这样的话Find操作就是索引其中的某个位置的元素，事件复杂度是O(1)。 然后Union操作的话需要遍历整个数组一遍，事件复杂度是O(n)的，时间复杂度大，对于存储的元素数据量变得很大的时候，就比较鸡肋了。 然后这里可以使用树结构来作为并查集的数据存储结构，其实就是将每个元素看做是一个节点，然后是一个集合中的元素就存储在一个树中，然后拥有相同的根节点。具体的如下： 基于这种树结构实现的Find和Union操作的时间复杂度都是O(logn)的，综合来说好一些。 Quick Union如何使用树结构来初始化并查集并且实现Quick Union操作，具体实现如下： 初始化的时候就是每个元素都是一棵树，并且根节点是指向自己的，表示每个元素是属于不同的集合的。 Union其实就是要将合并的元素指向其中某一个元素，由该元素作为根节点，指向同一个根节点的所有元素都是属于同一个集合的。 然后这样的Union操作其实是存在问题的，在合并的时候是可能将将树初始化成一个链表的如下如，这样的话树结构的优势就失去了。 我们并不希望出现这样的问题，那如何来完善呢？ 基于size的union优化我们可以新建一个空间来存储每棵树的size的大小，然后合并的时候讲size小的树合并到size大的树的根节点上，具体就如下图： 而不是这样去合并： 基于rank的union优化上面这样的方式其实避免了合并的时候合并成了链表，但是还有一个问题，就是如下图的合并： 明显还是有问题的，我们希望的合并其实是将左边的树合并到右边的树上，而不是像上面这样，这样其实也是增加了树的深度，我们的union操作的时间复杂度是和树的深度有关系的。我们希望的合并方式是如下图的： 这就是基于rank的合并方式。 我们需要新建一个存储空间，用rank(i)表示已i为根节点的树的深度。 路径压缩在find操作的时候，对于一个树，我们查找的时间复杂度其实也是和树的深度相关的，对于下面右边的树我们要find(4)也就是找4所在树（集合）的根节点，需要从末尾遍历到根部，但还是对于右边的话我们就不需要了，然后这两棵树是代表一样的集合。这就是路径压缩。 具体的实现其实就是将每次查找的元素的指向的节点指向其父亲节点的父亲节点。具体如下： 最后就是觉得上面压缩的还不是最优的，压缩成下面才是最优的，但是这种实现是需要递归的去实现，其实递归的过程本身也是需要付出代价的。所以这里讨论上面那种压缩的具体的实现。 其实这两种路径压缩的实现具体的实现上的不同之处就在于： 1234567891011private int find(int p)&#123; if (p &lt; 0 || p &gt; parent.length)&#123; throw new IllegalArgumentException("p is illegal"); &#125; while (parent[p] != p)&#123; parent[p] = parent[parent[p]]; p = parent[p]; //第一种压缩// parent[p] = find(parent[p]); //第二种压缩 &#125; return parent[p]; &#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package UnionFind;/** * 基于树结构并查集 * @author WilsonSong * @date 2018/6/15 */public class UnionFind implements UF &#123; private int[] parent; private int[] rank; /** * 并查集的初始化 * @param size */ public UnionFind(int size)&#123; parent = new int[size]; rank = new int[size]; for (int i = 0; i &lt; size; i++)&#123; parent[i] = i; rank[i] = 1; &#125; &#125; /** * 找到p所在的集合 * @param p 节点 * @return */ private int find(int p)&#123; if (p &lt; 0 || p &gt; parent.length)&#123; throw new IllegalArgumentException("p is illegal"); &#125; while (parent[p] != p)&#123; parent[p] = parent[parent[p]]; p = parent[p];// parent[p] = find(parent[p]); &#125; return parent[p]; &#125; /** * 查看元素p和元素q是否所属一个集合 * @param p * @param q * @return */ @Override public boolean isConnected(int p, int q)&#123; return find(p) == find(q); &#125; /** * 合并两个集合 * @param p * @param q */ @Override public void UnionElements(int p, int q)&#123; if (p &lt; 0 || q &lt; 0 || p &gt; parent.length || q &gt; parent.length)&#123; throw new IllegalArgumentException("index is illegal"); &#125; int pRoot = find(p); int qRoot = find(q); if (rank[pRoot] &gt; rank[qRoot])&#123; parent[qRoot] = pRoot; &#125;else if (rank[pRoot] &lt; rank[qRoot])&#123; parent[pRoot] = qRoot; &#125;else &#123; parent[pRoot] = pRoot; rank[pRoot] += 1; &#125; &#125;&#125; 时间复杂度其实我上面所说的O(logn)的是不准确的，具体的如下：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集， 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[segment tree(线段树)详解]]></title>
    <url>%2F2018%2F06%2F12%2FSegmentTree%2F</url>
    <content type="text"><![CDATA[segment tree(线段树)详解什么是线段树线段树是一棵平衡搜索树，但是不是完全二叉树，其实也是一棵二分搜索树，它储存的是一个区间的信息。 每个节点以结构体的方式存储，结构体包含以下几个信息： 区间左端点、右端点；（这两者必有） 区间内要维护的信息（实际情况而定，数目不等）。 一个具体的线段树如下所示，这里是一数组作为底层数据结构来阐述线段树，所以就简单的将线段树看为满二叉树，这样的话肯定是会造成空间的浪费，但是这里就是为了理解线段树这种数据结构，不去考虑其更高层的实现，要想空间不浪费的话就动态的创建线段树就可以了。 构建二叉树其实只要涉及到树的一些操作就避免不了使用递归的思想来创建树，以为每一棵树都是有一棵棵子树构成的. 主体的思路就是: 对于二分到的每一个结点，给它的左右端点确定范围。 如果是叶子节点，存储要维护的信息。 子树合并。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class SegmentTree&lt;E&gt; &#123; private E[] data; private E[] tree; private Merger&lt;E&gt; merger; public SegmentTree(E[] arr, Merger&lt;E&gt; merger)&#123; this.merger = merger; data = (E[]) new Object[arr.length]; for (int i = 0; i &lt; arr.length; i++)&#123; data[i] = arr[i]; &#125; tree = (E[])new Object[arr.length * 4 ]; //为保证树是一个满二叉树，包含n个节点最差的情况需要的空间是4n的，所以其中肯定有为空的节点 //其实线段是一颗平衡二叉树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1 buildSegmentTree(0,0,arr.length-1); //创建线段树 &#125; /** * 创建表示data区间[l...r]的线段树 * @param treeIndex 以treeIndex为起点 * @param L L * @param R R */ public void buildSegmentTree(int treeIndex, int L, int R)&#123; if ( L == R)&#123; tree[treeIndex] = data[L]; return; &#125; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); int mid = L + (R - L)/2; buildSegmentTree(leftTreeIndex, L, mid); buildSegmentTree(rightTreeIndex, mid + 1, R); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); &#125; ** * 返回左孩子节点的索引值 * @param index * @return */ public int leftChild(int index)&#123; return 2 * index + 1; &#125; /** * 返回右孩子节点的索引值 * @param index * @return */ public int rightChild(int index)&#123; return 2 * index + 2; &#125; 上面初始化树的空间的时候使用的空间大小是要存储的数组的大小的4倍，具体是怎么来的？ 对于一棵满二叉树，其第h层的元素有2^h-1个节点，并且第h层元素的节点的个数等于前1—&gt;h-1 层元素个数的总和。那么来看存储n个元素的时候需要多大的空间？需要4n的空间，具体如下图： 这里实现了Merger的接口，这个结接口就是用来应对对线段树的不同操作而设置的，用户可以根据自己想要实现的功能自己进行这个接口的具体实现。 123public interface Merger&lt;E&gt; &#123; E merge(E a, E b);&#125; 树的查询操作查询一个线段树其实使用递归的思想来实现，例如说我们要查询[2,5]这个区间内的元素，然后从根节点开始递归，[2,5]是在[0,7]之内的，然后求出根的左右孩子和中间分割点mid，查询区间的左右边界与mid比较，然后根据其满足的条件看需要在左子树还是右子树继续查询，不断递归直到找到要查询的区间。说的有点啰嗦了，具体看下面： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 返回区间[queryL, queryR]的值 * @param queryL queryL * @param queryR queryR * @return */ public E query(int queryL, int queryR)&#123; return query(0,0,data.length-1, queryL,queryR); &#125; /** * 以treeIndex为根的线段树中[l...r]的范围里，搜索区间[queryL...queryR]的值 * @param index * @param L * @param R * @param queryL * @param queryR * @return */ public E query(int index, int L, int R, int queryL, int queryR)&#123; if (queryL &lt; 0 || queryR &lt; 0|| queryL &gt; queryR || queryL &gt; data.length || queryR &gt; data.length)&#123; throw new IllegalArgumentException("Index is illegal"); &#125; if (L == queryL &amp;&amp; R == queryR)&#123; return tree[index]; &#125; int mid = L + (R - L)/2; int leftChildIndex = leftChild(index); int rightChildIndex = rightChild(index); if (queryL &gt; mid)&#123; return query(rightChildIndex, mid +1, R, queryL,queryR); &#125;else if (queryR &lt;= mid)&#123; return query(leftChildIndex, L, mid, queryL, queryR); &#125; E leftResult = query(leftChildIndex,L,mid, queryL, mid); E rightResult = query(rightChildIndex, mid+1, R, mid +1, queryR); return merger.merge(leftResult,rightResult); &#125; 树中元素的更新更新操作其实与查询操作的实现差不多，但是有一点区别的是，更新某个节点的匀速之后其父节点的元素也需要更新，因为其父节点也是包含该元素的，因此更新操作需要返回更新后状态。 具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637/** * 把索引为index位置的值更新为e * @param index index * @param e e */ public void set(int index, E e)&#123; data[index] = e; set(0, 0,data.length-1, index, e); &#125; /** * 更新以treeIndex为根节点的[L...R]区间内的index位置的元素的值 * @param treeIndex * @param L * @param R * @param index * @param e */ public void set(int treeIndex, int L, int R, int index, E e)&#123; if (index &lt; 0 || index &gt; R || index &lt; L ||index &gt; data.length-1)&#123; throw new IllegalArgumentException("Index is illegal"); &#125; if (L == R)&#123; tree[treeIndex] = e; &#125; int mid = L + (R - L)/2; int leftTreeChild = leftChild(treeIndex); int rightTreeChild = rightChild(treeIndex); if (index &lt;= mid)&#123; set(leftTreeChild, L, mid, index, e); &#125;else if (index &gt; mid )&#123; set(rightTreeChild, mid +1, R, index, e); &#125; tree[treeIndex] = merger.merge(tree[leftTreeChild], tree[rightTreeChild]); &#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166package SegmentTree;/** * 以数组作为底层的线段树的实现 * @author WilsonSong * @date 2018/6/12 */public class SegmentTree&lt;E&gt; &#123; private E[] data; private E[] tree; private Merger&lt;E&gt; merger; public SegmentTree(E[] arr, Merger&lt;E&gt; merger)&#123; this.merger = merger; data = (E[]) new Object[arr.length]; for (int i = 0; i &lt; arr.length; i++)&#123; data[i] = arr[i]; &#125; tree = (E[])new Object[arr.length * 4 ]; //为保证树是一个满二叉树，包含n个节点最差的情况需要的空间是4n的，所以其中肯定有为空的节点 //其实线段是一颗平衡二叉树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1 buildSegmentTree(0,0,arr.length-1); //创建线段树 &#125; /** * 创建表示data区间[l...r]的线段树 * @param treeIndex 以treeIndex为起点 * @param L L * @param R R */ public void buildSegmentTree(int treeIndex, int L, int R)&#123; if ( L == R)&#123; tree[treeIndex] = data[L]; return; &#125; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); int mid = L + (R - L)/2; buildSegmentTree(leftTreeIndex, L, mid); buildSegmentTree(rightTreeIndex, mid + 1, R); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); &#125; /** * 获取线段树的大小 * @return */ public int getSize()&#123; return data.length; &#125; /** * 获取元素 * @param index 元素索引 * @return */ public E get(int index)&#123; if (index &lt; 0 || index &gt; data.length)&#123; throw new IllegalArgumentException("index is illegal"); &#125; return data[index]; &#125; /** * 返回左孩子节点的索引值 * @param index * @return */ public int leftChild(int index)&#123; return 2 * index + 1; &#125; /** * 返回右孩子节点的索引值 * @param index * @return */ public int rightChild(int index)&#123; return 2 * index + 2; &#125; /** * 返回区间[queryL, queryR]的值 * @param queryL queryL * @param queryR queryR * @return */ public E query(int queryL, int queryR)&#123; return query(0,0,data.length-1, queryL,queryR); &#125; /** * 以treeIndex为根的线段树中[l...r]的范围里，搜索区间[queryL...queryR]的值 * @param index * @param L * @param R * @param queryL * @param queryR * @return */ public E query(int index, int L, int R, int queryL, int queryR)&#123; if (queryL &lt; 0 || queryR &lt; 0|| queryL &gt; queryR || queryL &gt; data.length || queryR &gt; data.length)&#123; throw new IllegalArgumentException("Index is illegal"); &#125; if (L == queryL &amp;&amp; R == queryR)&#123; return tree[index]; &#125; int mid = L + (R - L)/2; int leftChildIndex = leftChild(index); int rightChildIndex = rightChild(index); if (queryL &gt; mid)&#123; return query(rightChildIndex, mid +1, R, queryL,queryR); &#125;else if (queryR &lt;= mid)&#123; return query(leftChildIndex, L, mid, queryL, queryR); &#125; E leftResult = query(leftChildIndex,L,mid, queryL, mid); E rightResult = query(rightChildIndex, mid+1, R, mid +1, queryR); return merger.merge(leftResult,rightResult); &#125; /** * 把索引为index位置的值更新为e * @param index index * @param e e */ public void set(int index, E e)&#123; data[index] = e; set(0, 0,data.length-1, index, e); &#125; /** * 更新以treeIndex为根节点的[L...R]区间内的index位置的元素的值 * @param treeIndex * @param L * @param R * @param index * @param e */ public void set(int treeIndex, int L, int R, int index, E e)&#123; if (index &lt; 0 || index &gt; R || index &lt; L ||index &gt; data.length-1)&#123; throw new IllegalArgumentException("Index is illegal"); &#125; if (L == R)&#123; tree[treeIndex] = e; &#125; int mid = L + (R - L)/2; int leftTreeChild = leftChild(treeIndex); int rightTreeChild = rightChild(treeIndex); if (index &lt;= mid)&#123; set(leftTreeChild, L, mid, index, e); &#125;else if (index &gt; mid )&#123; set(rightTreeChild, mid +1, R, index, e); &#125; tree[treeIndex] = merger.merge(tree[leftTreeChild], tree[rightTreeChild]); &#125;&#125; 应用在LeetCode上有这么一道题： Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. Example: 12345Given nums = [1, 3, 5]sumRange(0, 2) -&gt; 9update(1, 2)sumRange(0, 2) -&gt; 8 Note: The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly. 这道题目其实就是动态查询某个数组区间内的和，一般的想法是进行预处理，就是把前i个元素的和求出来，然后每次求的时候就可以借助这个和来进行sumRange的操作，然后更新操作的话就是初始化一个新的数组存放原来nums的值，然后对其进行跟新，这样更新的话同时sum的和也需要更新，就是从更新的那个元素开始后面的元素的和全部要更新。事件复杂度nO(n)的，超时了。 然后这里要是使用线段树来做的话实现复杂度就是nO(logn)的，能够运行通过，具体如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175class NumArray &#123; private interface Merger&lt;E&gt; &#123; E merge(E a, E b); &#125; private class SegmentTree&lt;E&gt; &#123; private E[] tree; private E[] data; private Merger&lt;E&gt; merger; public SegmentTree(E[] arr, Merger&lt;E&gt; merger)&#123; this.merger = merger; data = (E[])new Object[arr.length]; for(int i = 0 ; i &lt; arr.length ; i ++) data[i] = arr[i]; tree = (E[])new Object[4 * arr.length]; buildSegmentTree(0, 0, arr.length - 1); &#125; // 在treeIndex的位置创建表示区间[l...r]的线段树 private void buildSegmentTree(int treeIndex, int l, int r)&#123; if(l == r)&#123; tree[treeIndex] = data[l]; return; &#125; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); // int mid = (l + r) / 2; int mid = l + (r - l) / 2; buildSegmentTree(leftTreeIndex, l, mid); buildSegmentTree(rightTreeIndex, mid + 1, r); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); &#125; public int getSize()&#123; return data.length; &#125; public E get(int index)&#123; if(index &lt; 0 || index &gt;= data.length) throw new IllegalArgumentException("Index is illegal."); return data[index]; &#125; // 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引 private int leftChild(int index)&#123; return 2*index + 1; &#125; // 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引 private int rightChild(int index)&#123; return 2*index + 2; &#125; // 返回区间[queryL, queryR]的值 public E query(int queryL, int queryR)&#123; if(queryL &lt; 0 || queryL &gt;= data.length || queryR &lt; 0 || queryR &gt;= data.length || queryL &gt; queryR) throw new IllegalArgumentException("Index is illegal."); return query(0, 0, data.length - 1, queryL, queryR); &#125; // 在以treeIndex为根的线段树中[l...r]的范围里，搜索区间[queryL...queryR]的值 private E query(int treeIndex, int l, int r, int queryL, int queryR)&#123; if(l == queryL &amp;&amp; r == queryR) return tree[treeIndex]; int mid = l + (r - l) / 2; // treeIndex的节点分为[l...mid]和[mid+1...r]两部分 int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if(queryL &gt;= mid + 1) return query(rightTreeIndex, mid + 1, r, queryL, queryR); else if(queryR &lt;= mid) return query(leftTreeIndex, l, mid, queryL, queryR); E leftResult = query(leftTreeIndex, l, mid, queryL, mid); E rightResult = query(rightTreeIndex, mid + 1, r, mid + 1, queryR); return merger.merge(leftResult, rightResult); &#125; // 将index位置的值，更新为e public void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= data.length) throw new IllegalArgumentException("Index is illegal"); data[index] = e; set(0, 0, data.length - 1, index, e); &#125; // 在以treeIndex为根的线段树中更新index的值为e private void set(int treeIndex, int l, int r, int index, E e)&#123; if(l == r)&#123; tree[treeIndex] = e; return; &#125; int mid = l + (r - l) / 2; // treeIndex的节点分为[l...mid]和[mid+1...r]两部分 int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if(index &gt;= mid + 1) set(rightTreeIndex, mid + 1, r, index, e); else // index &lt;= mid set(leftTreeIndex, l, mid, index, e); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append('['); for(int i = 0 ; i &lt; tree.length ; i ++)&#123; if(tree[i] != null) res.append(tree[i]); else res.append("null"); if(i != tree.length - 1) res.append(", "); &#125; res.append(']'); return res.toString(); &#125; &#125; private SegmentTree&lt;Integer&gt; segTree; public NumArray(int[] nums) &#123; if(nums.length != 0)&#123; Integer[] data = new Integer[nums.length]; for(int i = 0 ; i &lt; nums.length ; i ++) data[i] = nums[i]; segTree = new SegmentTree&lt;&gt;(data, (a, b) -&gt; a + b); &#125; &#125; public void update(int i, int val) &#123; if(segTree == null) throw new IllegalArgumentException("Error"); segTree.set(i, val); &#125; public int sumRange(int i, int j) &#123; if(segTree == null) throw new IllegalArgumentException("Error"); return segTree.query(i, j); &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * obj.update(i,val); * int param_2 = obj.sumRange(i,j); */]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>SegmentTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆树详解及使用最大堆实现优先队列]]></title>
    <url>%2F2018%2F06%2F12%2FMaxHeapAndPriorityQueue%2F</url>
    <content type="text"><![CDATA[堆树详解及使用最大堆实现优先队列定义堆树的定义如下： 堆树是一颗完全二叉树； 堆树中某个节点的值总是不大于或不小于其孩子节点的值； 堆树中每个节点的子树都是堆树。 当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆。 构造二叉堆这里是一自定义的动态数组作为底层来实现最大堆这种数据结构，使用数组存储二叉堆具有如下性质，如下如所示： 就是通过其中的任何一个节点可以找到其父节点或者是左孩子和右孩子节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Array&lt;E&gt; data; /** * 最大堆初始化 * @param capacity */ public MaxHeap(int capacity)&#123; data = new Array&lt;&gt;(capacity); &#125; /** * f返回某一节点的父节点 * @param index node * @return */ private int parent(int index)&#123; if (index == 0 || index &gt; data.getSize())&#123; throw new IllegalArgumentException(&quot;index has no parent node&quot;); &#125; return (index-1)/2; &#125; /** * 返回当前节点的左孩子节点 * @param index node * @return */ public int leftChild(int index)&#123; if (index == 0 || index &gt; data.getSize())&#123; throw new IllegalArgumentException(&quot;index has no parent node&quot;); &#125; return index * 2 + 1; &#125; /** * 返回当前节点的右孩子节点 * @param index * @return */ public int rightChild(int index)&#123; if (index == 0 || index &gt; data.getSize())&#123; throw new IllegalArgumentException(&quot;index has no parent node&quot;); &#125; return index * 2 + 2; &#125; 关于判断堆的大小及是否为空都是很简单的操作。就不在这里多说了。下面说一下最大堆中的sift up,sift down和heapify操作。 向堆中添加元素及sift up对于下面的一个堆，插入元素52时，因为我们使用的是数组存储的二叉堆，然后插入的元素需要满足二叉堆的性质，如果直接通过遍历数组来找到其位置，复杂度是O(n)的，这里采用的是sift up也就是先将元素插入堆的末尾，然后通过上浮操作来找到其位置，复杂度是O(logn)的。 sift up具体实现如下图： 具体的实现如下： 12345678910111213141516171819*** 添加元素* @param e*/public void add(E e)&#123; data.addLast(e); siftUp(data.getSize()-1);&#125;/*** 从节点index开始元素上浮* @param index*/public void siftUp(int index)&#123; while (index &gt; 0 &amp;&amp; data.get(parent(index)).compareTo(data.get(index)) &lt; 0 )&#123; data.swap(index, parent(index)); index = parent(index); &#125;&#125; 取出堆中最大元素及sift down通过性质我们可以知道对于一个最大堆来说，堆中最大的元素在堆顶。取出堆顶的元素之后谁去堆顶？这里采取的操作时将堆顶的62元素和堆底的16交换然后删除16，再将16下沉，找到其合适的位置。这样的复杂度只有O(logn). sift down 具体的实现如下： 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 取出堆中的最大元素 * @return */ public E extractMax()&#123; E ret = findMax(); data.swap(0, data.getSize()- 1); data.deleteLast(); siftDown(0); return ret; &#125; /** * 元素下沉操作 * @param index */ public void siftDown(int index)&#123; while (leftChild(index) &lt; data.getSize())&#123; if (rightChild(index) &lt; data.getSize() &amp;&amp; data.get(leftChild(index)).compareTo(data.get(rightChild(index))) &lt; 0)&#123; if (data.get(index).compareTo(data.get(rightChild(index))) &lt; 0)&#123; data.swap(index, rightChild(index)); index = rightChild(index); &#125; &#125; if (data.get(index).compareTo(data.get(leftChild(index))) &gt; 0)&#123; break; &#125; data.swap(index, leftChild(index)); index = leftChild(index); &#125; &#125; /** * 取出堆中的最大元素，并且替换成元素e * @param e 元素 * @return */ public E replace(E e)&#123; E ret = findMax(); data.set(0, e); siftDown(0); return ret; &#125; 将任意数组整理成最大堆和heapify一般随便一个数组是不符合最大堆的性质的，如何将一个数组整理成最大堆呢？寻常的想法是将数组中的n个元素不断的插入空堆中，这样操作的复杂度是O(nlogn)的，这里采用heapify的操作来实现，其实就是将不是叶子结点的元素全部采用下沉操作，找到自己的位置，时间复杂度为O(n)的。 heapify的操作具体如下： 具体的代码实现如下： 首先是数组的初始化 123456public Array(E[] arr)&#123; data = (E[])new Object[arr.length]; for(int i = 0 ; i &lt; arr.length ; i ++) data[i] = arr[i]; size = arr.length;&#125; 然后是最大堆中的实现： 1234567891011/*** heapify 操作* @param arr*/public MaxHeap(E[] arr)&#123; data = new Array&lt;&gt;(arr); int index= parent(arr.length-1); for (int i = 0; i &lt; index ; i++)&#123; siftDown(index); &#125;&#125; 替换堆中的任意元素是实现的方法比较简单，就是将堆中的最大元素由替换元素替换，然后进行下沉操作，O(logn)的时间复杂度 123456789101112 /** * 取出堆中的最大元素，并且替换成元素e * @param e 元素 * @return */public E replace(E e)&#123; E ret = findMax(); data.set(0, e); siftDown(0); return ret;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165package heap;import arrary.Array;/** * 最大堆 * @author WilsonSong * @date 2018/6/11 */public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Array&lt;E&gt; data; /** * 最大堆初始化 * @param capacity */ public MaxHeap(int capacity)&#123; data = new Array&lt;&gt;(capacity); &#125; /** * heapify 操作 * @param arr */ public MaxHeap(E[] arr)&#123; data = new Array&lt;&gt;(arr); int index= parent(arr.length-1); for (int i = 0; i &lt; index ; i++)&#123; siftDown(index); &#125; &#125; public MaxHeap()&#123; data = new Array&lt;&gt;(); &#125; /** * size * @return */ public int getSize()&#123; return data.getSize(); &#125; /** * 是否为空 * @return */ public boolean isEmpty()&#123; return data.isEmpty(); &#125; /** * f返回某一节点的父节点 * @param index node * @return */ private int parent(int index)&#123; if (index == 0 || index &gt; data.getSize())&#123; throw new IllegalArgumentException("index has no parent node"); &#125; return (index-1)/2; &#125; /** * 返回当前节点的左孩子节点 * @param index node * @return */ public int leftChild(int index)&#123; if (index == 0 || index &gt; data.getSize())&#123; throw new IllegalArgumentException("index has no parent node"); &#125; return index * 2 + 1; &#125; /** * 返回当前节点的右孩子节点 * @param index * @return */ public int rightChild(int index)&#123; if (index == 0 || index &gt; data.getSize())&#123; throw new IllegalArgumentException("index has no parent node"); &#125; return index * 2 + 2; &#125; /** * 添加元素 * @param e */ public void add(E e)&#123; data.addLast(e); siftUp(data.getSize()-1); &#125; /** * 从节点index开始元素上浮 * @param index */ public void siftUp(int index)&#123; while (index &gt; 0 &amp;&amp; data.get(parent(index)).compareTo(data.get(index)) &lt; 0 )&#123; data.swap(index, parent(index)); index = parent(index); &#125; &#125; /** * 最大堆中的元素 * @return */ public E findMax()&#123; if (data.getSize() == 0)&#123; throw new IllegalArgumentException("This Heap has no elements"); &#125; return data.get(0); &#125; /** * 取出堆中的最大元素 * @return */ public E extractMax()&#123; E ret = findMax(); data.swap(0, data.getSize()- 1); data.deleteLast(); siftDown(0); return ret; &#125; /** * 元素下沉操作 * @param index */ public void siftDown(int index)&#123; while (leftChild(index) &lt; data.getSize())&#123; if (rightChild(index) &lt; data.getSize() &amp;&amp; data.get(leftChild(index)).compareTo(data.get(rightChild(index))) &lt; 0)&#123; if (data.get(index).compareTo(data.get(rightChild(index))) &lt; 0)&#123; data.swap(index, rightChild(index)); index = rightChild(index); &#125; &#125; if (data.get(index).compareTo(data.get(leftChild(index))) &gt; 0)&#123; break; &#125; data.swap(index, leftChild(index)); index = leftChild(index); &#125; &#125; /** * 取出堆中的最大元素，并且替换成元素e * @param e 元素 * @return */ public E replace(E e)&#123; E ret = findMax(); data.set(0, e); siftDown(0); return ret; &#125;&#125; 作为底层的数组的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250package arrary;/** * 数组 * @author WilsonSong * @date 2018/5/28 */public class Array&lt;E&gt; &#123; private E[] data; private int size; /** * 构造函数，传入数组容量capacity * @param capacity 数组容量 */ public Array(int capacity)&#123; data = (E[])new Object[capacity]; size = 0; &#125; /** * 无参数的构造函数，默认数组容量为10 */ public Array()&#123; this(10); &#125; /** * 构造函数 * @param arr */ public Array(E[] arr)&#123; data = (E[])new Object[arr.length]; for(int i = 0 ; i &lt; arr.length ; i ++) data[i] = arr[i]; size = arr.length; &#125; /** * 获取数组的元素个数 * @return */ public int getSize()&#123; return size; &#125; /** * 获取数组的容量 * @return */ public int getCapacity()&#123; return data.length; &#125; /** * 判断数组是否为空 * @return */ public boolean isEmpty()&#123; return size == 0; &#125; /** * 交换数组中的任意两个元素 * @param i * @param j */ public void swap(int i, int j)&#123; if (i &lt; 0 || j &lt; 0 || i &gt; size || j &gt; size )&#123; throw new IllegalArgumentException("i or j do not in this array"); &#125; E ret = data[i]; data[i] = data[j]; data[j] = ret; &#125; /** * 向数组中指定位置插入元素 * @param index 插入位置 * @param e 插入表元素 */ public void add(int index, E e)&#123; if(size == data.length)&#123; resize(2*data.length); &#125; if (index &lt; 0 || index &gt; size)&#123; throw new IllegalArgumentException("Add failed. Required index &gt;= 0 &amp; index &lt;= size "); &#125; for (int i = size -1; i &gt;= index; i--)&#123; data[i+1] = data[i]; &#125; data[index] = e; size ++ ; &#125; /** * 向数组的末尾插入元素 * @param e 元素 */ public void addLast(E e)&#123; add(size, e); &#125; /** *向数组第一个位置插入元素 * @param e 元素 */ public void addFirst(E e)&#123; add(0,e); &#125; /** * 查询指定位置元素 * @param index * @return */ public E get(int index)&#123; if ( index &lt; 0||index &gt; size)&#123; throw new IllegalArgumentException("Get failed. Index is illegal."); &#125; return data[index]; &#125; public E getLast()&#123; return get(size -1); &#125; public E getFirst()&#123; return get(0); &#125; /** * 重设指定位置元素 * @param index * @return */ public void set(int index, E e)&#123; if ( index &lt; 0||index &gt; size)&#123; throw new IllegalArgumentException("Set failed. Index is illegal."); &#125; data[index] = e; &#125; /** * 查询是否包含某个元素 * @param e 查询的元素 * @return */ public boolean contains(E e)&#123; for (int i =0; i&lt;size; i++)&#123; if (data[i].equals(e))&#123; return true; &#125; &#125; return false; &#125; /** * 查询某个元素的位置，如果不存在元素e，则返回-1 * @param e 元素 * @return */ public int find(E e)&#123; for (int i = 0; i&lt; size; i++)&#123; if (data [i].equals(e))&#123; return i; &#125; &#125; return -1; &#125; /** * 删除索引位置的元素 * @param index 索引 * @return */ public E delete(int index)&#123; if (index &lt; 0 || index &gt; size)&#123; throw new IllegalArgumentException("Delete failed. Index is illegal."); &#125; E ret = data[index]; for (int i = index +1 ; i&lt; size; i++)&#123; data[i-1] = data[i]; &#125; size--; data[size] = null; if (size == data.length / 2)&#123; resize(data.length/2); &#125; return ret; &#125; /** * 删除第一个位置元素 * @return */ public E deleteFirst()&#123; return delete(0); &#125; /** * 删除最后一个位置元素 * @return */ public E deleteLast()&#123; return delete(size -1); &#125; /** * 删除元素 * @param e 元素 * @return */ public void deleteElement(E e)&#123; int index = find(e); if (index != -1)&#123; delete(index); &#125;else &#123; throw new IllegalArgumentException("Delete failed. Element is not exist"); &#125; &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append(String.format("Array: size = %d, capacity = %d.\n",size,getCapacity() )); res.append("["); for (int i = 0; i &lt; size; i++)&#123; res.append(data[i]); if (i != size -1)&#123; res.append(","); &#125; &#125; res.append("]"); return res.toString(); &#125; /** * 数组扩容 * @param newCapacity 数组容量 */ private void resize(int newCapacity)&#123; E[] newData = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++)&#123; newData[i] =data[i]; &#125; data = newData; &#125;&#125; 基于最大堆实现优先队列普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。优先队列有很多的实现方式，但通常采用堆数据结构来实现。因为这两者很像。 具体的实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041package heap;import queue.Queue;/** * 优先队列 * @author WilsonSong * @date 2018/6/11 */public class PriorityQueue&lt;E extends Comparable&lt;E&gt;&gt; implements Queue&lt;E&gt; &#123; private MaxHeap&lt;E&gt; maxHeap; public PriorityQueue()&#123; maxHeap = new MaxHeap&lt;&gt;(); &#125; @Override public int getSize()&#123; return maxHeap.getSize(); &#125; @Override public boolean isEmpty()&#123; return maxHeap.isEmpty(); &#125; @Override public E getFront()&#123; return maxHeap.findMax(); &#125; @Override public void enqueue(E e)&#123; maxHeap.add(e); &#125; @Override public E dequeue()&#123; return maxHeap.extractMax(); &#125;&#125; 应用统计前k个出现频次高的数字Given a non-empty array of integers, return the k most frequent elements. Example 1: 12Input: nums = [1,1,1,2,2,3], k = 2Output: [1,2] Example 2: 12Input: nums = [1], k = 1Output: [1] Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size 使用优先队列来解决这么问题比较方便，将前k个频次最高的元素放入队列，优先级高的元素出现的频次是这k个中最小的，然后只要有出现频次比他高的就可以替换掉。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package heap;import java.util.*;import java.util.PriorityQueue;/** * Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size. * @author WilsonSong * @date 2018/6/11 */public class heapSolution2 &#123; public static List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; /** * 定义一个频次的私有类 */ class Freq implements Comparable&lt;Freq&gt;&#123; public int e; public int freq; public Freq(int e, int freq)&#123; this.e = e; this.freq = freq; &#125; @Override public int compareTo(Freq anotherFreq)&#123; if (this.freq &lt; anotherFreq.freq) &#123; return -1; &#125; else if (this.freq &gt; anotherFreq.freq)&#123; return 1; &#125; else&#123; return 0; &#125; &#125; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums)&#123; if (!map.containsKey(num))&#123; map.put(num,1); &#125;else &#123; map.put(num, map.get(num) + 1); &#125; &#125; PriorityQueue&lt;Freq&gt; priorityQueue = new PriorityQueue&lt;&gt;(); //按照优先级排列，出现频次低的优先级高 for (int key : map.keySet())&#123; if (priorityQueue.size() &lt; k)&#123; priorityQueue.add(new Freq(key, map.get(key))); &#125;else &#123; if (map.get(key) &gt; priorityQueue.peek().freq)&#123; priorityQueue.remove(); priorityQueue.add(new Freq(key, map.get(key))); &#125; &#125; &#125; List list = new ArrayList(); while (!priorityQueue.isEmpty())&#123; list.add(priorityQueue.poll().e); &#125; return list; &#125; public static void main(String[] args)&#123; int[] array = &#123;1,2,2,3,3,3&#125;; List&lt;Integer&gt; list = topKFrequent(array,2); System.out.println(list.toString()); &#125;&#125; 然后觉得太复杂了，然后又改了改，就是存入hashmap之后，因为其出现的频次对应的是value的值，然后让hashmap根据value排序，然后输出即可。 hashmap根据value排序需要先将其视图存入list中，然后使用collections的排序方法来做，实现一个Comparator的比较器就可以了，代码化简不少。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package heap;import java.util.*;/** * Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size. * @author WilsonSong * @date 2018/6/11 */public class heapSolution &#123; public static List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums)&#123; if (!map.containsKey(num))&#123; map.put(num,1); &#125; map.put(num, map.get(num)+1); &#125; List&lt;Map.Entry&lt;Integer,Integer&gt;&gt; list1 = new ArrayList&lt;&gt;(); list1.addAll(map.entrySet()); Collections.sort(list1, new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123; @Override public int compare(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2) &#123; return o2.getValue().compareTo( o1.getValue()); &#125; &#125;); for (Map.Entry&lt;Integer, Integer&gt; mapping : list1)&#123; if (list.size() &gt;= k)&#123; break; &#125; list.add(mapping.getKey()); &#125; return list; &#125; public static void main(String[] args)&#123; int[] array = &#123;2,2,2,3,3,5,5,5,4,5,4,4,4,4,5&#125;; List&lt;Integer&gt; list = topKFrequent(array,2); System.out.println(list.toString()); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>最大堆， 优先队列， 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map及其底层简单实现]]></title>
    <url>%2F2018%2F06%2F08%2FMap%2F</url>
    <content type="text"><![CDATA[Map数据结构及其底层简单实现 其实Java中的map就是映射，叫字典也可以，其实map也是一种容器，在这里为了深入的去理解map这种数据结构，从底层自己简单的实现 一下。 使用链表作为底层基础来实现Map 其实链表这种数据结构我们知道其一般只包含next和value两个属性，但是其实你也可以多给他添加一个key的属性。这样的话就和我们的map这种数据结构很像了，具体的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public class LinkedListMap &lt;K,V&gt; implements Map&lt;K,V&gt; &#123; /** * 初始化链表 * 没有泛型的 */ private class Node&#123; public Node next; public K key; public V value; public Node (K key, V value, Node next)&#123; this.key = key; this.value = value; this.next = next; &#125; public Node(K key, V value)&#123; this.key = key; this.value = value; this.next = null; &#125; public Node()&#123; this(null, null, null); &#125; @Override public String toString()&#123; return key.toString() + " : " + value.toString(); &#125; &#125; public Node dummyHead; //虚拟头结点 public int size; //链表的大小 public LinkedListMap()&#123; dummyHead = new Node(); size = 0; &#125; /** * 获取size * @return */ @Override public int getSize()&#123; return size; &#125; /** * 链表是否为空 * @return */ @Override public boolean isEmpty()&#123; return size == 0; &#125; /** * 获取key对应的节点 * @param key key * @return */ private Node getNode(K key)&#123; Node cur = dummyHead.next; while (cur.next != null)&#123; if (cur.key.equals(key))&#123; return cur; &#125; cur = cur.next; &#125; return null; &#125; /** * 查询树中包含某个key * @param key * @return */ @Override public boolean contains(K key)&#123; return getNode(key) != null; &#125; /** * 向Map中添加元素 * @param key key * @param value value */ @Override public void add(K key, V value)&#123; if (!contains(key))&#123; Node prev = new Node(key,value); prev.next = dummyHead.next; dummyHead.next = prev; size ++; &#125; &#125; @Override public V remove(K key) &#123; if (!contains(key))&#123; throw new IllegalArgumentException("Error: Map do not contain this key"); &#125; Node prev = dummyHead; while (prev.next != null)&#123; if (prev.next.key.equals(key))&#123; Node delNode = prev.next; prev.next = delNode.next; delNode.next= null; size--; return delNode.value; &#125; prev = prev.next; &#125; return null; &#125; /** * 更新key对应的value * @param key key * @param newValue newValue */ public void set(K key, V newValue)&#123; Node node = getNode(key); if (node != null)&#123; node.value = newValue; &#125; if(node == null) throw new IllegalArgumentException(key + " doesn't exist!"); &#125; /** * 获取key对应的value * @param key key * @return */ @Override public V get(K key)&#123; return contains(key)? getNode(key).value : null; &#125;&#125; 使用二分搜索树的思想来实现 其实二分搜索树和用链表的思想来实现map的道理是一样的，每个树节点除了原来的value,左孩子和右孩子，你再添加一个key的属性就可以了，具体的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210public class BSTMap&lt;K extends Comparable&lt;K&gt;, V&gt; implements Map&lt;K, V&gt; &#123; /** * 二分搜索树节点的实现 */ private class Node&#123; public K key; public V value; public Node left; private Node right; public Node(K key, V value)&#123; this.key = key; this.value = value; this.left = null; this.right = null; &#125; &#125; public Node root; //树的根节点 public int size; //树的大小 public BSTMap()&#123; size = 0; root = null; &#125; /** * 树的大小 */ @Override public int getSize()&#123; return size; &#125; /** * 是否为空 * @return */ public boolean isEmpty()&#123; return size == 0; &#125; /** * 添加元素 * @param key * @param value */ public void add(K key, V value)&#123; root = add(root, key, value); &#125; /** * 递归的向node为节点的树中添加元素 * @param node * @param key * @param value * @return */ private Node add(Node node, K key, V value)&#123; if (node == null)&#123; size ++; return node = new Node(key,value); &#125; if (key.compareTo(node.key) &gt; 0)&#123; node.right = add(node.right,key,value); &#125;else if (key.compareTo(node.key) &lt; 0)&#123; node.left = add(node.left, key, value); &#125;else &#123; node.value = value; &#125; return node; &#125; /** * 递归查询key对应的节点 * @param node * @param key * @return */ private Node getNode(Node node,K key)&#123; if (node == null)&#123; return node; &#125; if (node.key.equals(key))&#123; return node; &#125;else if (node.key.compareTo(key) &gt; 0)&#123; return getNode(node.left, key); &#125;else&#123; return getNode(node.right, key); &#125; &#125; /** * 包含某个元素 * @param key * @return */ @Override public boolean contains(K key)&#123; return getNode(root,key)!= null; &#125; /** * 获取key对应的value * @param key * @return */ @Override public V get(K key)&#123; return contains(key)? getNode(root,key).value:null; &#125; /** * 更新key 对应的value * @param key * @param newValue */ @Override public void set(K key, V newValue)&#123; Node node = getNode(root, key); if (node == null)&#123; throw new IllegalArgumentException("Key don't exist"); &#125; node.value = newValue; &#125; /** * 返回以node为根的子树最小值的节点 * @param node */ public Node minimum(Node node)&#123; if (node == null)&#123; return node; &#125; else &#123; return minimum(node.left); &#125; &#125; /** * 删除以node为根节点的树中的最小元素，并返回新的子树的根 * @param node * @return */ public Node removeMin(Node node)&#123; if (node.left == null)&#123; Node delNode = minimum(node); node.left = delNode.right; delNode.right = null; size--; return node; &#125; node.left = removeMin(node.left); return node; &#125; /** * 删除key对应的节点，并返回该key对应的值 * @param key * @return */ @Override public V remove(K key)&#123; return contains(key)?remove(root, key).value: null; &#125; /** * 删除以node为子节点的树的值，并返回新的子树的根 * @param node * @param key * @return */ private Node remove(Node node, K key)&#123; if (node == null)&#123; return null; &#125; if (key.compareTo(node.key) &gt; 0)&#123; node.right = remove(node.right, key); return node; &#125; else if (key.compareTo(node.key) &lt; 0)&#123; node.left = remove(node.left, key); return node; &#125;else &#123; if (node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; if (node.right == null)&#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; Node successor = minimum(node); successor.left = node.left; successor.right = removeMin(node.right); node.left = null; node.right = null; return successor; &#125; &#125;&#125; 复杂度分析 使用二分搜索树和使用链表来实现map他的时间复杂度是不同的，因为这两种数据结构是不一样的，对于不同具体的是怎样的？如下表： LinkListMap BSTMap BSTMap BSTMap 严格讲(h树的深度) 平均 最差 增add O(n) O(h) O(logn) O(n) 删remove O(n) O(h) O(logn) O(n) 改set O(n) O(h) O(logn) O(n) 查get O(n) O(h) O(logn) O(n) 查contains O(n) O(h) O(logn) O(n) 其实对于正常情况下，链表因为一般从头到尾需要遍历一遍，一般对应的操作的时间复杂度是O(n)的； 对于二分搜索树，其实操作一般是二分查找，时间复杂度是和树的深度是相关的，所以是O(logn)的，但是也不排除特殊情况，当一棵树退化成链表的时候如下：这时候他的时间复杂度也就和链表是一样的了。 应用在LeetCode上有这么一道题目 12345678910Given two arrays, write a function to compute their intersection.Example 1:Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2]Example 2:Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [9,4] 这里使用map这种数据结构去来处理这个问题，其实就是把一个数组中的元素放入map中作为key,以为key是不可重复的，然后数组中有重复元素怎么办？就value这个属性存放元素的个数。然后不断地查询另一个数组中的元素在map中的数量，找到一个就存一个，然后map中该元素对应的数量就减一个，具体的实现就如下： 1234567891011121314151617181920212223public class MapSolution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; TreeSet&lt;Integer&gt; set = new TreeSet(); for (int num : nums1)&#123; set.add(num); &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int num : nums2)&#123; if (set.contains(num))&#123; list.add(num); set.remove(num); &#125; &#125; int[] a = new int[list.size()]; for (int i = 0; i &lt; list.size(); i++)&#123; a[i] = list.get(i); &#125; return a; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习总结之二分搜索树]]></title>
    <url>%2F2018%2F06%2F06%2FBinarySearchTree%2F</url>
    <content type="text"><![CDATA[二分搜索树定义二分搜索树（Binary Search Tree），也称二叉查找树，有序二叉树,排序二叉树，是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树。 没有键值相等的节点（no duplicate nodes）。 如下图就是一个二分搜索树，其本质就是一个二叉树，并且不一定是满的，而且元素要可比较大小。 优势 二分搜索树在某些方面是具有优势的，比如我们从时间复杂度上来分析一下： 实现二分搜索树的实现 简单的实现一下，通过一个私有类实现包含其所需的节点，值，左节点，右节点。 1234567891011121314151617181920212223public class BinarySearchTree&lt;E extends Comparable&lt;E&gt;&gt; &#123; /** * 定义树节点的私有类 * @param &lt;E&gt; */ private class Node&#123; public E e; public Node left, right; public Node(E e)&#123; this.e = e; left = null; right = null; &#125; &#125; private Node root; //根节点 private int size; //树的大小 public BinarySearchTree()&#123; root = null; size = 0; &#125; 向树中添加元素 其实插入元素使用递归的方式很容易，其核心思想:从根节点开始找插入的位置，满足二叉搜索树的特性，比左子节点大，比右子节点小. 具体的步骤： 从根节点开始，先比较当前节点，如果当前节点为null那么很明显就应该插入到这个节点。 如果上面的节点不是null，那么和当前节点比较，如果小于节点就往左子树放，如果大于节点就往右子树放。 然后分别对左子树或者右子树递归的递归进行如上1、2步骤的操作 此时就用到了递归，那么递归是对某一个问题，它的子问题需要是同样的模型。此处的一个小的问题就是：对某个node，然后进行操作，所以参数应该有个node才能实现循环起来。此处向以node为根的二叉搜索树中,插入节点value. 123456789101112131415161718192021222324252627282930/*** 添加元素* @param e 添加的元素*/public void add(E e)&#123; root = add(root, e);&#125;/*** 递归的添加元素* 向以node为根的二分搜索树中插入元素e，递归算法* 返回插入新节点后二分搜索树的根* @param node 树节点* @param e 元素* @return*/private Node add(Node node, E e)&#123; if (node == null)&#123; size ++; return new Node(e); &#125; if (e.compareTo(node.e) &gt; 0)&#123; node.right = add(node.right, e); &#125; if (e.compareTo(node.e) &lt; 0)&#123; node.left= add(node.left, e); &#125; return node;&#125; 注意 在这里抠一下关于递归添加元素这个函数为啥要返回插入新节点后二分搜索树的根， 比方说上面这棵树，我要添加元素12，执行递归的第一步之后，node节点其实是28这个根节点，然后执行 add(node.left, e); 其实就是像下面的树中添加元素，但是现在的节点还是28，执行完之后就是下面这棵树，返回以16为根节点的这棵树，然后赋值给node.left。其实就是相当于把这棵树连接到了28这个节点上。最后返回node也就是28这个节点，其实就是新添加元素之后的树。 查询树中包含某一个元素 其实查询包含树中是否包含某个元素与向树中添加一个元素的思路是类似的，都是通过递归的方式查询左右子树。 123456789101112131415161718192021222324252627/*** 查询是否包含元素* @param e 元素* @return*/public boolean contain(E e)&#123; return contains(root, e);&#125;/*** 递归的查询是否包含某个元素* @param node 树节点* @param e 元素* @return*/private boolean contains(Node node, E e)&#123; if (node == null)&#123; return false; &#125; if (e.compareTo(node.e) &lt; 0)&#123; return contains(node.left, e); &#125;else if (e.compareTo(node.e) &gt; 0)&#123; return contains(node.right, e); &#125;else &#123; return true; &#125;&#125; 树的遍历 其实树的遍历和图的遍历是一样的，分为两种，一种是广度优先遍历，一种是深度优先遍历。 深度优先遍历 深度优先遍历又分为三种： 前序遍历(Preorder Traversal)：先访问当前节点，再依次递归访问左右子树 中序遍历(Inorder Traversal)：先递归访问左子树，再访问自身，再递归访问右子树 后序遍历(Postorder Traversal)：先递归访问左右子树，最后再访问当前节点。 比如一棵树： 前序遍历的结果是：28–16–13–22–30–29–42 中序遍历的结果是：13–16–22–28–30–29–42 后序遍历的结果是：13–22–16–29–42–30–28 前序遍历的递归实现 递归实现的思想是非常简单的，从根节点开始，判断根节点是否有值，有则输出，然后递归的去处理器左子树，最后去处理其右子树。 1234567891011121314151617181920/*** 前序遍历*/public void preOrder()&#123; preOrder(root);&#125;/*** 递归前序遍历* @param node*/public void preOrder(Node node)&#123; if (node == null)&#123; return; &#125;else &#123; System.out.println(node.e); preOrder(node.left); preOrder(node.right); &#125;&#125; 前序遍历的非递归实现 关于前序遍历的非递归实现这里使用栈的方式，具体的思路如下： 具体的实现其实就是从根节点开始向堆栈中压入元素，然后弹出元素，然将该根节点的左右孩子按顺序压入堆栈，然后弹出栈顶元素，在将弹出的元素的左右孩子按顺序压入堆栈，不断的执行，直到树中没有元素，堆栈中就只弹出元素，直至堆栈为空。 具体的实现如下： 123456789101112131415161718/*** 非递归的实现二分搜索树的前序遍历*/public void preOrderNR()&#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty())&#123; Node cur = stack.pop(); System.out.println(cur.e); if (cur.right != null)&#123; stack.push(cur.right); &#125; if (cur.left != null)&#123; stack.push(cur.left); &#125; &#125;&#125; 中序遍历的递归实现1234567891011121314151617181920/*** 中序遍历*/public void inOrder()&#123; inOrder(root);&#125;/*** 递归的实现中序遍历* @param node 节点*/public void inOrder(Node node)&#123; if(node == null) return; inOrder(node.left); System.out.println(node.e); inOrder(node.right);&#125; 后序遍历的递归实现1234567891011121314151617181920/*** 后序遍历*/public void postOrder()&#123; postOrder(root);&#125;/*** 递归的实现后序遍历* @param node 节点*/private void postOrder(Node node)&#123; if(node == null) return; postOrder(node.left); postOrder(node.right); System.out.println(node.e);&#125; 广度优先遍历（层序遍历） 层序遍历的实现从根节点开，一次安深度往下遍历，按照先左孩子然后右孩子的方式遍历，这里使用队列的方式来实现层序遍历，具体的实现方式如下： 12345678910111213141516/*** 层序遍历*/public void levelOrder()&#123; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty())&#123; Node cur= queue.remove(); if (cur.left != null)&#123; queue.add(cur.left); &#125; if (cur.right != null)&#123; queue.add(cur.right); &#125; &#125;&#125; 删除书中的节点删除树中的最大元素和最小元素 首先是先要找到最大和最小元素，根据二分搜索树的性质我们可以很容易的就找到最大最小的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 查找树中最小元素 * @return */public E minimum()&#123; if (size == 0)&#123; throw new IllegalArgumentException("BST can not be empty"); &#125; return minimum(root).e;&#125;/** * 查找树中最小元素的节点 * @param node * @return */private Node minimum(Node node)&#123; if (node.left == null)&#123; return null; &#125; return minimum(node.left);&#125;/** * 查找树中最大元素 * @return */public E maximum()&#123; if (size == 0)&#123; throw new IllegalArgumentException("BST can not be empty"); &#125; return maximum(root).e;&#125;/** * 查找树中最大元素的节点 * @param node * @return */private Node maximum(Node node)&#123; if (node.right == null)&#123; return node; &#125; return maximum(node.right);&#125; 找到了最大个最小元素之后要将其删除，有需要注意的地方就是当树的结构如下时： 从图上我们可以看出，要是删除的最小元素还有右孩子或者要删除的最大元素还有左孩子的时候，就需要重新把待删除元素的根节点指向其孩子节点。 具体的实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * 查找树中最小元素 * @return */public E minimum()&#123; if (size == 0)&#123; throw new IllegalArgumentException("BST can not be empty"); &#125; return minimum(root).e;&#125;/** * 查找树中最小元素的节点 * @param node * @return */private Node minimum(Node node)&#123; if (node.left == null)&#123; return null; &#125; return minimum(node.left);&#125;/** * 查找树中最大元素 * @return */public E maximum()&#123; if (size == 0)&#123; throw new IllegalArgumentException("BST can not be empty"); &#125; return maximum(root).e;&#125;/** * 查找树中最大元素的节点 * @param node * @return */private Node maximum(Node node)&#123; if (node.right == null)&#123; return node; &#125; return maximum(node.right);&#125;/** * 删除最小元素 * @return 返回最小元素的值 */public E removeMin()&#123; E ret = minimum(); root = removeMin(root); return ret;&#125;/** * 删除最小元素的节点，并返回删除该节点之后新的二分搜索树的根 * @param node 树节点 * @return */public Node removeMin(Node node)&#123; if (node.left == null &amp;&amp; node.right != null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; node.left = removeMin(node.left); return node;&#125;/** * 删除最大元素，并返回最大元素的值 * @return */public E removeMax()&#123; E ret = maximum(); root = removeMax(root); return ret;&#125;/** * 删除最大元素节点并返回删除该节点之后新的二分搜索树的根 * @param node * @return */private Node removeMax(Node node)&#123; if (node.right == null &amp;&amp; node.left != null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; node.right = removeMax(node.right); return node;&#125; 删除树中任意节点 删除树中任意的节点需要考虑的问题就多一些了 首先删除的节点只有左孩子或者只有右孩子，这个时候其实是比较简单的，删除该节点后，其子节点有其父节点继承即可。如下： 但是当要删除的节点既有左孩子又有右孩子的时候就需要注意了，这里使用Hibbard Deletion方法来实现，具体如下： 其实核心的思想即使找到该节点中右子树中的最小节点来替代该节点成为新的节点。 具体的实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 从二分搜索树中删除元素为e的节点 * @param e 删除的元素 * @return */public void remove(E e)&#123; root = remove(root, e);&#125;/** * 删除掉以node为根的二分搜索树中值为e的节点, 递归算法，返回删除节点后新的二分搜索树的根 * @param e 删除的元素 *@param node 节点 * @return */private Node remove(Node node, E e)&#123; if( node == null ) return null; if( e.compareTo(node.e) &lt; 0 )&#123; node.left = remove(node.left , e); return node; &#125; else if(e.compareTo(node.e) &gt; 0 )&#123; node.right = remove(node.right, e); return node; &#125; else&#123; // e.compareTo(node.e) == 0 // 待删除节点左子树为空的情况 if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; // 待删除节点右子树为空的情况 if(node.right == null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125;&#125; 注意 这里删除的操作为什么需要返回删除元素之后的新的树的根节点其实和添加元素的道理是一样的，可以参照一下。一样的理解方式。 这样就完成了树的简单的实现 拓展 当然树还有很多的东西可以去设计，比方说把每个树的节点代表的含义设置的更加丰富 如：树节点除了存值，还存储以其为根节点的树的元素的个数，也就是树的size 或者是存储该节点在树中的深度 或者是把树设计成可以存储重复的元素，就是在该节点在存一个代表其元素个数的值。 总之树的拓展还有很多，待慢慢探索实现。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构， 二分搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之逻辑回归（Logistic Regression）与决策边界]]></title>
    <url>%2F2018%2F05%2F29%2FLogisticRegression%2F</url>
    <content type="text"><![CDATA[逻辑回归与决策边界what？逻辑回归其实是一个分类算法而不是回归算法。通常是利用已知的自变量来预测一个离散型因变量的值（像二进制值0/1，是/否，真/假）。简单来说，它就是通过拟合一个逻辑函数（logit fuction）来预测一个事件发生的概率。所以它预测的是一个概率值，自然，它的输出值应该在0到1之间。 Logistic回归简单分析: 优点：计算代价不高，易于理解和实现 缺点：容易欠拟合，分类精度可能不高 适用数据类型：数值型和标称型数据 基本原理按照我自己的理解，可以简单的描述为这样的过程： 找一个合适的预测函数，一般表示为h函数，该函数就是我们需要找的分类函数，它用来预测输入数据的判断结果。这个过程时非常关键的，需要对数据有一定的了解或分析，知道或者猜测预测函数的“大概”形式，比如是线性函数还是非线性函数。借助sigmoid函数构造出的预测函数形式一般为：$$h_{\theta }(x) = g(\theta ^{_{T}}x) = \frac{1}{1+e^{-\theta ^{T}x}}$$其中sigmoid函数为: 构造一个Cost函数（损失函数），该函数表示预测的输出（h）与训练数据类别（y）之间的偏差，可以是二者之间的差（h-y）或者是其他的形式。cost函数为：$$Cost(h_{\theta }x,y) = \begin{cases} -log(h_{\theta }(x))&amp; \text{ if } y=1 \ -log(1-h_{\theta }(x))&amp; \text{ if } y=0 \end{cases}$$综合考虑所有训练数据的“损失”，将Cost求和或者求平均，记为J(θ)函数，表示所有训练数据预测值与实际类别的偏差。J(θ函数一般为：$$J(\theta ) = -\frac{1}{m}[\sum_{i=1}^{m}(y_{i}logh_{\theta }(x_{i})+(1-y_{i})log(1-h_{\theta }(x_{i})))]$$ 显然，J(θ)函数的值越小表示预测函数越准确（即h函数越准确），所以这一步需要做的是找到J(θ)函数的最小值。找函数的最小值有不同的方法，Logistic Regression实现时用的是梯度下降法（Gradient Descent）。&emsp;关于详细的公式推导就不介绍了 伪代码12345678初始化线性函数参数为1构造sigmoid函数重复循环I次 计算数据集梯度 更新线性函数参数确定最终的sigmoid函数输入训练（测试）数据集运用最终sigmoid函数求解分类 代码实现逻辑回归的python代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import numpy as np from sklearn.metrics import accuracy_score class LogisticRegression: def __init__(self): """初始化Logistic Regression模型""" self.coef_ = None self.intercept_ = None self._theta = None def _sigmoid(self, t): return 1.0 / (1.0 + np.exp(-t)) def fit(self, X_train, y_train, eta=0.01, n_iters=1e4): """根据训练数据集X_train, y_train, 使用梯度下降法训练Logictic Regression模型""" assert X_train.shape[0] == y_train.shape[0], \ "the size of X_train must be equal to the size of y_train" def J(theta, X_b, y): y_hat = self._sigmoid(X_b.dot(theta)) try: return -np.sum(y*np.log(y_hat) + (1-y)*np.log(1-y_hat)) / len(y) except: return float('inf') '''逻辑回归''' def dJ(theta, X_b, y): return X_b.T.dot(self._sigmoid(X_b.dot(theta)) - y) / len(X_b) '''梯度下降法''' def gradient_descent(X_b, y, initial_theta, eta, n_iters=1e4, epsilon=1e-8): theta = initial_theta cur_iter = 0 while cur_iter &lt; n_iters: gradient = dJ(theta, X_b, y) last_theta = theta theta = theta - eta * gradient if (abs(J(theta, X_b, y) - J(last_theta, X_b, y)) &lt; epsilon): break cur_iter += 1 return theta X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) initial_theta = np.zeros(X_b.shape[1]) self._theta = gradient_descent(X_b, y_train, initial_theta, eta, n_iters) self.intercept_ = self._theta[0] self.coef_ = self._theta[1:] return self def predict_proba(self, X_predict): """给定待预测数据集X_predict，返回表示X_predict的结果概率向量""" assert self.intercept_ is not None and self.coef_ is not None, \ "must fit before predict!" assert X_predict.shape[1] == len(self.coef_), \ "the feature number of X_predict must be equal to X_train" X_b = np.hstack([np.ones((len(X_predict), 1)), X_predict]) return self._sigmoid(X_b.dot(self._theta)) def predict(self, X_predict): """给定待预测数据集X_predict，返回表示X_predict的结果向量""" assert self.intercept_ is not None and self.coef_ is not None, \ "must fit before predict!" assert X_predict.shape[1] == len(self.coef_), \ "the feature number of X_predict must be equal to X_train" proba = self.predict_proba(X_predict) return np.array(proba &gt;= 0.5, dtype='int') def score(self, X_test, y_test): """根据测试数据集 X_test 和 y_test 确定当前模型的准确度""" y_predict = self.predict(X_test) ''''分类的准确度''' return accuracy_score(y_test, y_predict) def __repr__(self): return "LogisticRegression() 上述结果为本次测试数据,可以看出来该数据集其实是三维的数据，因为逻辑回归只能解决二分类的问题，因此取数据集中的前两维数据，作为两种类别，因此使用该数据集可以用来判断逻辑回归测试结果的好坏 测试代码： 12345678from playML.model_selection import train_test_splitfrom playML.LogisticRegression import LogisticRegressionx_train, x_test, y_train, y_test = train_test_split(x, y, seed=666)log_reg = LogisticRegression()log_reg.fit(x_train, y_train)log_reg.score(x_test, y_test)log_reg.predict_proba(x_test) 输出的测试结果： 0.98664939, 0.14852024, 0.17601199, 0.0369836 ,0.0186637 , 0.04936918, 0.99669244, 0.97993941, 0.74524655,0.04473194, 0.00339285, 0.26131273, 0.0369836 , 0.84192923,0.79892262, 0.82890209, 0.32358166, 0.06535323, 0.20735334])```1234567891011121314151617 对于上述简单的测试数据，输出的array中的数据表示将某个数据分类成某一类别的概率，越接近于0就越趋近于分类成0这个类别，同理越趋近与1，就越趋近于分类成1，最后的分类的测试值输出为1.### 决策边界怎么对新输入的数据进行预测分类呢？ 每输入一个值&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&#123;_&#123;b&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&#123;_&#123;b&#125;&#125;&quot; title=&quot;x^&#123;_&#123;b&#125;&#125;&quot; /&gt;&lt;/a&gt;，与\theta ^&#123;T&#125;点乘，&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&#123;_&#123;b&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&#123;_&#123;b&#125;&#125;&quot; title=&quot;x^&#123;_&#123;b&#125;&#125;&quot; /&gt;&lt;/a&gt;·$\theta ^&#123;T&#125;$&gt;0，p&gt;0.5，&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&#123;_&#123;b&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&#123;_&#123;b&#125;&#125;&quot; title=&quot;x^&#123;_&#123;b&#125;&#125;&quot; /&gt;&lt;/a&gt;·$\theta ^&#123;T&#125;$&lt;0，p&lt;0.5,这样就能实类别的分类。当&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&#123;_&#123;b&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&#123;_&#123;b&#125;&#125;&quot; title=&quot;x^&#123;_&#123;b&#125;&#125;&quot; /&gt;&lt;/a&gt;·$\theta ^&#123;T&#125;$=0就称为该分类的决策边界。 然后使用上面简单的数据集，绘制决策边界，其实也就是分类的边界，当有新的数据的时候骡子坳那边就分类为该类别。```pythondef x2(x1):return (-log_reg.coef_[0] * x1 - log_reg.intercept_) / log_reg.coef_[1]x1_plot = np.linspace(4, 8, 1000)x2_plot = x2(x1_plot)plt.scatter(x[y==0,0], x[y==0,1], color=&apos;red&apos;)plt.scatter(x[y==1,0], x[y==1,1], color=&apos;blue&apos;)plt.plot(x1_plot, x2_plot)plt.show() 得到的结果如下： 上述的决策边界是一条直线，所以不严格的说还是属于线性分类，当分类数据不线性的时候就需要不规则的决策边界。 举个例子使用KNN算法来对上述数据进行分类： 123456789from sklearn.neighbors import KNeighborsClassifierknn_clf = KNeighborsClassifier()knn_clf.fit(x_train, y_train)knn_clf.score(x_test, y_test)plot_decision_boundary(knn_clf, axis=[4, 7.5, 1.5, 4.5])plt.scatter(x[y==0,0], x[y==0,1])plt.scatter(x[y==1,0], x[y==1,1])plt.show() 结果如下： 可以看出通过使用KNN方法对上述数据的决策边界就是不规则的 因为KNN是支持多类别数据的分类的，然后我们的数据集也是3中类别的，所以测试下KNN在三分类中的分类的效果。 12345678knn_clf_all = KNeighborsClassifier()knn_clf_all.fit(iris.data[:,:2], iris.target)# 欠拟合plot_decision_boundary(knn_clf_all, axis=[4, 8, 1.5, 4.5])plt.scatter(iris.data[iris.target==0,0], iris.data[iris.target==0,1])plt.scatter(iris.data[iris.target==1,0], iris.data[iris.target==1,1])plt.scatter(iris.data[iris.target==2,0], iris.data[iris.target==2,1])plt.show() 得到的结果如下： 可以看出分类的结果是非常的不规则的，其实也就是应该是发生了过拟合的问题。 对于KNeighborsClassifier()这个函数其实其中有一个参数是可以调节的,就是n_neighbors这个参数，可以直接运行 knn_clf_all = KNeighborsClassifier()查看其中的参数，n_neighbors这个参数的含义其实就是分类的复杂程度，越小的话越复杂，就容易出现过拟合的问题。这里调节下这个参数看一下效果，设置knn_clf_all = KNeighborsClassifier(n_neighbors = 50)，其余代码相同 得到的结果如下: 明显能够看出来决策边界规则了许多，但是相应的分类效果弱了一些，所以调参，调参。 上面的数据集是可以线性分类的，当数据的类别线性不可分的时候，逻辑回归的方式怎么去处理呢？举个例子： 当数据集是这样的，显然线性不可分，决策边界是不规则类似于圆。其实这个时候就需要类似于使用多项式回归的方式来处理。给逻辑回归中添加多项式。 1234567891011121314151617181920212223242526272829303132333435363738from sklearn.pipeline import Pipelinefrom sklearn.preprocessing import PolynomialFeaturesfrom sklearn.preprocessing import StandardScalerfrom playML.LogisticRegression import LogisticRegressionlog_reg = LogisticRegression()def plot_decision_boundary(model, axis):x0, x1 = np.meshgrid(np.linspace(axis[0], axis[1], int((axis[1]-axis[0])*100)).reshape(-1,1),np.linspace(axis[2], axis[3], int((axis[3]-axis[2])*100)).reshape(-1,1))X_new = np.c_[x0.ravel(), x1.ravel()]y_predict = model.predict(X_new)zz = y_predict.reshape(x0.shape)from matplotlib.colors import ListedColormapcustom_cmap = ListedColormap(['#EF9A9A','#FFF59D','#90CAF9'])plt.contourf(x0, x1, zz, linewidth=5, cmap=custom_cmap)#多项式def PolynomialLogisticRegression(degree):return Pipeline([('poly', PolynomialFeatures(degree=degree)), #多项式参数('std_scaler', StandardScaler()), #标准化（归一化）('log_reg', LogisticRegression()) #逻辑回归对象])poly_log_reg = PolynomialLogisticRegression(degree=2)poly_log_reg.fit(X, y)plot_decision_boundary(poly_log_reg, [-4, 4, -4, 4])plt.scatter(X[y==0,0], X[y==0,1])plt.scatter(X[y==1,0], X[y==1,1])plt.show()print("准确度：" + str(poly_log_reg.score(X, y))) 得到如下的结果： 可以看出添加了多项式的逻辑回归可以解决非线性可分的问题。 逻辑回归中使用正则化处理过拟合的问题因为数据线性不可分的时候，需要在逻辑回归中引入多项式，这也使得分类变得复杂，容桂产生过拟合的问题，解决方法有两个，一个是调节degree参数，另一种就是正则化。通用的正则化的方式就是在J(θ)函数中加一个正则项，使用J(θ）+aL2作为新的损失函数。a用来调节J(θ)和L2各自所占比重。这里C·J(θ）+L1作为所示函数，其实C也是用来平衡J(θ)和L1，原理是一样的。L1和L2是正则化中的一个重要的参数。 1234567891011121314151617181920from sklearn.linear_model import LogisticRegressionfrom sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=666)def PolynomialLogisticRegression2(degree, C, penalty='l2'):return Pipeline([('poly', PolynomialFeatures(degree=degree)),('std_scaler', StandardScaler()),('log_reg', LogisticRegression(C=C, penalty=penalty))])poly_log_reg2 = PolynomialLogisticRegression2(degree=10, C=13, penalty='l1')poly_log_reg2.fit(X_train, y_train)plot_decision_boundary(poly_log_reg2, [-4, 4, -4, 4])plt.scatter(X[y==0,0], X[y==0,1])plt.scatter(X[y==1,0], X[y==1,1])plt.show() 说实话这里选取的数据集的代表性不太够，没有太突出正则化的优点，注重点在方法的实现上，但是还是能看出有一点区别的，决策边界更加清楚了。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习，逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之线性回归（Linear Regression）]]></title>
    <url>%2F2018%2F05%2F25%2FLinearRegression%2F</url>
    <content type="text"><![CDATA[线性回归概念线性回归(Linear Regression)是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。 回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。 其特点为： 解决回归问题 思想简单，实现容易 许多强大的非线性模型的基础 结果具有很好的可解释性 蕴含机器学习中的很多重要思想 简单线性回归的实现下面我们来举例何为一元线性回归分析: 首先假设有这样一组数据 从数据中我们可以看出，可以找到一条直线实现数据的拟合，这条直线设为 y=ax+b 那怎么计算a和b的参数，公式如下: jupyter notebook中具体的代码实现： 12345678910111213141516x_mean = np.mean(x)y_mean = np.mean(y)#分子num = 0.0#分母d = 0.0for x_i, y_i in zip(x, y):num += (x_i - x_mean) * (y_i - y_mean)d += (x_i - x_mean) ** 2a = num/db = y_mean - a*x_meany_hat = a*x + bplt.scatter(x,y)plt.plot(x,y_hat,color="r")plt.axis([0,6,0,6])plt.show() 得到了拟合数据的直线： 这里还可以在底层自己实现线性回归的算法，然后在jupyter notebook中调用，相应的pycharm的代码为： import numpy as np from sklearn.metrics import r2_score class LinearRegression: def __init__(self): &quot;&quot;&quot;初始化Linear Regression模型&quot;&quot;&quot; self.coef_ = None self.intercept_ = None self._theta = None def fit_normal(self, X_train, y_train): &quot;&quot;&quot;根据训练数据集X_train, y_train训练Linear Regression模型&quot;&quot;&quot; assert X_train.shape[0] == y_train.shape[0], \ &quot;the size of X_train must be equal to the size of y_train&quot; X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) self._theta = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y_train) self.intercept_ = self._theta[0] self.coef_ = self._theta[1:] return self def fit_gd(self, X_train, y_train, eta=0.01, n_iters=1e4): &quot;&quot;&quot;根据训练数据集X_train, y_train, 使用梯度下降法训练Linear Regression模型&quot;&quot;&quot; assert X_train.shape[0] == y_train.shape[0], \ &quot;the size of X_train must be equal to the size of y_train&quot; def J(theta, X_b, y): try: return np.sum((y - X_b.dot(theta)) ** 2) / len(y) except: return float(&apos;inf&apos;) def dJ(theta, X_b, y): # res = np.empty(len(theta)) # res[0] = np.sum(X_b.dot(theta) - y) # for i in range(1, len(theta)): # res[i] = (X_b.dot(theta) - y).dot(X_b[:, i]) # return res * 2 / len(X_b) return X_b.T.dot(X_b.dot(theta) - y) * 2. / len(X_b) def gradient_descent(X_b, y, initial_theta, eta, n_iters=1e4, epsilon=1e-8): theta = initial_theta cur_iter = 0 while cur_iter &lt; n_iters: gradient = dJ(theta, X_b, y) last_theta = theta theta = theta - eta * gradient if (abs(J(theta, X_b, y) - J(last_theta, X_b, y)) &lt; epsilon): break cur_iter += 1 return theta X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) initial_theta = np.zeros(X_b.shape[1]) self._theta = gradient_descent(X_b, y_train, initial_theta, eta, n_iters) self.intercept_ = self._theta[0] self.coef_ = self._theta[1:] return self def fit_sgd(self, X_train, y_train, n_iters=5, t0=5, t1=50): &quot;&quot;&quot;根据训练数据集X_train, y_train, 使用梯度下降法训练Linear Regression模型&quot;&quot;&quot; assert X_train.shape[0] == y_train.shape[0], \ &quot;the size of X_train must be equal to the size of y_train&quot; assert n_iters &gt;= 1 def dJ_sgd(theta, X_b_i, y_i): return X_b_i * (X_b_i.dot(theta) - y_i) * 2. def sgd(X_b, y, initial_theta, n_iters, t0=5, t1=50): def learning_rate(t): return t0 / (t + t1) theta = initial_theta m = len(X_b) for cur_iter in range(n_iters): indexes = np.random.permutation(m) X_b_new = X_b[indexes] y_new = y[indexes] for i in range(m): gradient = dJ_sgd(theta, X_b_new[i], y_new[i]) theta = theta - learning_rate(cur_iter * m + i) * gradient return theta X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) initial_theta = np.random.randn(X_b.shape[1]) self._theta = sgd(X_b, y_train, initial_theta, n_iters, t0, t1) self.intercept_ = self._theta[0] self.coef_ = self._theta[1:] return self def predict(self, X_predict): &quot;&quot;&quot;给定待预测数据集X_predict，返回表示X_predict的结果向量&quot;&quot;&quot; assert self.intercept_ is not None and self.coef_ is not None, \ &quot;must fit before predict!&quot; assert X_predict.shape[1] == len(self.coef_), \ &quot;the feature number of X_predict must be equal to X_train&quot; X_b = np.hstack([np.ones((len(X_predict), 1)), X_predict]) return X_b.dot(self._theta) def score(self, X_test, y_test): &quot;&quot;&quot;根据测试数据集 X_test 和 y_test 确定当前模型的准确度&quot;&quot;&quot; y_predict = self.predict(X_test) return r2_score(y_test, y_predict) def __repr__(self): return &quot;LinearRegression()&quot; 这里其实就是一个简单的一元数据的一个简答线性回归算法。 线性回归评价指标那怎么去评价线性回归算法的指标的好坏呢？ 常用得三个指标：均方误差MSE、均方根误差RMSE、平均绝对误差MAE，这三类算法具体公式这些就不再赘述了，这三类指标都存在一个局限性：作用域的使用范围，对不同事物的预测缺乏统一标准，这样就引出了新的一个预测指标R Squared，其实就是R^2,关于R^2的解释如下： 从上面的图中我们到关于R^2的公式，公式中上面分子就是我们训练出的模型预测的所有误差。 下面分母就是 不管什么我们猜的结果就是y的平均数。（其实也就是我们瞎猜的误差） 那具体实现下这些评价指标，首先换一个数据集，上面是我们自己构造的的太简单了， 导入sklearn中的datasets 123456789101112131415161718192021222324252627282930313233import numpy as npimport matplotlib.pyplot as pltfrom sklearn import datasetsfrom sklearn.model_selection import train_test_splitfrom sklearn.metrics import mean_squared_error, mean_absolute_errorboston = datasets.load_boston()x = boston.data[:,5]y = boston.targetx = x[y&lt;50.0]y = y[y&lt;50.0]plt.scatter(x, y)plt.show()# 划分训练集和测试集x_train, x_test, y_train, y_test = train_test_split(x,y,test_size=0.2)# 简单线性规划x_mean = np.mean(x_train)y_mean = np.mean(y_train)# 分子num = 0.0# 分母d = 0.0for x_i, y_i in zip(x_train, y_train):num += (x_i - x_mean) * (y_i - y_mean)d += (x_i - x_mean) ** 2a = num/db = y_mean - a*x_meany_hat = a*x_train + b # 回归函数plt.scatter(x_train, y_train)plt.plot(x_train, y_hat, color="r")plt.show() y_predict = a*x_test + b mse = mean_squared_error(y_test, y_predict) mae = mean_absolute_error(y_test, y_predict) print(&quot;均方误差为：&quot; + str(mse)) print(&quot;平均绝对误差为：&quot; + str(mae)) rs = 1 - mse/np.var(y_test) print(&quot;R Square = &quot; + str(rs)) 这样我们就得到了所有的评价指标。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习，线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之梯度下降法(GradientDescent)]]></title>
    <url>%2F2018%2F05%2F23%2FGradientDescent%2F</url>
    <content type="text"><![CDATA[梯度下降法概念梯度下降法是迭代法的一种,其实它不是一种具体的机器学习算法，是一种基于搜索的最优化方法，可以用于求解最小二乘问题(线性和非线性都可以)。在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法。在求解损失函数的最小值时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数和模型参数值。相应的还有一个梯度上升法，它的作用是最大化一个效用函数。 用一个图来表示梯度下降法： 怎么理解呢？梯度其实是在在多维空间中的概念，在二维的平面上其实就是导数，梯度表示的就是方向，通过求某一个点的梯度，我们就可以知道J(损失函数)增大的方向，然后乘-η就可以找到J(损失函数)减小的方向，不断地求J的导数，直到其变为0，这样就找到J的最小值点。这里的η称为学习率，η的取值影响获得最优解的速度，η取值太小的时候学习速度收敛太慢，η太大有可能直接跳过最小值点然后导致不收敛。 有可能在某一次取值的过程中找到的是局部最优解，而不是全局最优解。这个时候怎么解决呢？多次运行，随机化初始点，这样的话增加了找到全局最优解的概率。 模拟实现梯度下降法jupyter notebook中实现： 123456789101112131415161718192021222324252627282930313233343536import numpy as npimport matplotlib.pyplot as plt#datasetsx = np.linspace(-1, 6 ,141)y = (x-2.5)**2-1# 求导数def dJ(theta):return 2*(theta - 2.5)# 损失函数def J(theta):return (theta - 2.5)**2-1# 梯度下降法theta = 0.0eta = 0.1#误差精度epsilon = 1e-8theta_history = [theta]while True:gradient = dJ(theta)last_theta = thetatheta = theta - eta * gradienttheta_history.append(theta)if(abs(J(theta) - J(last_theta)) &lt; epsilon):breakplt.plot(x, y)plt.plot(np.array(theta_history), J(np.array(theta_history)), color='R', marker = 'o')plt.xlabel("theta")plt.ylabel("J")plt.show()print("theta = " + str(theta))print("J(theta) = " + str(J(theta))) 得到的结果如下： 然后我们上面讨论过，η取值太小的时候学习速度收敛太慢，η太大有可能直接跳过最小值点然后导致不收敛。下面测试一下。先取η=0.01 我们可以看出梯度下降的速度变慢了 然后取η=1 当η&gt;1的时候编译器就自动报错，但是这里只是针对这里定义的这个函数，并不是意味着η=1就是极限值，针对不同的函数有不同的取值。 多元线性回归中使用批量梯度下降线性回归中使用梯度下降法，其目标是使得$$\sum_{i=1}^{m}(y^i-\hat{y}^i)^2$$尽可能小，而且线性回归算法的损失函数是具有唯一解的。 其中$$\hat{y}^{i} = \theta _{0} + \theta _{1}X_{1}^{i}+…++ \theta _{n}X_{n}^{i}$$带入因此线性回归中梯度下降的目标就成为了$$\sum_{i=1}^{m}(y^i - \theta _{0} + \theta _{1}X_{1}^{i}+…++ \theta _{n}X_{n}^{i})$$使得其尽可能小。那梯度怎么去求呢？如下： 批量梯度下降法具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445import numpy as npimport matplotlib.pyplot as pltnp.random.seed(666)x = 2 * np.random.random(size = 100)y = x * 3.0 + 4.0 + np.random.normal(size = 100)X = x.reshape(-1, 1)#损失函数def J(theta, X_b, y):try:return np.sum((y - X_b.dot(theta))**2)/len(X_b)except:return float(&apos;inf&apos;)#损失函数的梯度def dJ(theta, X_b, y):res = np.empty(len(theta))res[0] = np.sum(X_b.dot(theta) - y)for i in range(1, len(theta)):res[i] = (X_b.dot(theta) - y).dot(X_b[:,i])return res *2 /len(X_b)#梯度下降法def gradient_descent(X_b, y, initial_thata, eta, n_iters = 1e4, epsilon = 1e-8):theta = initial_thetai_iter = 0while i_iter &lt; n_iters:# n_iters是最大循环次数gradient = dJ(theta, X_b, y)last_theta = thetatheta = theta - eta * gradientif(abs(J(theta, X_b, y) - J(last_theta, X_b, y)) &lt; epsilon):breaki_iter += 1return thetaX_b = np.hstack([np.ones((len(x), 1)), x.reshape(-1, 1)])initial_theta = np.zeros(X_b.shape[1])eta = 0.01theta = gradient_descent(X_b, y, initial_theta, eta) 12345plt.scatter(x, y)Y = X_b.dot(theta)plt.plot(x, Y, color="red")plt.show()print("theta = " + str(theta)) 得到的结果 在初始化数据的时候，斜率设为3，截距为4，然后我们训练出的结果theta与两值接近，证明训练的模型是准确的：y = x * 3.0 + 4.0 + np.random.normal(size = 100) 随机梯度下降法上面我们用的是批量梯度下降法，这种方法有一个缺点，就是每一项都需要对所有的样本点进行计算，数据量少的时候还可以，但是数据量很大的时候就显得很鸡肋了，计算非常的耗资源。能不能每一次计算的时候只对其中的一个样本进行计算呢？这就衍生出了随机梯度下降法。 即每读取一条样本，就迭代对Θ进行更新，然后判断其是否收敛，若没收敛，则继续读取样本进行处理，如果所有样本都读取完毕了，则循环重新从头开始读取样本进行处理。但是，相较于批量梯度下降算法而言，随机梯度下降算法使得J(Θ)趋近于最小值的速度更快，但是有可能造成永远不可能收敛于最小值，有可能一直会在最小值周围震荡，但是实践中，大部分值都能够接近于最小值，所以当数据量很大的时候可以用精度来换取时间。 在随机梯度下降法中为了得到更高的收敛结果，学习率是要随着循环次数的增加而逐渐的减小。这是因为在学习的过程中要是学习率是一个固定值，但是可能由于随机的过程不够好，eta有是一个固定值，那么在学习的过程中随机梯度下降法接近最优解的时候又会慢慢的跳出最优解的范围。气质学习率随着循环次数的增加而逐渐的减小这种思想是模拟退火的思想，去搜了下模拟退火，下面写下自己的理解。 模拟退火算法拟退火其实也是一种贪心算法，但是它的搜索过程引入了随机因素。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。模拟退火算法描述： 想象一个高温物体的降温过程。其温度为T时出现能量差为dE的降温概率为P(dE) = e ^ ( -dE / (k * T) ) 。其实就是温度越高降温的概率越大，温度越低降温概率越小。而模拟退火就是利用这样一种思想去进行搜索。那么在进行搜索的时候首先定义一个初始值( 温度 ) T , 一个系数 r ( 降温速度 0 \&lt; r \&lt; 1 ) , 假设你当前状态为 f i , 你的下一个状态为 f i +1 , 对这两个状态进行评价，如果更接近你想要的结果，就更新到这个状态，否则则以 P ( dE ) 的概率去更新到 这个状态，但是其实在实际题目中，这个概率是不必要的，这一步有时是可以忽略掉的。我们可以想象，随着搜索次数的不断增多，搜索范围将越来越趋近于稳定，也就是随着时间的增长温度降低的概率越来越低，直到趋近于1。对应搜索就是随着你搜索的次数越多，你搜索到的值是你想要的值的概率就越大。 然后结合模拟退火的思想，在随机梯度下降法中设置学习率为: 然后结合模拟退火的思想，在随机梯度下降法中设置学习率为:$$\eta = \frac{a}{i_iters + b}$$其中i_iters是循环次数，a,b是两个经验参数，根据实际情况设置。 看完了梯度下降法，其优缺点如下： 第一种，遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，更新梯度。这种方法每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢，不支持在线学习，其实这就是批量梯度下降。 其中i_iters是循环次数，a,b是两个经验参数，根据实际情况设置。 看完了梯度下降法，其优缺点如下： 第一种，遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，更新梯度。这种方法每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢，不支持在线学习，其实这就是批量梯度下降。 其中i_iters是循环次数，a,b是两个经验参数，根据实际情况设置。看完了梯度下降法，其优缺点如下：第一种，遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，更新梯度。这种方法每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢，不支持在线学习，其实这就是批量梯度下降。 另一种，每看一个数据就算一下损失函数，然后求梯度更新参数，这个其实也就是随机梯度下降，这个方法速度比较快，但是收敛性能不太好，可能在最优点附近晃来晃去，找不到不到最优点。两次参数的更新也有可能互相抵消掉，造成目标函数震荡的比较剧烈。 为了克服两种方法的缺点，现在一般采用的是一种折中手段，小批的梯度下降，这种方法把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。 另一种，每看一个数据就算一下损失函数，然后求梯度更新参数，这个其实也就是随机梯度下降，这个方法速度比较快，但是收敛性能不太好，可能在最优点附近晃来晃去，找不到不到最优点。两次参数的更新也有可能互相抵消掉，造成目标函数震荡的比较剧烈。为了克服两种方法的缺点，现在一般采用的是一种折中手段，小批的梯度下降，这种方法把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。 为了克服两种方法的缺点，现在一般采用的是一种折中手段，小批的梯度下降，这种方法把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。 随机梯度下降法实现1234567891011121314151617181920212223242526272829303132333435import numpy as npimport matplotlib.pyplot as pltm = 100000x = np.random.normal(size = m)X = x.reshape(-1, 1)y = 4.0 * x + 3.0 + np.random.normal(0 ,3, size = m)def J(theta, X_b, y):try:return np.sum((y - X_b.dot(theta))**2) / len(y)except:return float(&apos;inf&apos;)def dJ_sgd(theta, X_b_i, y_i):return X_b_i.T.dot(X_b_i.dot(theta) - y_i) * 2.0 def sgd(X_b, y, initial_theta, n_iters):t0 = 5t1 = 50def learning_rate(t):return t0 / (t + t1)theta = initial_thetafor cur_iter in range(n_iters):rand_i = np.random.randint(len(X_b))gradient = dJ_sgd(theta, X_b[rand_i], y[rand_i])theta = theta - learning_rate(cur_iter) * gradientreturn thetaX_b = np.hstack([np.ones((len(X), 1)), X])initial_theta = np.zeros(X_b.shape[1])theta = sgd(X_b, y, initial_theta, n_iters = len(X_b)//3)print(&quot;theta = &quot; + str(theta)) 输出的theta = [3.00887864 4.05589554]，与设置的数据相接近。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习，梯度下降，python3，jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinsterAndFilter]]></title>
    <url>%2F2018%2F05%2F21%2FLinsterAndFilter%2F</url>
    <content type="text"><![CDATA[监听器与过滤器（Listener &amp; Filter）详解Listener 监听器 能做什么事？ 监听某一个事件的发生。 状态的改变。 监听器的内部机制 其实就是接口回调. 接口回调 需求： A在执行循环，当循环到5的时候， 通知B。 事先先把一个对象传递给 A ， 当A 执行到5的时候，通过这个对象，来调用B中的方法。 但是注意，不是直接传递B的实例，而是传递一个接口的实例过去。 Web监听器 总共有8个 划分成三种类型 定义一个类，实现接口 注册 | 配置监听器 监听三个作用域创建和销毁request —httpServletRequest session —httpSession aapplication — ServletContext 1234567891. ServletContextListener servletcontext创建： 1. 启动服务器的时候 servletContext销毁： 2. 关闭服务器. 从服务器移除项目 1234567892. ServletRequestListener request创建: 访问服务器上的任意资源都会有请求出现。 访问 html： 会 访问 jsp: 会 访问 servlet : 会 123request销毁： 服务器已经对这次请求作出了响应。 1234567891011public class MyRequestListener implements ServletRequestListener &#123; @Override public void requestDestroyed(ServletRequestEvent sre) &#123; System.out.println("servletrequest 销毁了"); &#125; @Override public void requestInitialized(ServletRequestEvent sre) &#123; System.out.println("servletrequest 初始化了"); &#125;&#125; 123&lt;listener&gt; &lt;listener-class&gt;com.itheima.listener.MyRequestListener&lt;/listener-class&gt;&lt;/listener&gt; 123456789101112131415161718192021222324252627283. HttpSessionListener session的创建 只要调用getSession html: 不会 jsp: 会 getSession(); servlet: 会 session的销毁 超时 30分钟 非正常关闭 销毁 正常关闭服务器(序列化) public class MySessionListener implements HttpSessionListener &#123; @Override public void sessionCreated(HttpSessionEvent se) &#123; System.out.println(&quot;创建session了&quot;); &#125; @Override public void sessionDestroyed(HttpSessionEvent se) &#123; System.out.println(&quot;销毁session了&quot;); &#125; &#125; 作用： 12345678910ServletContextListener 利用它来，在servletcontext创建的时候， 1. 完成自己想要的初始化工作 2. 执行自定义任务调度。 执行某一个任务。 Timer HttpSessionListener 统计在线人数. 监听三个作用域属性状态变更 可以监听在作用域中值 添加 | 替换 | 移除的动作。 servletContext — ServletContextAttributeListener request — ServletRequestAttributeListener session — HttpSessionAttributeListener 监听httpSession里面存值的状态变更 这一类监听器不用注册。 HttpSessionBindingListener 监听对象与session 绑定和解除绑定 的动作 12345678910111. 让javaBean 实现该接口即可@Overridepublic void valueBound(HttpSessionBindingEvent event) &#123; System.out.println("对象被绑定进来了");&#125; @Overridepublic void valueUnbound(HttpSessionBindingEvent event) &#123; System.out.println("对象被解除绑定");&#125; HttpSessionActivationListener 用于监听现在session的值 是 钝化 （序列化）还是活化 （反序列化）的动作 钝化 （序列化） 把内存中的数据 存储到硬盘上 活化 （反序列化） 把硬盘中的数据读取到内存中。 session的钝化活化的用意何在 session中的值可能会很多， 并且我们有很长一段时间不使用这个内存中的值， 那么可以考虑把session的值可以存储到硬盘上【钝化】，等下一次在使用的时候，在从硬盘上提取出来。 【活化】 如何让session的在一定时间内钝化. 做配置即可 123456789101112131415161718192021221. 在tomcat里面 conf/context.xml 里面配置 对所有的运行在这个服务器的项目生效 2. 在conf/Catalina/localhost/context.xml 配置 对 localhost生效。 localhost:80803. 在自己的web工程项目中的 META-INF/context.xml 只对当前的工程生效。 maxIdleSwap ： 1分钟不用就钝化 directory ： 钝化后的那个文件存放的目录位置。 D:\tomcat\apache-tomcat-7.0.52\work\Catalina\localhost\ListenerDemo\itheima &lt;Context&gt; &lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; maxIdleSwap=&quot;1&quot;&gt; &lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;itheima&quot;/&gt; &lt;/Manager&gt; &lt;/Context&gt; Filter 过滤器 ， 其实就是对客户端发出来的请求进行过滤。 浏览器发出， 然后服务器派servlet处理。 在中间就可以过滤， 其实过滤器起到的是拦截的作用。 作用 对一些敏感词汇进行过滤 统一设置编码 自动登录 … 如何使用Filter 定义一个类， 实现Filter public class FilterDemo implements Filter { 123456789101112 public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;来到过虑器了。。。&quot;); chain.doFilter(request, response); &#125; public void init(FilterConfig fConfig) throws ServletException &#123; &#125;&#125; 注册过滤器 在web.xml里面注册，注册的手法与servlet基本一样。 123456789 &lt;filter&gt; &lt;display-name&gt;FilterDemo&lt;/display-name&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt; &lt;filter-class&gt;com.itheima.filter.FilterDemo&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Filter的生命周期 创建 在服务器启动的时候就创建。 销毁 服务器停止的时候。 Filter执行顺序 客户端发出请求，先经过过滤器， 如果过滤器放行，那么才能到servlet 如果有多个过滤器， 那么他们会按照注册的映射顺序 来 排队。 只要有一个过滤器， 不放行，那么后面排队的过滤器以及咱们的servlet都不会收到请求。 Filter细节： init方法的参数 FilterConfig , 可以用于获取filter在注册的名字 以及初始化参数。 其实这里的设计的初衷与ServletConfig是一样的。 如果想放行，那么在doFilter 方法里面操作，使用参数 chain 1chain.doFilter(request, response); 放行， 让请求到达下一个目标。 &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 写法格式与servlet一样。 全路径匹配 以 / 开始 /LoginServlet 以目录匹配 以 / 开始 以 * 结束 /demo01/* 以后缀名匹配 以 * 开始 以后缀名结束 *.jsp *.html *.do 针对 dispatcher 设置 REQUEST ： 只要是请求过来，都拦截，默认就是REQUEST FORWARD : 只要是转发都拦截。 ERROR ： 页面出错发生跳转 INCLUDE ： 包含页面的时候就拦截。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Listener</tag>
        <tag>Filter</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈哈哈，终于把博客搭建起来啦]]></title>
    <url>%2F2018%2F05%2F20%2Ffirst-blog%2F</url>
    <content type="text"><![CDATA[520，今天是个好日子，心想的事儿都能成。 嘿嘿，用来几个小时的时间，算是完成了简单的搭建，果然在学习的过程中才是最开心的。为什么要跑到这里搭建博客呢？嗯。。。。 首先csdn换了两个账号，来回倒腾自己的博客，倒腾到一个里去了，至于原因就不说了，心塞塞。然后就是csdn的排版-略略略算是嘲笑吧。 还有毕竟是要常年混迹在全球最大的同性交友社区了，把博客搭起来写写项目开发经历，记录下自己开踩过的坑，还是很重要的。还有自己的博客想怎么折腾就怎么折腾。想说什么就能说什么。 希望路能越走越顺吧。啦啦啦……..]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
