<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[freemarker]]></title>
    <url>%2F2018%2F08%2F20%2Ffreemarker%2F</url>
    <content type="text"><![CDATA[Freemaker FTL指令常用标签及语法注意：使用freemaker，要求所有标签必须闭合，否则会导致freemaker无法解析。 freemaker注释:&lt;#– 注释内容 –&gt;格式部分,不会输出 ———————————- 基础语法 ———————————- 1、字符输出12345$&#123;emp.name?if_exists&#125; // 变量存在，输出该变量，否则不输出$&#123;emp.name!&#125; // 变量存在，输出该变量，否则不输出$&#123;emp.name?default(&quot;xxx&quot;)&#125; // 变量不存在，取默认值xxx $&#123;emp.name!&quot;xxx&quot;&#125; // 变量不存在，取默认值xxx 常用内部函数： 12345$&#123;&quot;123&lt;br&gt;456&quot;?html&#125; // 对字符串进行HTML编码，对html中特殊字符进行转义$&#123;&quot;str&quot;?cap_first&#125; // 使字符串第一个字母大写 $&#123;&quot;Str&quot;?lower_case&#125; // 将字符串转换成小写 $&#123;&quot;Str&quot;?upper_case&#125; // 将字符串转换成大写$&#123;&quot;str&quot;?trim&#125; // 去掉字符串前后的空白字符 字符串的两种拼接方式拼接： 12$&#123;&quot;hello$&#123;emp.name!&#125;&quot;&#125; // 输出hello+变量名$&#123;&quot;hello&quot;+emp.name!&#125; // 使用+号来连接，输出hello+变量名 可以通过如下语法来截取子串: 1234567891011&lt;#assign str = &quot;abcdefghijklmn&quot;/&gt;// 方法1$&#123;str?substring(0,4)&#125; // 输出abcd// 方法2$&#123;str[0]&#125;$&#123;str[4]&#125; // 结果是ae$&#123;str[1..4]&#125; // 结果是bcde// 返回指定字符的索引$&#123;str?index_of(&quot;n&quot;)&#125; 2、日期输出1$&#123;emp.date?string(&apos;yyyy-MM-dd&apos;)&#125; //日期格式 3、数字输出(以数字20为例)12345678910111213$&#123;emp.name?string.number&#125; // 输出20$&#123;emp.name?string.currency&#125; // ￥20.00 $&#123;emp.name?string.percent&#125; // 20%$&#123;1.222?int&#125; // 将小数转为int，输出1&lt;#setting number_format=&quot;percent&quot;/&gt; // 设置数字默认输出方式(&apos;percent&apos;,百分比)&lt;#assign answer=42/&gt; // 声明变量 answer 42#&#123;answer&#125; // 输出 4,200%$&#123;answer?string&#125; // 输出 4,200%$&#123;answer?string.number&#125; // 输出 42$&#123;answer?string.currency&#125; // 输出 ￥42.00$&#123;answer?string.percent&#125; // 输出 4,200%#&#123;answer&#125; // 输出 42 123数字格式化插值可采用#&#123;expr;format&#125;形式来格式化数字,其中format可以是:mX:小数部分最小X位MX:小数部分最大X位 123456789如下面的例子:&lt;#assign x=2.582/&gt;&lt;#assign y=4/&gt;#&#123;x; M2&#125; // 输出2.58#&#123;y; M2&#125; // 输出4#&#123;x; m2&#125; // 输出2.58#&#123;y; m2&#125; // 输出4.0#&#123;x; m1M2&#125; // 输出2.58#&#123;x; m1M2&#125; // 输出4.0 4、申明变量12&lt;#assign foo=false/&gt; // 声明变量,插入布尔值进行显示,注意不要用引号$&#123;foo?string(&quot;yes&quot;,&quot;no&quot;)&#125; // 当为true时输出&quot;yes&quot;,否则输出&quot;no&quot; 申明变量的几种方式 1234567891011&lt;#assign name=value&gt; &lt;#assign name1=value1 name2=value2 ... nameN=valueN&gt; &lt;#assign same as above... in namespacehash&gt;&lt;#assign name&gt; capture this &lt;/#assign&gt;&lt;#assign name in namespacehash&gt; capture this &lt;/#assign&gt; 5、比较运算符表达式中支持的比较运算符有如下几个:= 或 == ：判断两个值是否相等.!= ：判断两个值是否不等.> 或 gt ：判断左边值是否大于右边值>= 或 gte ：判断左边值是否大于等于右边值&lt; 或 lt ：判断左边值是否小于右边值&lt;= 或 lte ：判断左边值是否小于等于右边值 6、算术运算符FreeMarker表达式中完全支持算术运算,FreeMarker支持的算术运算符包括:+, - , * , / , %注意：（1）、运算符两边必须是数字（2）、使用+运算符时,如果一边是数字,一边是字符串,就会自动将数字转换为字符串再连接,如:${3 + “5”},结果是:35 7、逻辑运算符逻辑运算符有如下几个:逻辑与:&amp;&amp;逻辑或:||逻辑非:!逻辑运算符只能作用于布尔值,否则将产生错误 8、FreeMarker中的运算符优先级如下(由高到低排列):①、一元运算符:!②、内建函数:?③、乘除法:*, / , %④、加减法:- , +⑤、比较:&gt; , &lt; , &gt;= , &lt;= (lt , lte , gt , gte)⑥、相等:== , = , !=⑦、逻辑与:&amp;&amp;⑧、逻辑或:||⑨、数字范围:..实际上,我们在开发过程中应该使用括号来严格区分,这样的可读性好,出错少 9、if 逻辑判断（注意：elseif 不加空格）123456789&lt;#if condition&gt;...&lt;#elseif condition2&gt;...&lt;#elseif condition3&gt;...&lt;#else&gt;...&lt;/#if&gt; if 空值判断 123456789// 当 photoList 不为空时&lt;#if photoList??&gt;...&lt;/#if&gt; 值得注意的是,$&#123;..&#125;只能用于文本部分,不能用于表达式,下面的代码是错误的:&lt;#if $&#123;isBig&#125;&gt;Wow!&lt;/#if&gt;&lt;#if &quot;$&#123;isBig&#125;&quot;&gt;Wow!&lt;/#if&gt;// 正确写法&lt;#if isBig&gt;Wow!&lt;/#if&gt; 10、switch (条件可为数字，可为字符串)12345678910111213&lt;#switch value&gt; &lt;#case refValue1&gt; ....&lt;#break&gt; &lt;#case refValue2&gt; ....&lt;#break&gt; &lt;#case refValueN&gt; ....&lt;#break&gt; &lt;#default&gt; .... &lt;/#switch&gt; 11、集合 &amp; 循环12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 遍历集合:&lt;#list empList! as emp&gt; $&#123;emp.name!&#125;&lt;/#list&gt;// 可以这样遍历集合:&lt;#list 0..(empList!?size-1) as i&gt; $&#123;empList[i].name!&#125;&lt;/#list&gt;// 与jstl循环类似,也可以访问循环的状态。empList?size // 取集合的长度emp_index: // int类型，当前对象的索引值 emp_has_next: // boolean类型，是否存在下一个对象// 使用&lt;#break&gt;跳出循环&lt;#if emp_index = 0&gt;&lt;#break&gt;&lt;/#if&gt;// 集合长度判断 &lt;#if empList?size != 0&gt;&lt;/#if&gt; // 判断=的时候,注意只要一个=符号,而不是==&lt;#assign l=0..100/&gt; // 定义一个int区间的0~100的集合，数字范围也支持反递增,如100..2&lt;#list 0..100 as i&gt; // 等效于java for(int i=0; i &lt;= 100; i++) $&#123;i&#125;&lt;/#list&gt;// 截取子集合：empList[3..5] //返回empList集合的子集合,子集合中的元素是empList集合中的第4-6个元素// 创建集合：&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as x&gt;// 集合连接运算,将两个集合连接成一个新的集合&lt;#list [&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;] + [&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期天&quot;] as x&gt;// 除此之外,集合元素也可以是表达式,例子如下:[2 + 2, [1, 2, 3, 4], &quot;whatnot&quot;]// seq_contains：判断序列中的元素是否存在&lt;#assign x = [&quot;red&quot;, 16, &quot;blue&quot;, &quot;cyan&quot;]&gt; $&#123;x?seq_contains(&quot;blue&quot;)?string(&quot;yes&quot;, &quot;no&quot;)&#125; // yes$&#123;x?seq_contains(&quot;yellow&quot;)?string(&quot;yes&quot;, &quot;no&quot;)&#125; // no$&#123;x?seq_contains(16)?string(&quot;yes&quot;, &quot;no&quot;)&#125; // yes$&#123;x?seq_contains(&quot;16&quot;)?string(&quot;yes&quot;, &quot;no&quot;)&#125; // no// seq_index_of：第一次出现的索引&lt;#assign x = [&quot;red&quot;, 16, &quot;blue&quot;, &quot;cyan&quot;, &quot;blue&quot;]&gt; $&#123;x?seq_index_of(&quot;blue&quot;)&#125; // 2// sort_by：排序（升序）&lt;#list movies?sort_by(&quot;showtime&quot;) as movie&gt;&lt;/#list&gt;// sort_by：排序（降序）&lt;#list movies?sort_by(&quot;showtime&quot;)?reverse as movie&gt;&lt;/#list&gt;// 具体介绍：// 不排序的情况：&lt;#list movies as moive&gt; &lt;a href=&quot;$&#123;moive.url&#125;&quot;&gt;$&#123;moive.name&#125;&lt;/a&gt;&lt;/#list&gt;//要是排序，则用&lt;#list movies?sort as movie&gt; &lt;a href=&quot;$&#123;movie.url&#125;&quot;&gt;$&#123;movie.name&#125;&lt;/a&gt;&lt;/#list&gt;// 这是按元素的首字母排序。若要按list中对象元素的某一属性排序的话，则用&lt;#list moives?sort_by([&quot;name&quot;]) as movie&gt; &lt;a href=&quot;$&#123;movie.url&#125;&quot;&gt;$&#123;movie.name&#125;&lt;/a&gt;&lt;/#list&gt;//这个是按list中对象元素的[name]属性排序的，是升序，如果需要降序的话，如下所示：&lt;#list movies?sort_by([&quot;name&quot;])?reverse as movie&gt; &lt;a href=&quot;$&#123;movie.url&#125;&quot;&gt;$&#123;movie.name&#125;&lt;/a&gt;&lt;/#list&gt; 12、Map对象123456789// 创建map&lt;#assign scores = &#123;&quot;语文&quot;:86,&quot;数学&quot;:78&#125;&gt;// Map连接运算符&lt;#assign scores = &#123;&quot;语文&quot;:86,&quot;数学&quot;:78&#125; + &#123;&quot;数学&quot;:87,&quot;Java&quot;:93&#125;&gt;// Map元素输出emp.name // 全部使用点语法emp[&quot;name&quot;] // 使用方括号 13、FreeMarker支持如下转义字符:\” ：双引号(u0022)\’ ：单引号(u0027)\ ：反斜杠(u005C)\n ：换行(u000A)\r ：回车(u000D)\t ：Tab(u0009)\b ：退格键(u0008)\f ：Form feed(u000C)\l ：&lt;\g ：&gt;\a ：&amp;\{ ：{\xCode ：直接通过4位的16进制数来指定Unicode码,输出该unicode码对应的字符. 如果某段文本中包含大量的特殊符号,FreeMarker提供了另一种特殊格式:可以在指定字符串内容的引号前增加r标记,在r标记后的文件将会直接输出.看如下代码:${r”${foo}”} // 输出 ${foo}${r”C:/foo/bar”} // 输出 C:/foo/bar 14、include指令123456// include指令的作用类似于JSP的包含指令:&lt;#include &quot;/test.ftl&quot; encoding=&quot;UTF-8&quot; parse=true&gt;// 在上面的语法格式中,两个参数的解释如下:encoding=&quot;GBK&quot; // 编码格式parse=true // 是否作为ftl语法解析,默认是true，false就是以文本方式引入,注意:在ftl文件里布尔值都是直接赋值的如parse=true,而不是parse=&quot;true&quot; 15、import指令123// 类似于jsp里的import,它导入文件，然后就可以在当前文件里使用被导入文件里的宏组件&lt;#import &quot;/libs/mylib.ftl&quot; as my&gt;// 上面的代码将导入/lib/common.ftl模板文件中的所有变量,交将这些变量放置在一个名为com的Map对象中，&quot;my&quot;在freemarker里被称作namespace 17、compress 压缩1234// 用来压缩空白空间和空白的行 &lt;#compress&gt; ... &lt;/#compress&gt; 1234567&lt;#t&gt; // 去掉左右空白和回车换行 &lt;#lt&gt;// 去掉左边空白和回车换行 &lt;#rt&gt;// 去掉右边空白和回车换行 &lt;#nt&gt;// 取消上面的效果 18、escape,noescape 对字符串进行HTML编码1234567891011// escape指令导致body区的插值都会被自动加上escape表达式,但不会影响字符串内的插值,只会影响到body内出现的插值,使用escape指令的语法格式如下:&lt;#escape x as x?html&gt; First name: $&#123;firstName&#125; &lt;#noescape&gt;Last name: $&#123;lastName&#125;&lt;/#noescape&gt; Maiden name: $&#123;maidenName&#125; &lt;/#escape&gt;// 相同表达式First name: $&#123;firstName?html&#125; Last name: $&#123;lastName&#125; Maiden name: $&#123;maidenName?html&#125; ———————————- 高级语法 ———————————-1、global全局赋值语法123456789&lt;#global name=value&gt; &lt;#global name1=value1 name2=value2 ... nameN=valueN&gt; &lt;#global name&gt; capture this &lt;/#global&gt;// 利用这个语法给变量赋值，那么这个变量在所有的namespace中是可见的，如果这个变量被当前的assign语法覆盖如&lt;#global x=2&gt;&lt;#assign x=1&gt;在当前页面里x=2将被隐藏，或者通过$&#123;.globals.x&#125; 来访问 2、setting 语法123456789101112131415// 用来设置整个系统的一个环境 locale // zh_CN 中文环境number_format boolean_format date_format , time_format , datetime_format time_zone classic_compatible// 例1：&lt;#setting number_format=&quot;percent&quot;/&gt; // 设置数字默认输出方式(&apos;percent&apos;,百分比)// 例2：// 假如当前是匈牙利的设置，然后修改成美国$&#123;1.2&#125; // 输出1,2&lt;#setting locale=&quot;en_US&quot;&gt; $&#123;1.2&#125; // 输出1.2,因为匈牙利是采用&quot;, &quot;作为十进制的分隔符，美国是用&quot;. &quot; 3、macro宏指令例子1： 12345678910&lt;#-- 定义宏 --&gt;&lt;#macro test foo bar=&quot;Bar&quot; baaz=-1&gt; Text: $&#123;foo&#125;, $&#123;bar&#125;, $&#123;baaz&#125;&lt;/#macro&gt;&lt;#-- 使用宏 --&gt;&lt;@test foo=&quot;a&quot; bar=&quot;b&quot; baaz=5*5/&gt; // 输出：Text: a, b, 25&lt;@test foo=&quot;a&quot; bar=&quot;b&quot;/&gt; // 输出：Text: a, b, -1&lt;@test foo=&quot;a&quot; baaz=5*5-2/&gt; // 输出：Text: a, Bar, 23&lt;@test foo=&quot;a&quot;/&gt; // 输出：Text: a, Bar, -1 例子2： 1234567891011&lt;#-- 定义一个循环输出的宏 --&gt;&lt;#macro list title items&gt; $&#123;title&#125; &lt;#list items as x&gt; *$&#123;x&#125; &lt;/#list&gt; &lt;/#macro&gt; &lt;#-- 使用宏 --&gt;&lt;@list items=[&quot;mouse&quot;, &quot;elephant&quot;, &quot;python&quot;] title=&quot;Animals&quot;/&gt;// 输出Animals *mouse *elephant *python 例子3： 123456789101112131415&lt;#-- 嵌套宏 --&gt;&lt;#macro border&gt; &lt;table&gt; &lt;#nested&gt; &lt;/table&gt;&lt;/#macro&gt;&lt;#-- 嵌套宏使用 --&gt;&lt;@border&gt; &lt;tr&gt;&lt;td&gt;hahaha&lt;/td&gt;&lt;/tr&gt;&lt;/@border&gt; 输出结果：&lt;table&gt; &lt;tr&gt;&lt;td&gt;hahaha&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 例子4：在nested指令中使用循环变量时,可以使用多个循环变量,看如下代码: 12345678910111213141516&lt;#-- 循环嵌套宏 --&gt;&lt;#macro repeat count&gt; &lt;#list 1..count as x&gt; &lt;#nested x, x/2, x==count&gt; // 使用nested指令时指定了三个循环变量 &lt;/#list&gt;&lt;/#macro&gt;&lt;#-- 使用宏 --&gt;&lt;@repeat count = 4; c, halfc, last&gt; $&#123;c&#125;. $&#123;halfc&#125;&lt;#if last&gt; Last!&lt;/#if&gt;&lt;/@repeat&gt;// 输出结果：// 1. 0.5// 2. 1// 3. 1.5// 4. 2 Last! freemarker 宏嵌套nested 的使用: 4、结束macro指令1234567891011// return指令用于结束macro指令&lt;#-- 创建宏 --&gt;&lt;#macro book&gt; spring &lt;#return&gt; j2ee&lt;/#macro&gt;&lt;#-- 使用宏 --&gt;&lt;@book /&gt;// 上面的代码输出:spring,而j2ee位于return指令之后,不会输出.]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分别使用原生Ajax 和Jquery的方式发送请求]]></title>
    <url>%2F2018%2F08%2F19%2FAjaxAndJquery%2F</url>
    <content type="text"><![CDATA[分别使用原生Ajax 和Jquery的方式发送请求Ajax 是什么? “Asynchronous Javascript And XML”（异步JavaScript和XML）， 并不是新的技术，只是把原有的技术，整合到一起而已。 12341.使用CSS和XHTML来表示。2. 使用DOM模型来交互和动态显示。3.使用XMLHttpRequest来和服务器进行异步通信。4.使用javascript来绑定和调用。 有什么用? 咱们的网页如果想要刷新局部内容。 那么需要重新载入整个网页。用户体验不是很好。 就是为了解决局部刷新的问题。 保持其他部分不动，只刷新某些地方。 内部原理诚如前面所说的， Ajax 并不是一项新技术。而是包装了现有的技术，然后使用他们来完成工作而已。 那么现在给大家举个例子， 还是以咱们的判断用户名是否已被注册为例。 传统方式： 123451. 输入用户名，2. 点击一个按钮，校验。3. 把数据提交给服务器4. 服务器在后台帮助我们完成校验，并且反馈信息。5. 我们在浏览器上提示用户，给出结果 Ajax方式： 123456789ajax方式与前面的方式其实从要做的事情来说，是一样的。 ajax也没有牛到，不用去访问服务器就知道你的用户名是否已被占用。那么它是如何工作的呢?1. 通过JS 获取咱们的输入框文本内容 document.getElementById(&quot;username&quot;).value2. 通过XmlHttpRequest 去执行请求。 XmlHttpRequest 其实就是 XML + http + Request 的组合。3. 请求结束后，收到结果， 再使用 js 去完成提示。 4. 可以在顺便配合 css 样式来增加提示效果。 Ajax 的请求/响应与服务器上的 Web 应用程序打交道的是 JavaScript 技术，而不是直接提交给那个应用程序的 HTML 表单。发出请求如何使用XMLHttpRequest 对象?首先–需要一个能够调用JavaScript 方法 的Web 页面 。接下来就是在所有 Ajax 应用程序中基本都雷同的流程： 1、从 Web 表单中获取需要的数据。2、建立要连接的 URL。3、打开到服务器的连接。4、设置服务器在完成后要运行的函数。5、发送请求。 数据请求 Get123456789101112131415161718192021222324252627282930313233343536373839//创建对象function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125; //2.发送请求 //执行get请求 function get() &#123; //1. 创建xmlhttprequest 对象 var request = ajaxFunction(); //2. 发送请求。 // http://localhost:8080/day16/demo01.jsp //http://localhost:8080/day16/DemoServlet01 /* 参数一： 请求类型 GET or POST 参数二： 请求的路径 参数三： 是否异步， true or false */ request.open(&quot;GET&quot; ,&quot;/day16/DemoServlet01&quot; ,true ); request.send();&#125; 12345678910111213141516171819202122如果发送请求的同时，还想获取数据，那么代码如下//执行get请求function get() &#123; //1. 创建xmlhttprequest 对象 var request = ajaxFunction(); //2. 发送请求 request.open(&quot;GET&quot; ,&quot;/day16/DemoServlet01?name=aa&amp;age=18&quot; ,true ); //3. 获取响应数据 注册监听的意思。 一会准备的状态发生了改变，那么就执行 = 号右边的方法 request.onreadystatechange = function()&#123; //前半段表示 已经能够正常处理。 再判断状态码是否是200，已经处理请求 if(request.readyState == 4 &amp;&amp; request.status == 200)&#123; //弹出响应的信息 alert(request.responseText); &#125; &#125; request.send();&#125; 数据请求 Post1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script type=&quot;text/javascript&quot;&gt;//1. 创建对象function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125;function post() &#123; //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open( &quot;POST&quot;, &quot;/day16/DemoServlet01&quot;, true ); //如果不带数据，写这行就可以了 //request.send(); //如果想带数据，就写下面的两行 //如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); //带数据过去 ， 在send方法里面写表单数据。 request.send(&quot;name=aobama&amp;age=19&quot;);&#125;&lt;/script&gt; 1234567891011121314151617181920//需要获取数据function post() &#123; //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open( &quot;POST&quot;, &quot;/day16/DemoServlet01&quot;, true ); //想获取服务器传送过来的数据， 加一个状态的监听。 request.onreadystatechange=function()&#123; if(request.readyState==4 &amp;&amp; request.status == 200)&#123; alert(&quot;post：&quot;+request.responseText); &#125; &#125; //如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); //带数据过去 ， 在send方法里面写表单数据。 request.send(&quot;name=aobama&amp;age=19&quot;); &#125; JQuery的方式实现请求与相应load123&lt;a href=&quot;&quot; onclick=&quot;load()&quot;&gt;使用JQuery执行load方法&lt;/a&gt;有两次刷新， 先走 onClick的方法，取到数据回来之后，赋值显示。 接着 走 href=&quot;&quot;的路径，但是这个属性没有给值，所以会把当前的页面重新再刷新一次。所以导致看不见值。 12345//找到这个元素， 去执行加载的动作， 加载/day16/DemoServlet02 ， 得到的数据，赋值显示$(&quot;#aaa&quot;).load(&quot;/day16/DemoServlet02&quot; , function(responseText , statusTXT , xhr) &#123; //找到id为text01的元素， 设置它的value属性值为 responseText 对应的值 $(&quot;#aaa&quot;).val(responseText); &#125;); Get123$.get(&quot;/day16/DemoServlet02&quot; , function(data ,status) &#123; $(&quot;#div01&quot;).text(data); &#125;); 赋值显示 val(“aa”); 只能放那些标签带有value属性 html(“aa”); —写html代码 text(“aa”); 其实没有什么区别，如果想针对这分数据做html样式处理，那么只能用html() post123456function post() &#123; $.post("/day16/DemoServlet02", &#123;name:"zhangsan",age:18&#125;,function(data,status) &#123; //想要放数据到div里面去。 --- 找到div $("#div01").html(data); &#125;); &#125; load &amp; get&amp;post比较 load $(“#元素id”).load(url地址); 1$(&quot;#div1&quot;).load(serlvet); ---&gt; 使用的get请求，回来赋值的时候， 使用text（）;去赋值 get 语法格式 ： $.get(URL,callback); 123使用案例： $.get(&quot;/day16/DemoServlet02&quot; , function(data ,status) &#123; $(&quot;#div01&quot;).text(data);&#125;); post 语法格式：$.post(URL,data,callback); 123456function post() &#123; $.post(&quot;/day16/DemoServlet02&quot;, &#123;name:&quot;zhangsan&quot;,age:18&#125;,function(data,status) &#123; //想要放数据到div里面去。 --- 找到div $(&quot;#div01&quot;).html(data); &#125;);&#125; 使用JQuery去实现校验用户名1234567891011121314151617function checkUserName() &#123; //1. 获取输入框的内容 var name = $(&quot;#name&quot;).val(); //2. 发送请求 $.post(&quot;/day16/CheckUserNameServlet&quot; , &#123;name:name&#125; , function(data , status)&#123; //alert(data); if(data == 1)&#123;//用户名存在 //alert(&quot;用户名存在&quot;); $(&quot;#span01&quot;).html(&quot;&lt;font color=&apos;red&apos;&gt;用户名已被注册&lt;/font&gt;&quot;); &#125;else&#123; //alert(&quot;用户名可用&quot;); $(&quot;#span01&quot;).html(&quot;&lt;font color=&apos;green&apos;&gt;用户名可以使用&lt;/font&gt;&quot;); &#125; &#125; ); //3. 输出响应的数据到页面上。&#125;]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Ajax</tag>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery基础知识学习总结]]></title>
    <url>%2F2018%2F08%2F19%2FjQuery%2F</url>
    <content type="text"><![CDATA[jQuery基础知识学习总结什么JQuery: jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等 使用jQuery完成页面定时弹出广告定时器: setInterval clearInterval setTimeout clearTimeout 显示: img.style.display = “block” 隐藏: img.style.display = “none” img 对象 style属性: style对象 使用jQuery完成表格的隔行换色获得所有的行 table.rows[] 修改行的颜色 row.bgColor =&quot;red&quot; row.style.backgroundColor = &quot;black&quot; row.style.background = &quot;red&quot; &quot;background-color:red&quot; &quot;background:red&quot; 使用jQuery完成复选框的全选效果checked属性 如何获取所有复选框: document.getElementsByName get Elements By Name 数据库里面 使用jQuery完成省市联动效果JS中的数组: [&quot;城市&quot;] new Array() DOM树操作: 创建节点: document.createElement 创建文本节点: document.createTextNode 添加节点: appendChild 使用jQuery完成下列列表左右选择select下拉列表 multiple 允许多选 ondblclick : 双击事件 for循环遍历,一边遍历一边移除出现的问题 使用jQuery完成表单的校验(扩展)事件: 获得焦点事件: onfocus 失去焦点事件: onblur 按键抬起事件: onkeyup 鼠标移入: onmouseenter 鼠标移出: onmouseout JS引入外部文件 : script 使用jQuery完成页面定时弹出广告JQ的入门 1234567891011121314151617181920212223242526272829&lt;script&gt; //js文档加载完成的事件 window.onload = function()&#123; alert("window.onload 111"); &#125; window.onload = function()&#123; alert("window.onload 222"); &#125; /*文档加载完成的事件*/ jQuery(document).ready(function()&#123; alert("jQuery(document).ready(function()"); &#125;); /* jQuery 简写成 $ */ $(document).ready(function()&#123; alert("$(document).ready(function()"); &#125;); /* 最简单的写法 */ $(function()&#123; alert("$(function()&#123;"); &#125;); &lt;/script&gt; 【JQ中根据ID查找元素】 1234全都是根据选择器去找的#ID&#123;&#125;.类名&#123;&#125;$("#ID的名称") 【JQ和JS之间的转换】 JQ对象,只能调用JQ的属性和方法 JS对象 只能调用JS的属性和方法 12345678910111213141516171819function changeJS()&#123; var div = document.getElementById("div1");// div.innerHTML = "JS成功修改了内容" //将JS对象转成JQ对象 $(div).html("转成JQ对象来修改内容") &#125; $(function()&#123; //给按钮绑定事件 $("#btn2").click(function()&#123; //找到div1// $("#div1").html("JQ方式成功修改了内容"); //将JQ对象转成JS对象来调用 var $div = $("#div1");// var jsDiv = $div.get(0); var jsDiv = $div[0]; jsDiv.innerHTML="jq转成JS对象成功"; &#125;); &#125;); JQ的开发步骤: (将我们页面的JS代码和HTML页面代码进行分离) 123451. 导入JQ相关的文件2. 文档加载完成事件: $(function) : 页面初始化的操作: 绑定事件, 启动页面定时器3. 确定相关操作的事件4. 事件触发函数5. 函数里面再去操作相关的元素 显示和隐藏 img.style.display 【JQ中的动画效果】 1234567show()hide()slideUpslideDownfadeInfadeOutanimate : 自定义动画 步骤分析： 导入JQ的文件 编写JQ的文档加载事件 启动定时器 setTimeout(“”,3000); 编写显示广告的函数 在显示广告里面再启动一个定时器 编写隐藏广告的函数 代码实现1234567891011121314&lt;script&gt; //显示广告 function showAd()&#123; $("#img1").slideDown(2000); setTimeout("hideAd()",3000); &#125; //隐藏广告 function hideAd()&#123; $("#img1").slideUp(2000); &#125; $(function()&#123; //文档加载完成才这么做 setTimeout("showAd()",3000); &#125;);&lt;/script&gt; jQuery中的选择器让我们能够更加精确找到我们要操作的元素 基本选择器 ID选择器 : #ID的名称 类选择器: 以 . 开头 .类名 元素选择器: 标签的名称 通配符选择器: * 选择器,选择器: 选择器1,选择器2 基本选择器的案例12345678910111213141516171819202122232425262728293031323334&lt;!-- - ID选择器 : #ID的名称 - 类选择器: 以 . 开头 .类名 - 元素选择器: 标签的名称 - 通配符选择器: * - 选择器,选择器: 选择器1,选择器2 --&gt; &lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 $("#btn1").click(function()&#123; $("#two").css("background-color","palegreen"); &#125;); //找出mini类的所有元素 $("#btn2").click(function()&#123; $(".mini").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("div").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("*").css("background-color","palegreen"); &#125;); /*选择器分组*/ //找出mini类 和 span元素 $("#btn5").click(function()&#123; $(".mini,span").css("background-color","palegreen"); &#125;); &#125;); &lt;/script&gt; JQ中的层级选择器 子元素选择器: 选择器1 &gt; 选择器2 后代选择器: 选择器1 儿孙 相邻兄弟选择器 : 选择器1 + 选择器2 : 找出紧挨着的一个弟弟 找出所有弟弟: 选择器1~ 选择器2 : 找出所有的弟弟 123456789101112131415161718192021&lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 //找出body下面的子div $("#btn1").click(function()&#123; $("body &gt; div").css("background-color","palegreen"); &#125;); //找出body下面的所有div $("#btn2").click(function()&#123; $("body div").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("#one+div").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("#two~div").css("background-color","palegreen"); &#125;); &#125;);&lt;/script&gt; JQ中的基本过滤器12345678910111213141516171819202122232425&lt;script&gt; $(function()&#123; /&lt;script&gt; //文档加载事件,页面初始化的操作 $(function()&#123; //初始化操作: 给按钮绑定事件 //过滤出所有div中第一个元素 $("#btn1").click(function()&#123; $("div:first").css("background-color","palegreen"); &#125;); //过滤出所有div中偶数位的div $("#btn2").click(function()&#123; $("div:even").css("background-color","palegreen"); &#125;); $("#btn3").click(function()&#123; $("div:odd").css("background-color","palegreen"); &#125;); $("#btn4").click(function()&#123; $("div:gt(2)").css("background-color","palegreen"); &#125;); &#125;);&lt;/script&gt; JQ中的属性选择器123456789101112$(function()&#123;//找到有name属性的input $("#btn1").click(function()&#123; $("input[name]").attr("checked",true); &#125;); $("#btn2").click(function()&#123; $("input[name='accept']").attr("checked",true); &#125;); $("#btn3").click(function()&#123; $("input[name='newsletter'][value='Hot Fuzz']").attr("checked",true); &#125;);&#125;); JQ中的表单过滤器123456&lt;script&gt; //1.文档加载事件 $(function()&#123; $(":text").css("background-color","pink"); &#125;);&lt;/script&gt; 使用JQ完成表格的隔行换色步骤分析: 导入JQ的包 文档加载完成函数: 页面初始化 获得所有的行 : 元素选择器 根据行号去修改颜色 代码实现:123456789 $(function()&#123; //获得所有的行 : 元素选择器 $("tbody &gt; tr:even").css("background-color","#CCCCCC"); //修改基数行 $("tbody &gt; tr:odd").css("background-color","#FFF38F");// $("tbody &gt; tr").css("background-color","#FFF38F"); &#125;); 使用JQ完成省市联动效果技术分析: 准备工作 : 城市信息的数据 添加节点 : appendChild (JS) append : 添加子元素到末尾 appendTo : 给自己找一个爹,将自己添加到别人家里 prepend : 在子元素前面添加 after : 在自己的后面添加一个兄弟 遍历的操作: 步骤分析: 导入JQ的文件 文档加载事件:页面初始化 进一步确定事件: change事件 函数: 得到当前选中省份 得到城市, 遍历城市数据 将遍历出来的城市添加到城市的select中 代码实现:123456789101112131415161718$(function()&#123; $("#province").change(function()&#123;// alert(this.value); //得到城市信息 var cities = provinces[this.value]; //清空城市select中的option /*var $city = $("#city"); //将JQ对象转成JS对象 var citySelect = $city.get(0) citySelect.options.length = 0;*/ $("#city").empty(); //采用JQ的方式清空 //遍历城市数据 $(cities).each(function(i,n)&#123; $("#city").append("&lt;option&gt;"+n+"&lt;/option&gt;"); &#125;); &#125;); &#125;); 使用JQ完成下拉列表左右选择步骤分析123451. 导入JQ的文件2. 文档加载函数 :页面初始化3.确定事件 : 点击事件 onclick4. 事件触发函数1. 移动被选中的那一项到右边 代码实现123456789101112131415&lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $("#a1").click(function()&#123; //找到被选中的那一项 //将被选中项添加到右边 $("#rightSelect").append($("#leftSelect option:selected")); &#125;); //将左边所有商品移动到右边 $("#a2").click(function()&#123; $("#rightSelect").append($("#leftSelect option")); &#125;); &#125;);&lt;/script&gt; 使用JQ完成表单的校验(扩展)技术分析 trigger triggerHandler is() 步骤分析 首先给必填项,添加尾部添加一个小红点 获取用户输入的信息,做相应的校验 事件: 获得焦点, 失去焦点, 按键抬起 表单提交的事件 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;link rel="stylesheet" href="../css/style.css" /&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 1. 首先给必填项,添加尾部添加一个小红点 2. 获取用户输入的信息,做相应的校验 3. 事件: 获得焦点, 失去焦点, 按键抬起 4. 表单提交的事件 Jq的方式来实现: 1. 导入JQ的文件 2. 文档加载事件: 在必填项后天加一个小红点 3. 表单校验确定事件: blur focus keyup 4. 提交表单 submit --&gt; &lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; //默认做一些页面初始化 //动态在必填项后面添加小红点 $(".bitian").after("&lt;font class='high'&gt;*&lt;/font&gt;"); //给必填项绑定事件 $(".bitian").blur(function()&#123; //首先获取用户当前输入的值 var value = this.value; //123 //清空上一次提示的信息 $(this).parent().find(".formtips").remove(); //判断当前的值是哪一项输入的值 if($(this).is("#username"))&#123; //判断是否是用户名输入项 if(value.length &lt; 6)&#123; $(this).parent().append("&lt;span class='formtips onError'&gt;用户名太短了&lt;/span&gt;"); &#125;else&#123; $(this).parent().append("&lt;span class='formtips onSuccess'&gt;用户名够用&lt;/span&gt;"); &#125; &#125; if($(this).is("#password"))&#123; //判断是否是密码输入项 if(value.length &lt; 6)&#123; $(this).parent().append("&lt;span class='formtips onError'&gt;,密码太短了&lt;/span&gt;"); &#125;else&#123; $(this).parent().append("&lt;span class='formtips onSuccess'&gt;密码够用&lt;/span&gt;"); &#125; &#125; &#125;).focus(function()&#123; $(this).triggerHandler("blur"); &#125;).keyup(function()&#123; $(this).triggerHandler("blur"); &#125;) //给表单提交绑定事件 $("form").submit(function()&#123; //触发所有必填项的校验 $(".bitian").trigger("focus"); //找到错误信息的个数 if($(".onError").length &gt; 0)&#123; return false; &#125; return true; &#125;); &#125;); /* $(function()&#123; // 在所有必填项后天加一个小红点 * $(".bitian").after("&lt;font class='high'&gt;*&lt;/font&gt;"); //事件绑定 $(".bitian").blur(function()&#123;// var value = this.value; var value = $(this).val(); //清空当前必填项后面的span // $(".formtips").remove(); $(this).parent().find(".formtips").remove(); //获得当前事件是谁的 if($(this).is("#username"))&#123; //校验用户名 if(value.length &lt; 6)&#123; $(this).parent().append("&lt;span class='formtips onError'&gt;用户名太短了&lt;/span&gt;"); &#125;else&#123; $(this).parent().append("&lt;span class='formtips onSuccess'&gt;用户名够用&lt;/span&gt;"); &#125; &#125; if($(this).is("#password"))&#123; //校验密码 if(value.length &lt; 3)&#123; $(this).parent().append("&lt;span class='formtips onError'&gt;密码太短了&lt;/span&gt;"); &#125;else&#123; $(this).parent().append("&lt;span class='formtips onSuccess'&gt;密码够用&lt;/span&gt;"); &#125; &#125; &#125;).focus(function()&#123; $(this).triggerHandler("blur"); &#125;).keyup(function()&#123; $(this).triggerHandler("blur"); &#125;); // $(".bitian").blur(function()&#123;&#125;).focus(function()&#123;&#125;).keyup(function()&#123;&#125;) //给表单绑定提交事件 $("form").submit(function()&#123; //触发必填项的校验逻辑 $(".bitian").trigger("focus"); var length = $(".onError").length if(length &gt; 0)&#123; return false; &#125; return true; &#125;); &#125;);*/ &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="../index.html"&gt; &lt;div&gt; 用户名:&lt;input type="text" class="bitian" id="username" /&gt; &lt;/div&gt; &lt;div&gt; 密码:&lt;input type="password" class="bitian" id="password" /&gt; &lt;/div&gt; &lt;div&gt; 手机号:&lt;input type="tel" /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="submit" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 使用JQuery发送请求局部刷新页面数据交换格式: json xml 什么是JSON JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。 JSON格式 JSON对象 12&#123; key1:value&#125; &#123;"username":"zhangsan","password":"123"&#125; JSON数组 1[&#123; key1:value&#125;,&#123; key1:value&#125;,&#123; key1:value&#125;] 内容总结:定时器 动画效果: show hide slideDown slideUp fadeIn fadeOut animate 基本选择器: ID选择器: #ID名称 类选择器: .类名 元素选择器: 元素/标签名称 通配符选择器: * 找出所有页面元素 包含页面上所有的标签 选择器分组 : 选择器1, 选择器2 [选择器1,选择器2] 层级选择器: 后代选择器: 选择器1 选择器2 找出所有的后代,儿子孙子曾孙 子元素选择器: 选择器1 &gt;选择器2 找出所有儿子 相邻兄弟选择器: 选择器1+选择器2 : 找出紧挨着自己那个弟弟 兄弟选择器 : 选择器1~选择器2 : 找出所有的弟弟 属性选择器: 选择器[属性名称] 12选择器[属性名称][属性名名]选择器[属性名称='属性值'][属性名称='属性值'][属性名称='属性值'] 表单选择器: :input 找出所有的输入项 : 不单单找出input textarea select :text 找出type类型为 text :password 基本过滤器: :even :odd :gt :lt :eq :first :last 表单对象属性: :selected :checked 123456789101112131415161718$(function) : 文档加载完成的事件css() : 修改css样式prop() : 修改属性/ 获取属性html() : 修改innerHTMLappend : 给自己添加子节点appendTo : 将自己添加到别人家,给自己找一个爹prepend : 在自己最前面添加子节点after : 在自己后面添加一个兄弟empty : 清空所有子节点$(cities).each(function(i,n)&#123; &#125;)$.each(arr,function(i,n)&#123; &#125;);]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootStrap基础知识学习]]></title>
    <url>%2F2018%2F08%2F16%2FBootStrap%2F</url>
    <content type="text"><![CDATA[BootStrap基础学习使用BootStrap开发一个响应式的页面出来BootStap概述 什么是BootStrap Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。 Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。Bootstrap一经推出后颇受欢迎，一直是GitHub上的热门开源项目，包括NASA的MSNBC（微软全国广播公司）的Breaking News都使用了该项目。国内一些移动开发者较为熟悉的框架，如WeX5前端开源框架等，也是基于Bootstrap源码进行性能优化而来 BootStrap结构 全局CSS bootStrap中已经定义好了一套CSS的样式表 组件 BootStrap定义的一套按钮,导航条等组件 JS插件 BootStrap定义了一套JS的插件,这些插件已经默认实现了很多种效果 BootStrap的入门开发 引入相关的头文件 12345678910&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;&lt;link rel="stylesheet" href="../css/bootstrap.css" /&gt;&lt;!--需要引入JQuery--&gt;&lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script type="text/javascript" src="../js/bootstrap.js" &gt;&lt;/script&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; BootStrap的布局容器 .container 类用于固定宽度并支持响应式布局的容器。 123&lt;div class=&quot;container&quot;&gt; ...&lt;/div&gt; .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。 123&lt;div class=&quot;container-fluid&quot;&gt; ...&lt;/div&gt; 校验表单扩展: trigger : 触发浏览器默认行为 triggerHandler : 不会触发 is : 判断 find : 查找 什么json: 轻量级的数据交换格式 json对象: {“username”:”zhangsan”} json数组: [ {“username”:”zhangsan”}, {“username”:”zhangsan”}, {“username”:”zhangsan”}] ajax异步请求: 同步和异步 row Bootstrap 栅格系统的工作原理： “行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。 通过“行（row）”在水平方向创建一组“列（column）”。 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。 类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。 通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding BootStrap的栅格系统 响应式设计: 这种设计依赖于CSS3中的媒体查询 栅格样式: 设备分辨率大于1200 使用lg样式 设备分辨率大于992 &lt; 1200 使用md样式 设备分辨率大于768 &lt; 992 使用sm样式 设备分辨率小于768使用xs样式 BootStrap的全局CSS 定义了一套CSS 对页面中的元素进行定义 列表元素,表单,按钮,图片 简单案例实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 准备工作: &lt;meta name='viewport'&gt; 1.导入bootstrap css文件 2.导入JQuery 3.bootstrap.js 4.写一个div class = container 支持响应式的布局容器 --&gt; &lt;link rel="stylesheet" href="../css/bootstrap.min.css"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt; &lt;script src="../js/jquery-1.11.0.js"&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src="../js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-4"&gt; &lt;img src="../img/logo2.png" /&gt; &lt;/div&gt; &lt;div class="col-md-4 hidden-xs"&gt; &lt;img src="../img/header.png" /&gt; &lt;/div&gt; &lt;div class="col-md-4"&gt; &lt;a href="#"&gt;登录&lt;/a&gt; &lt;a href="#"&gt;注册&lt;/a&gt; &lt;a href="#"&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--菜单--&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;nav class="navbar navbar-inverse" role="navigation"&gt; &lt;div class="container-fluid"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt;首页&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt; &lt;a href="#"&gt;手机数码&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;鞋靴箱包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;电脑办公&lt;/a&gt; &lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown"&gt;所有分类 &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu" role="menu"&gt; &lt;li&gt; &lt;a href="#"&gt;手机数码&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;鞋靴箱包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;电脑办公&lt;/a&gt; &lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;Separated link&lt;/a&gt; &lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;One more separated link&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-right" role="search"&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control" placeholder="请输入要搜索的商品"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;!-- /.navbar-collapse --&gt; &lt;/div&gt; &lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt; &lt;!-- Indicators --&gt; &lt;ol class="carousel-indicators"&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class="carousel-inner" role="listbox"&gt; &lt;div class="item active"&gt; &lt;img src="../img/1.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="../img/2.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="../img/3.jpg" alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;!--最新商品这里--&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;h3&gt;最新商品&lt;img src="../images/title2.jpg"/&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--商品部分 --&gt; &lt;div class="row"&gt; &lt;!--左边div--&gt; &lt;div class="col-md-2 hidden-sm hidden-xs"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%" /&gt; &lt;/div&gt; &lt;!--右边div--&gt; &lt;div class="col-md-10"&gt; &lt;!--上面部分--&gt; &lt;div class="row"&gt; &lt;!--中等广告图--&gt; &lt;div class="col-md-6"&gt; &lt;img src="../products/hao/middle01.jpg" width="100%" /&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--下面部分--&gt; &lt;div class="row"&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;img src="../products/hao/ad.jpg" width="100%" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--最新商品这里--&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;h3&gt;最新商品&lt;img src="../images/title2.jpg"/&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--商品部分 --&gt; &lt;div class="row"&gt; &lt;!--左边div--&gt; &lt;div class="col-md-2 hidden-sm hidden-xs"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%" /&gt; &lt;/div&gt; &lt;!--右边div--&gt; &lt;div class="col-md-10"&gt; &lt;!--上面部分--&gt; &lt;div class="row"&gt; &lt;!--中等广告图--&gt; &lt;div class="col-md-6"&gt; &lt;img src="../products/hao/middle01.jpg" width="100%" /&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--下面部分--&gt; &lt;div class="row"&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;!--商品项--&gt; &lt;div class="col-md-2 col-xs-4" style="text-align: center;"&gt; &lt;img src="../products/hao/small01.jpg" /&gt; &lt;p&gt;豆浆机&lt;/p&gt; &lt;p&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--页脚广告--&gt; &lt;div&gt; &lt;img src="../image/footer.jpg" width="100%" /&gt; &lt;/div&gt; &lt;!--网站声明--&gt; &lt;div style="text-align: center;"&gt; &lt;a href="http://www.itheima.com"&gt;关于我们&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;联系我们&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;招贤纳士&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;法律声明&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;友情链接&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;支付方式&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;配送方式&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;服务声明&lt;/a&gt; &lt;a href="http://www.itheima.com"&gt;广告声明&lt;/a&gt; &lt;br /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>BootStrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础知识学习]]></title>
    <url>%2F2018%2F08%2F16%2FjavaScript%2F</url>
    <content type="text"><![CDATA[JavaScript基础知识学习概述JavaScript概述什么是javascript: JavaScript一种直译式脚本语言， 什么是脚本语言? java源代码 ----&gt; 编译成.class文件 -----&gt; java虚拟机中才能执行 脚本语言: 源码 -------- &gt; 解释执行 js由我们的浏览器来解释执行 HTML: 决定了页面的框架 CSS: 用来美化我们的页面 JS: 提供用户的交互的 JS的组成:ECMAScript : 核心部分 ,定义js的语法规范 DOM: document Object Model 文档对象模型 , 主要是用来管理页面的 BOM : Browser Object Model 浏览器对象模型, 前进,后退,页面刷新, 地址栏, 历史记录, 屏幕宽高 JS的语法:变量弱类型: var i = true 区分大小写 语句结束之后的分号 ,可以有,也可以没有 写在script标签 JS的数据类型: 基本类型 string number boolean undefine null 引用类型 对象, 内置对象 类型转换 js内部自动转换 JS的运算符和语句: 运算符和java 一样 “===” 全等号: 值和类型都必须相等 == 值相等就可以了 语句和java 一样 JS的输出 alert() 直接弹框 document.write() 向页面输出 console.log() 向控制台输出 innerHTML: 向页面输出 获取页面元素: document.getElementById(“id的名称”); JS声明变量: var 变量的名称 = 变量的值 JS声明函数: var 函数的名称 = function(){ } function 函数的名称(){ } JS开发步骤1231. 确定事件2. 事件要触发函数,所以我们是要声明函数3. 函数里面通常是去做一些交互才操作, 弹框, 修改页面内容,动态去添加一些东西 使用JS完成简单的数据校验使用JS完成对注册页面的简单数据校验,不允许出现用户名或密码为空的情况 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /* 1. 确认事件: 表单提交事件 onsubmit事件 2. 事件所要触发的函数: checkForm 3. 函数中要干点事情 1. 校验用户名, 用户不能为空, 长度不能小于6位 1.获取到用户输入的值 */ function checkForm()&#123; //获取用户名输入项 var inputObj = document.getElementById("username"); //获取输入项的值 var uValue = inputObj.value;// alert(uValue); //用户名长度不能6位 "" if(uValue.length &lt; 6 )&#123; alert("对不起,您的长度太短!"); return false; &#125; //密码长度大于6 和确认必须一致 //获取密码框输入的值 var input_password = document.getElementById("password"); var uPass = input_password.value; if(uPass.length &lt; 6)&#123; alert("对不起,您还是太短啦!"); return false; &#125; //获取确认密码框的值 var input_repassword = document.getElementById("repassword"); var uRePass = input_repassword.value; if(uPass != uRePass)&#123; alert("对不起,两次密码不一致!"); return false; &#125; //校验手机号 var input_mobile = document.getElementById("mobile"); var uMobile = input_mobile.value; // if(!/^[1][3578][0-9]&#123;9&#125;$/.test(uMobile))&#123; alert("对不起,您的手机号无法识别!"); return false; &#125; //校验邮箱: /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/ var inputEmail = document.getElementById("email"); var uEmail = inputEmail.value; if(!/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/.test(uEmail))&#123; alert("对不起,邮箱不合法"); return false; &#125; return true; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="JS开发步骤.html" onsubmit="return checkForm()"&gt; &lt;div&gt;用户名:&lt;input id="username" type="text" /&gt;&lt;/div&gt; &lt;div&gt;密码:&lt;input id="password" type="password" /&gt;&lt;/div&gt; &lt;div&gt;确认密码:&lt;input id="repassword" type="password" /&gt;&lt;/div&gt; &lt;div&gt;手机号码:&lt;input id="mobile" type="number" /&gt;&lt;/div&gt; &lt;div&gt;邮箱:&lt;input id="email" type="text" /&gt;&lt;/div&gt; &lt;div&gt;&lt;input type="submit" value="注册" /&gt;&lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 使用JS完成图片的轮播效果步骤分析:1234561. 确定事件: 文档加载完成的事件 onload2. 事件要触发 : init()3. 函数里面要做一些事情:(通常会去操作元素,提供交互) 1. 开启定时器: 执行切换图片的函数 changeImg()4. changeImg() 1. 获得要切换图片的那个元素 代码实现:1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /* 当页面加载完成的时候, 动态切换图片 1.确定事件: 2.事件所要触发的函数 */ var index = 1; //切换图片的函数 function changeAd()&#123; //获取要操作的img var img = document.getElementById("imgAd"); img.src = "../img/"+(index%3+1)+".jpg"; //0,1,2 //1,2,3 index++; &#125; function init()&#123; //启动定时器 setInterval("changeAd()",3000); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload="init()"&gt; &lt;img src="../img/1.jpg" id="imgAd"/&gt; &lt;/body&gt;&lt;/html&gt; 完成页面定时弹出图片技术分析 定时器 setInterval : 每隔多少毫秒执行一次函数 setTimeout: 多少毫秒之后执行一次函数 clearInterval clearTimeout 显示广告 img.style.display = “block” 隐藏广告 img.style.display = “none” 步骤分析 确定事件: 页面加载完成的事件 onload 事件要触发函数: init() init函数里面做一件事: 启动一个定时器 : setTimeout() 显示一个广告 再去开启一个定时5秒钟之后,关闭广告 代码实现1234567891011121314151617181920212223&lt;script&gt; function init()&#123; setTimeout("showAD()",3000); &#125; function showAD()&#123; //首先要获取要操作的img var img = document.getElementById("img1"); //显示广告 img.style.display = "block"; //再开启定时器,关闭广告 setTimeout("hideAD()",3000); &#125; function hideAD()&#123; //首先要获取要操作的img var img = document.getElementById("img1"); //隐藏广告 img.style.display = "none"; &#125; &lt;/script&gt; 完成完成表单的校验【JS中的常用事件】 onfocus 事件: 获得焦点事件 onblur : 失去焦点 onkeyup : 按键抬起事件 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 引入外部的js文件 --&gt; &lt;script type="text/javascript" src="../js/regutils.js" &gt;&lt;/script&gt; &lt;script&gt; /* 1. 确定事件 : onfocus 2. 事件要驱动函数 3. 函数要干一些事情: 修改span的内容 */ function showTips(spanID,msg)&#123; //首先要获得要操作元素 span var span = document.getElementById(spanID); span.innerHTML = msg; &#125; /* 校验用户名: 1.事件: onblur 失去焦点 2.函数: checkUsername() 3.函数去显示校验结果 */ function checkUsername()&#123; //获取用户输入的内容 var uValue = document.getElementById("username").value; //对输入的内容进行校验 //获得要显示结果的span var span = document.getElementById("span_username"); if(uValue.length &lt; 6)&#123; //显示校验结果 span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,太短&lt;/font&gt;"; return false; &#125;else&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;恭喜您,可用&lt;/font&gt;"; return true; &#125; &#125; /* 密码校验 */ function checkPassword()&#123; //获取密码输入 var uPass = document.getElementById("password").value; var span = document.getElementById("span_password"); //对密码输入进行校验 if(uPass.length &lt; 6)&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,太短&lt;/font&gt;"; return false; &#125;else&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;恭喜您,够用&lt;/font&gt;"; return true; &#125; &#125; /* 确认密码校验 * */ function checkRePassword()&#123; //获取密码输入 var uPass = document.getElementById("password").value; //获取确认密码输入 var uRePass = document.getElementById("repassword").value; var span = document.getElementById("span_repassword"); //对密码输入进行校验 if(uPass != uRePass)&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,两次密码不一致&lt;/font&gt;"; return false; &#125;else&#123; span.innerHTML = ""; return true; &#125; &#125; /* 校验邮箱 * */ function checkMail()&#123; var umail = document.getElementById("email").value; var flag = checkEmail(umail); var span = document.getElementById("span_email"); //对邮箱输入进行校验 if(flag)&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;恭喜您,可用&lt;/font&gt;"; return true; &#125;else&#123; span.innerHTML = "&lt;font color='red' size='2'&gt;对不起,邮箱格式貌似有问题&lt;/font&gt;"; return false; &#125; &#125; function checkForm()&#123; var flag = checkUsername() &amp;&amp; checkPassword() &amp;&amp; checkRePassword() &amp;&amp; checkMail(); return flag; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="../01-自动轮播图片/图片自动轮播.html" onsubmit="return checkForm()" &gt; 用户名:&lt;input type="text" id="username" onfocus="showTips('span_username','用户名长度不能小于6')" onblur="checkUsername()" onkeyup="checkUsername()" /&gt;&lt;span id="span_username"&gt;&lt;/span&gt;&lt;br /&gt; 密码:&lt;input type="password" id="password" onfocus="showTips('span_password','密码长度不能小于6')" onblur="checkPassword()" onkeyup="checkPassword()"/&gt;&lt;span id="span_password"&gt;&lt;/span&gt;&lt;br /&gt; 确认密码:&lt;input type="password" id="repassword" onfocus="showTips('span_repassword','两次密码必须一致')" onblur="checkRePassword()" onkeyup="checkRePassword()" /&gt;&lt;span id="span_repassword"&gt;&lt;/span&gt;&lt;br /&gt; 邮箱:&lt;input type="text" id="email" onfocus="showTips('span_email','邮箱格式必须正确')" onblur="checkMail()" /&gt;&lt;span id="span_email"&gt;&lt;/span&gt;&lt;br /&gt; 手机号:&lt;input type="text" id="text" /&gt;&lt;br /&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 定时器: setInterval(&quot;test()&quot;,3000) 每隔多少毫秒执行一次函数 setTimeout(&quot;test()&quot;,3000) 多少毫秒之后执行一次函数 timerID 上面定时器调用之后 clearInterval() clearTimeout() 切换图片 img.src = &quot;图片路径&quot; 事件: 文档加载完成的事件 onload事件 显示广告 : img.style.display = “block” 隐藏广告: img.style.display =”none” 引入一个外部js文件 1&lt;script src="js文件的路径" type="text/javascript"/&gt; 表单校验中常用的事件: 获得焦点事件: onfocus 失去焦点事件 onblur 按键抬起事件: onkeyup JS开发步骤 1231. 确定事件2. 事件要触发函数: 定义函数3. 函数通常都要去做一些交互: 点击, 修改图片, 动态修改innerHTML属性... innerTEXT 表格隔行换色实现步骤 确定事件: 文档加载完成 onload 事件要触发函数: init() 函数:操作页面的元素要操作表格中每一行动态的修改行的背景颜色 代码实现1234567891011121314151617&lt;script &gt; function init()&#123; //得到表格 var tab = document.getElementById("tab"); //得到表格中每一行 var rows = tab.rows; //便利所有的行,然后根据奇数 偶数 for(var i=1; i &lt; rows.length; i++)&#123; var row = rows[i]; //得到其中的某一行 if(i%2==0)&#123; row.bgColor = "yellow"; &#125;else&#123; row.bgColor = "red" &#125; &#125; &#125;&lt;/script&gt; 复选框的全选和全不选使用事件 : onclick点击事件 实现步骤全选和全不选步骤分析: 1.确定事件: onclick 单机事件2.事件触发函数: checkAll()3.函数要去做一些事情: 获得当前第一个checkbox的状态 获得所有分类项的checkbox 修改每一个checkbox的状态 代码实现123456789101112131415function checkAll()&#123;// 获得当前第一个checkbox的状态 var check1 = document.getElementById("check1"); //得到当前checked状态 var checked = check1.checked;// 获得所有分类项的checkbox// var checks = document.getElementsByTagName("input"); var checks = document.getElementsByName("checkone");// alert(checks.length); for(var i = 0; i &lt; checks.length; i++)&#123;// 修改每一个checkbox的状态 var checkone = checks[i]; checkone.checked = checked; &#125; &#125; DOM操作什么是DOM: Document Object Model : 管理我们的文档 增删改查规则 【HTML中的DOM操作】 12345678910111213141516171819202122232425262728293031一些常用的 HTML DOM 方法： getElementById(id) - 获取带有指定 id 的节点（元素） appendChild(node) - 插入新的子节点（元素） removeChild(node) - 删除子节点（元素） 一些常用的 HTML DOM 属性： innerHTML - 节点（元素）的文本值 parentNode - 节点（元素）的父节点 childNodes - 节点（元素）的子节点 attributes - 节点（元素）的属性节点 查找节点：getElementById() 返回带有指定 ID 的元素。 getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。 getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。 增加节点：createAttribute() 创建属性节点。 createElement() 创建元素节点。 createTextNode() 创建文本节点。 insertBefore() 在指定的子节点前面插入新的子节点。 appendChild() 把新的子节点添加到指定节点。 删除节点：removeChild() 删除子节点。 replaceChild() 替换子节点。 修改节点：setAttribute() 修改属性setAttributeNode() 修改属性节点 简答的实例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /* 准备工作 : 准备数据 */ var provinces = [ ["深圳市","东莞市","惠州市","广州市"], ["长沙市","岳阳市","株洲市","湘潭市"], ["厦门市","福州市","漳州市","泉州市"] ]; /* 1. 确定事件: onchange 2. 函数: selectProvince() 3. 函数里面要搞事情了 得到当前操作元素 得到当前选中的是那一个省份 从数组中取出对应的城市信息 动态创建城市元素节点 添加到城市select中 */ function selectProvince()&#123; var province = document.getElementById("province"); //得到当前选中的是哪个省份 //alert(province.value); var value = province.value; //从数组中取出对应的城市信息 var cities = provinces[value]; var citySelect = document.getElementById("city"); //清空select中的option citySelect.options.length = 0; for (var i=0; i &lt; cities.length; i++) &#123;// alert(cities[i]); var cityText = cities[i]; //动态创建城市元素节点 &lt;option&gt;东莞市&lt;/option&gt; //创建option节点 var option1 = document.createElement("option"); // &lt;option&gt;&lt;/option&gt; //创建城市文本节点 var textNode = document.createTextNode(cityText) ;// 东莞市 //将option节点和文本内容关联起来 option1.appendChild(textNode); //&lt;option&gt;东莞市&lt;/option&gt; // 添加到城市select中 citySelect.appendChild(option1); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--选择省份--&gt; &lt;select onchange="selectProvince()" id="province"&gt; &lt;option value="-1"&gt;--请选择--&lt;/option&gt; &lt;option value="0"&gt;广东省&lt;/option&gt; &lt;option value="1"&gt;湖南省&lt;/option&gt; &lt;option value="2"&gt;福建省&lt;/option&gt; &lt;/select&gt; &lt;!--选择城市--&gt; &lt;select id="city"&gt;&lt;/select&gt; &lt;/body&gt;&lt;/html&gt; 使用JS控制下拉列表左右选择代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 步骤分析 1. 确定事件: 点击事件 :onclick事件 2. 事件要触发函数 selectOne 3. selectOne要做一些操作 (将左边选中的元素移动到右边的select中) 1. 获取左边Select中被选中的元素 2. 将选中的元素添加到右边的Select中就可以 --&gt; &lt;script&gt; function selectOne()&#123;// 1. 获取左边Select中被选中的元素 var leftSelect = document.getElementById("leftSelect"); var options = leftSelect.options; //找到右侧的Select var rightSelect = document.getElementById("rightSelect"); //遍历找出被选中的option for(var i=0; i &lt; options.length; i++)&#123; var option1 = options[i]; if(option1.selected)&#123; // 2. 将选中的元素添加到右边的Select中就可以 rightSelect.appendChild(option1); &#125; &#125; &#125; //将左边所有的商品移动到右边 function selectAll()&#123;// 1. 获取左边Select中被选中的元素 var leftSelect = document.getElementById("leftSelect"); var options = leftSelect.options; //找到右侧的Select var rightSelect = document.getElementById("rightSelect"); //遍历找出被选中的option for(var i=options.length - 1; i &gt;=0; i--)&#123; var option1 = options[i]; rightSelect.appendChild(option1); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table border="1px" width="400px"&gt; &lt;tr&gt; &lt;td&gt;分类名称&lt;/td&gt; &lt;td&gt;&lt;input type="text" value="手机数码"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;分类描述&lt;/td&gt; &lt;td&gt;&lt;input type="text" value="这里面都是手机数码"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;分类商品&lt;/td&gt; &lt;td&gt; &lt;!--左边--&gt; &lt;div style="float: left;"&gt; 已有商品&lt;br /&gt; &lt;select multiple="multiple" id="leftSelect" ondblclick="selectOne()"&gt; &lt;option&gt;华为&lt;/option&gt; &lt;option&gt;小米&lt;/option&gt; &lt;option&gt;锤子&lt;/option&gt; &lt;option&gt;oppo&lt;/option&gt; &lt;/select&gt; &lt;br /&gt; &lt;a href="#" onclick="selectOne()"&gt; &amp;gt;&amp;gt; &lt;/a&gt; &lt;br /&gt; &lt;a href="#" onclick="selectAll()"&gt; &amp;gt;&amp;gt;&amp;gt; &lt;/a&gt; &lt;/div&gt; &lt;!--右边--&gt; &lt;div style="float: right;"&gt; 未有商品&lt;br /&gt; &lt;select multiple="multiple" id="rightSelect"&gt; &lt;option&gt;苹果6&lt;/option&gt; &lt;option&gt;肾7&lt;/option&gt; &lt;option&gt;诺基亚&lt;/option&gt; &lt;option&gt;波导&lt;/option&gt; &lt;/select&gt; &lt;br /&gt; &lt;a href="#"&gt; &amp;lt;&amp;lt; &lt;/a&gt; &lt;br /&gt; &lt;a href="#"&gt; &amp;lt;&amp;lt;&amp;lt; &lt;/a&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;input type="submit" value="提交"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 知识点总结:定时器: setInterval setTimeout clearInterval clearTimeout 控制图片显示隐藏 img.style.display = &quot;block&quot; img.style.display = &quot;none&quot; 表单中常用的事件: onfocus: 获取焦点事件 onblur : 失去焦点的事件 onkeyup: 按键抬起的事件 onclick: 单击事件 ondblclick: 双击事件 表格隔行换色,鼠标移入和移除要变色: onmouseenter: 鼠标移入 onmouseout: 鼠标移出 onload: 文档加载完成事件 onsubmit: 提交 onchange: 下拉列表内容改变 checkbox.checked 选中状态 DOM的文档操作: 添加节点: appendChild 创建节点: document.createElement 创建文本节点: document.createTextNode() JS开发步骤: 1231. 确认事件2. 事件触发函数3. 函数里面要做一些交互]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS与简单的js基础知识学习]]></title>
    <url>%2F2018%2F08%2F15%2FCSS%2F</url>
    <content type="text"><![CDATA[CSS与简单的js基础知识学习学习了一段时间的后端的知识，在开发项目的时候对于前端慢慢的学看的也七七八八，现在就重新系统的学习下基础知识,也能减少查手册的时间。 CSS简单语法CSS的简单语法: 在一个style标签中,去编写CSS内容,最好将style标签写在这个head标签中 123456&lt;style&gt; 选择器&#123; 属性名称:属性的值; 属性名称2: 属性的值2; &#125;&lt;/style&gt; CSS选择器: 帮助我们找到我们要修饰的标签或者元素 元素选择: 1234元素的名称&#123; 属性名称:属性的值; 属性名称:属性的值;&#125; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; span&#123; color:blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;简单的demo&lt;/span&gt; &lt;span&gt;简单的demo&lt;/span&gt; &lt;span&gt;简单的demo&lt;/span&gt; &lt;span&gt;简单的demo&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; ID选择器: 12345以#号开头 ID在整个页面中必须是唯一的s#ID的名称&#123; 属性名称:属性的值; 属性名称:属性的值;&#125; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #div1&#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--请将JAVAEE颜色改成红色--&gt; &lt;div id=&quot;div1&quot;&gt;JAVAEE&lt;/div&gt; &lt;div&gt;IOS&lt;/div&gt; &lt;div&gt;ANDROID&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 类选择器: 12345以 . 开头 .类的名称&#123; 属性名称:属性的值; 属性名称:属性的值;&#125; 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .shuiguo&#123; color: yellow; &#125; .shucai&#123; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;shuiguo&quot;&gt;香蕉&lt;/div&gt; &lt;div class=&quot;shucai&quot;&gt;黄瓜&lt;/div&gt; &lt;div class=&quot;shuiguo&quot;&gt;苹果&lt;/div&gt; &lt;div class=&quot;shucai&quot;&gt;茄子&lt;/div&gt; &lt;div class=&quot;shuiguo&quot;&gt;橘子&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 后代选择器 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; h1 &gt; em&#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; This is a &lt;em&gt;儿子&lt;/em&gt; &lt;strong&gt; &lt;em&gt;孙子&lt;/em&gt; &lt;/strong&gt; heading &lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; CSS的引入方式: ​ 外部样式: 通过link标签引入一个外部的css文件 ​ 内部样式: 直接在style标签内编写CSS代码 &lt;div class=&quot;shuiguo&quot; style=&quot;color:yellow&quot;&gt;香蕉&lt;/div&gt; ​ 行内样式: 直接在标签中添加一个style属性, 编写CSS样式 CSS浮动 : 浮动的元素会脱离正常的文档流,在正常的文档流中不占空间 123456789float属性: left rightclear属性: 清除浮动 both : 两边都不允许浮动 left: 左边不允许浮动 right : 右边不允许浮动流式布局 简单例子:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .logo&#123; float: left; width: 33%; /*border-width: 1px; border-style: solid; border-color: red;*/ height: 60px; line-height: 60px; /* border: 1px solid red;*/ &#125; .amenu&#123; color: white; text-decoration: none; height: 50px; line-height: 50px; &#125; .product&#123; float: left; text-align: center; width: 16%; height: 240px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. 创一个最外层div 2. 第一部份: LOGO部分: 嵌套三个div 3. 第二部分: 导航栏部分 : 放置5个超链接 4. 第三部分: 轮播图 5. 第四部分: 6. 第五部分: 直接放一张图片 7. 第六部分: 抄第四部分的 8. 第七部分: 放置一张图片 9. 第八部分: 放一堆超链接 --&gt; &lt;div&gt; &lt;!--2. 第一部份: LOGO部分: 嵌套三个div--&gt; &lt;div&gt; &lt;div class="logo"&gt; &lt;img src="../img/logo2.png"/&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;img src="../img/header.png"/&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;a href="#"&gt;登录&lt;/a&gt; &lt;a href="#"&gt;注册&lt;/a&gt; &lt;a href="#"&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--清除浮动--&gt; &lt;div style="clear: both;"&gt;&lt;/div&gt; &lt;!--3. 第二部分: 导航栏部分 : 放置5个超链接--&gt; &lt;div style="background-color: black; height: 50px;"&gt; &lt;a href="#" class="amenu"&gt;首页&lt;/a&gt; &lt;a href="#" class="amenu"&gt;手机数码&lt;/a&gt; &lt;a href="#" class="amenu"&gt;电脑办公&lt;/a&gt; &lt;a href="#" class="amenu"&gt;鞋靴箱包&lt;/a&gt; &lt;a href="#" class="amenu"&gt;香烟酒水&lt;/a&gt; &lt;/div&gt; &lt;!--4. 第三部分: 轮播图--&gt; &lt;div&gt; &lt;img src="../img/1.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--5. 第四部分:--&gt; &lt;div&gt; &lt;div&gt;&lt;h2&gt;最新商品&lt;img src="../img/title2.jpg"/&gt;&lt;/h2&gt;&lt;/div&gt; &lt;!--左侧广告图--&gt; &lt;div style="width: 15%; height: 480px; float: left;"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%"/&gt; &lt;/div&gt; &lt;!-- 右侧商品 --&gt; &lt;div style="width: 84%; height: 480px;float: left;"&gt; &lt;div style="height: 240px; width: 50%; float: left;"&gt; &lt;img src="../products/hao/middle01.jpg" height="100%" width="100%" /&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--6. 第五部分: 直接放一张图片--&gt; &lt;div&gt; &lt;img src="../products/hao/ad.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--7. 第六部分: 抄第四部分的--&gt; &lt;div&gt; &lt;div&gt;&lt;h2&gt;最新商品&lt;img src="../img/title2.jpg"/&gt;&lt;/h2&gt;&lt;/div&gt; &lt;!--左侧广告图--&gt; &lt;div style="width: 15%; height: 480px; float: left;"&gt; &lt;img src="../products/hao/big01.jpg" width="100%" height="100%"/&gt; &lt;/div&gt; &lt;!-- 右侧商品 --&gt; &lt;div style="width: 84%; height: 480px;float: left;"&gt; &lt;div style="height: 240px; width: 50%; float: left;"&gt; &lt;img src="../products/hao/middle01.jpg" height="100%" width="100%" /&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;div class="product"&gt; &lt;img src="../products/hao/small08.jpg" /&gt; &lt;p&gt;高压锅&lt;/p&gt; &lt;p style="color: red;"&gt;$998&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--8. 第七部分: 放置一张图片--&gt; &lt;div&gt; &lt;img src="../img/footer.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--9. 第八部分: 放一堆超链接--&gt; &lt;div style="text-align: center;"&gt; &lt;a href="#"&gt;关于我们&lt;/a&gt; &lt;a href="#"&gt;联系我们&lt;/a&gt; &lt;a href="#"&gt;招贤纳士&lt;/a&gt; &lt;a href="#"&gt;法律声明&lt;/a&gt; &lt;a href="#"&gt;友情链接&lt;/a&gt; &lt;a href="#"&gt;支付方式&lt;/a&gt; &lt;a href="#"&gt;配送方式&lt;/a&gt; &lt;a href="#"&gt;服务声明&lt;/a&gt; &lt;a href="#"&gt;广告声明&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 扩展: CSS的优先级 按照选择器搜索精确度来编写:行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 就近原则: 哪个离得近,就选用哪个的样式 CSS: 层叠样式表 主要作用: 美化页面2. 将页面美化和HTML代码进行分离,提高代码的服用型 选择器: 元素选择器: 标签的名称{} 类选择器: 以. 开头 .类的名称 ID选择器: 以#开头 , #ID的名称 (ID必须是页面上面唯一) CSS浮动: float : left, right 不再占有正常文档流中的空间 , 流式布局 clear : both left right ​ CSS中的其它选择器 选择器分组: 选择器1,选择器2{ 属性的名称:属性的值} 属性选择器: 1234a[title]a[titile='aaa']a[href][title]a[href][title='aaa'] 后代选择器: 爷爷选择器 孙子选择器 找出所有的后代 子元素选择器: 父选择器 &gt; 儿子选择器 伪类选择器: 通常都是用在A标签上 使用DIV+CSS完成页面的优化CSS的盒子模型: 万物皆盒子 内边距: padding-top: padding-right: padding-bottom: padding-left: 1234padding:10px; 上下左右都是10pxpadding:10px 20px; 上下是10px 左右是20pxpadding: 10px 20px 30px; 上 10px 右20px 下30px 左20pxpadding: 10px 20px 30px 40px; 上右下左, 顺时针的方向 外边距: margin-top: margin-right: margin-bottom: margin-left: CSS绝对定位: ​ position: absolute ​ top: 控制距离顶部的位置 ​ left: 控制距离左边的位置 代码实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="../css/main.css"/&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. 总共是5部分 2. 第一部分是LOGO部分 3. 第二部分是导航菜单 4. 第三部分是注册部分 5. 第四部分是FOOTER图片 6. 第五部分是一堆超链接 --&gt; &lt;div&gt; &lt;!--2. 第一部分是LOGO部分--&gt; &lt;div&gt; &lt;div class="logo"&gt; &lt;img src="../img/logo2.png" /&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;img src="../img/header.png" /&gt; &lt;/div&gt; &lt;div class="logo"&gt; &lt;a href="#"&gt;登录&lt;/a&gt; &lt;a href="#"&gt;注册&lt;/a&gt; &lt;a href="#"&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--清除浮动--&gt; &lt;div style="clear: both;"&gt;&lt;/div&gt; &lt;!--3. 第二部分是导航菜单--&gt; &lt;div style="background-color: black; height: 50px;"&gt; &lt;a href="#" class="amenu"&gt;首页&lt;/a&gt; &lt;a href="#" class="amenu"&gt;手机数码&lt;/a&gt; &lt;a href="#" class="amenu"&gt;电脑办公&lt;/a&gt; &lt;a href="#" class="amenu"&gt;鞋靴箱包&lt;/a&gt; &lt;a href="#" class="amenu"&gt;香烟酒水&lt;/a&gt; &lt;/div&gt; &lt;!--4. 第三部分是注册部分--&gt; &lt;div style="background: url(../image/regist_bg.jpg);height: 500px;"&gt; &lt;div style="position:absolute;top:200px;left:350px;border: 5px solid darkgray;width: 50%;height: 50%;background-color: white;"&gt; &lt;table width="60%" align="center"&gt; &lt;tr&gt; &lt;td colspan="2"&gt;&lt;font color="blue" size="6"&gt;会员注册&lt;/font&gt;USER REGISTER&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type="text"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type="password"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码:&lt;/td&gt; &lt;td&gt;&lt;input type="password"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;email:&lt;/td&gt; &lt;td&gt;&lt;input type="email"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;姓名:&lt;/td&gt; &lt;td&gt;&lt;input type="text"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt;&lt;input type="radio" name="sex"/&gt; 男 &lt;input type="radio" name="sex"/&gt; 女 &lt;input type="radio" name="sex"/&gt; 妖 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;出生日期:&lt;/td&gt; &lt;td&gt;&lt;input type="date"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码:&lt;/td&gt; &lt;td&gt;&lt;input type="text"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="submit" value="注册"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--5. 第四部分是FOOTER图片--&gt; &lt;div&gt; &lt;img src="../img/footer.jpg" width="100%"/&gt; &lt;/div&gt; &lt;!--9. 第四部分: 放一堆超链接--&gt; &lt;div style="text-align: center;"&gt; &lt;a href="#"&gt;关于我们&lt;/a&gt; &lt;a href="#"&gt;联系我们&lt;/a&gt; &lt;a href="#"&gt;招贤纳士&lt;/a&gt; &lt;a href="#"&gt;法律声明&lt;/a&gt; &lt;a href="#"&gt;友情链接&lt;/a&gt; &lt;a href="#"&gt;支付方式&lt;/a&gt; &lt;a href="#"&gt;配送方式&lt;/a&gt; &lt;a href="#"&gt;服务声明&lt;/a&gt; &lt;a href="#"&gt;广告声明&lt;/a&gt; &lt;br /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 上面用到的CSS部分的技术:​ CSS: 层叠样式表. ​ CSS作用: 美化页面,提高代码的复用性 ​ 选择器: ​ 需要掌握的: ​ 元素选择器: 标签的名称 ​ 类选择器: 以 . 开头 ​ ID选择器: 以#开头, #ID的名称 ID必须是唯一的 ​ 优先级: 按照选择精确度: 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 ​ 就近原则 ​ 扩展选择器: ​ 选择器分组: 选择器1,选择器2 以逗号隔开 ​ 后代选择器: 爷爷 孙子 中间以空格隔开 ​ 子元素选择器: 爸爸 &gt; 儿子 ​ 属性选择器: 选择器[属性的名称=’’] ​ 伪类选择器: 超链接标签上使用 ​ 浮动: float属性 left right ​ 清除浮动: clear: both left right ​ 盒子模型: 顺时针 : 上右下左 ​ padding : 内边距 ,控制的是盒子内容的距离 ​ margin : 外边距 控制盒子与盒子之间的距离 ​ 绝对定位: ​ position: absolute ​ top: ​ left:]]></content>
      <categories>
        <category>前端基础总结</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下重启网卡报错]]></title>
    <url>%2F2018%2F08%2F09%2FLinuxNetworkRestartError%2F</url>
    <content type="text"><![CDATA[重启网卡报Job for network.service failed because the control process exited with error code. 错误centos7下重启网卡 1systemctl restart network 然后报错 Job for network.service failed because the control process exited with error code. See “systemctl status network.service” and “journalctl -xe” for details. 解决方法： 执行 1systemctl stop NetworkManager 然后执行 1systemctl disable NetworkManager 然后重启网卡 1systemctl restart network 看一下网卡的状态 1ifconfig 如图：]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>NetWork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习之高并发接口优化]]></title>
    <url>%2F2018%2F08%2F09%2FSecurityOptimise%2F</url>
    <content type="text"><![CDATA[SpringBoot学习之高并发接口优化—–秒杀接口地址隐藏(验证码)+接口限流防刷秒杀接口地址隐藏思路：秒杀开始之前，先去请求接口获取秒杀地址。 123- 接口改造，带上PathVariable参数- 添加生成地址的接口- 秒杀收到请求，先验证PathVariable 随机生成一个字符串，作为地址加在url上，然后生成的时候，存入 redis缓存中，根据前端请求的url获取path。 判断与缓存中的字符串是否一致，一致就认为对的。就可以执行秒杀操作，否则失败。 对于秒杀接口，不是直接去请求秒杀的这个接口了， 而是先请求下获取path。之后拼接成秒杀地址。 前端代码： 1234567891011121314151617181920212223function getMiaoshaPath() &#123; goodsId:$("#goodsId").val(), g_showLoading(); $.ajax(&#123; url:"/miaosha/path", type:"GET", data:&#123; goodsId:$("#goodsId").val(), verifyCode:$("#verifyCode").val() &#125;, success:function (data) &#123; if(data.code == 0)&#123; var path = data.data; doMiaosha(path); &#125;else &#123; layer.msg(data.msg); &#125; &#125;, error:function() &#123; layer.msg("客户端请求错误"); &#125; &#125;);&#125; 对应的后端代码： 12345678910111213141516171819@AccessLimit(seconds = 5,maxCount = 5, needLogin = true)@RequestMapping(value = "/path",method = RequestMethod.GET)@ResponseBodypublic Result&lt;String&gt; getSecKillPath(HttpServletRequest request, SecKillUser user, @RequestParam("goodsId") long goodsId, @RequestParam(value = "verifyCode", defaultValue = "0") int verifyCode)&#123; if (user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; //验证码的校验 boolean check = secKillService.checkVerifyCode(user,goodsId,verifyCode); if (!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL); &#125; //生成path String path = secKillService.createSecKillPath(user,goodsId); return Result.success(path);&#125; 生成path，存入redis中 12345678public String createSecKillPath(SecKillUser user, Long goodsId) &#123; if (user == null || goodsId &lt;= 0)&#123; return null; &#125; String str = MD5Util.md5(UUIDUtil.uuid() + "123456"); redisService.set(SecKillKey.getPath,user.getId()+"_"+goodsId,str); return str; &#125; 秒杀接口，先拿到这个path验证一下是否正确，正确再进入下面的逻辑： 12345//验证pathboolean check = secKillService.checkPath(user,goodsId,path);if (!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL);&#125; 具体的验证，就是取出缓存中的path，与前端传来的path进行对比，相等，说明是这个用户发来的请求： 1234567891011121314/*** 验证秒杀接口参数* @param user* @param goodsId* @param path* @return*/public boolean checkPath(SecKillUser user, long goodsId, String path) &#123; if (user == null || path == null)&#123; return false; &#125; String pathOld = redisService.get(SecKillKey.getPath,""+user.getId()+"_"+goodsId,String.class); return path.equals(pathOld);&#125; 然后前端拼接出秒杀的地址 1234567891011121314151617181920function doMiaosha(path)&#123; $.ajax(&#123; url:"/miaosha/"+path+"/do_miaosha", type:"POST", data:&#123; goodsId:$("#goodsId").val() &#125;, success:function(data)&#123; if(data.code == 0)&#123; // window.location.href="/order_detail.htm?orderId="+data.data.id; getMiaoShaResult($("#goodsId").val()); &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125; 公式验证码思路：点击秒杀之前，先输入验证码，分散用户的请求 12 前端增加获取验证码显示验证码输入验证码上传。 1234567&lt;div class="row"&gt; &lt;div class="form-inline"&gt; &lt;img id="verifyCodeImg" width="80" height="32" style="display: none" onclick="refreshVerifyCode()"/&gt; &lt;input id="verifyCode" class="form-control" style="display: none"/&gt; &lt;button class="btn btn-primary" type="button" id="buyButton"onclick="getMiaoshaPath()"&gt;立即秒杀&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 增加返回验证码的接口 12345678910111213141516171819202122232425/** * 获取验证码 * @param response * @param user * @param goodsId * @return */ @RequestMapping(value = "/verifyCode",method = RequestMethod.GET) @ResponseBody public Result&lt;String&gt; getMiaoshaVerifyCode(HttpServletResponse response, SecKillUser user, @RequestParam("goodsId") long goodsId)&#123; if (user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; BufferedImage image = secKillService.createSecKillVerifyCode(user,goodsId); try&#123; OutputStream out = response.getOutputStream(); //输出流 ImageIO.write(image,"JPEG",out); //图片写入输出流 out.flush(); out.close(); return null; &#125;catch (Exception e)&#123; e.printStackTrace(); return Result.error(CodeMsg.SECKILL_FAILED); &#125; &#125; 在每次秒杀的时候，要先判断这个验证码是否正确 12345//验证码的校验boolean check = secKillService.checkVerifyCode(user,goodsId,verifyCode);if (!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL);&#125; 生成数字验证码并存入redis中，判断也是从redis中取出来判断 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public BufferedImage createSecKillVerifyCode(SecKillUser user, long goodsId) &#123; if (user == null || goodsId &lt;= 0)&#123; return null; &#125; int width = 80; int height = 32; //生成图片 BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = image.getGraphics(); // 背景 g.setColor(new Color(0xDCDCDC)); g.fillRect(0, 0, width, height); // 背景上生成矩形框 g.setColor(Color.black); g.drawRect(0, 0, width - 1, height - 1); // 随机数 Random rdm = new Random(); // 生成干扰点 for (int i = 0; i &lt; 50; i++) &#123; int x = rdm.nextInt(width); int y = rdm.nextInt(height); g.drawOval(x, y, 0, 0); &#125; // 生成验证码 String verifyCode = generateVerifyCode(rdm); g.setColor(new Color(0, 100, 0)); g.setFont(new Font("Candara", Font.BOLD, 24)); g.drawString(verifyCode, 8, 24); g.dispose(); //把验证码存到redis中 int rnd = calc(verifyCode); redisService.set(SecKillKey.getSecKillVerifyCode, user.getId()+","+goodsId, rnd); //输出图片 return image; &#125; private static char[] ops = new char[] &#123;'+', '-', '*'&#125;; /** * 生成验证码公式 * + - * * */ private String generateVerifyCode(Random rdm) &#123; int num1 = rdm.nextInt(10); int num2 = rdm.nextInt(10); int num3 = rdm.nextInt(10); char op1 = ops[rdm.nextInt(3)]; char op2 = ops[rdm.nextInt(3)]; String exp = ""+ num1 + op1 + num2 + op2 + num3; return exp; &#125; /** * Java ScriptEngine 解析js计算验证码 * @param exp 验证码 * @return */ private static int calc(String exp) &#123; try &#123; ScriptEngineManager manager = new ScriptEngineManager(); ScriptEngine engine = manager.getEngineByName("JavaScript"); return (Integer)engine.eval(exp); &#125;catch(Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; 前端在function getMiaoshaPath()这个函数中将结果传到后端，后端在这个获取真正秒杀链接的时候进行判断是否正确： 1verifyCode:$("#verifyCode").val() 后端接收验证码验证 123456789101112131415161718@AccessLimit(seconds = 5,maxCount = 5, needLogin = true) @RequestMapping(value = "/path",method = RequestMethod.GET) @ResponseBody public Result&lt;String&gt; getMiaoshaPath(HttpServletRequest request, SecKillUser user, @RequestParam("goodsId") long goodsId, @RequestParam(value = "verifyCode", defaultValue = "0") int verifyCode)&#123; if (user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; //验证码的校验 boolean check = secKillService.checkVerifyCode(user,goodsId,verifyCode); if (!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL); &#125; String path = secKillService.createSecKillPath(user,goodsId); return Result.success(path); &#125; redis中取出生成时存入的验证码并与前端传进来的验证码做校验 1234567891011121314151617181920/** * 验证码的验证 * @param user 用户 * @param goodsId 商品id * @param verifyCode 验证码 * @return */ public boolean checkVerifyCode(SecKillUser user, long goodsId, int verifyCode) &#123; if (user == null || goodsId &lt;= 0)&#123; return false; &#125; Integer codeOld = redisService.get(SecKillKey.getSecKillVerifyCode, user.getId()+&quot;,&quot;+goodsId, Integer.class); if (codeOld == null || codeOld - verifyCode != 0)&#123; return false; &#125; //把当前的验证码清除 redisService.delete(SecKillKey.getSecKillVerifyCode, user.getId()+&quot;,&quot;+goodsId); return true; &#125; 接口限流防刷思路：对接口做限流 可以使用拦截器减少对业务的侵入 点击秒杀之后，首先是生成path，那假如我们对这个接口进行限制：5秒之内用户只能点击5次。 这放在redis中是非常好实现的，因为redis有个自增(自减)和缓存时间，可以很好地实现这个效果。 这里使用注解的方式来实现接口的限流防刷，使用注解的话就可以做成通用的方法，在你想使用限流防刷的接口就可以添加上该注解 假设，我想在5秒内最多请求5次，并且必须要登陆：相应的注解就是这样的： 1@AccessLimit(seconds = 5,maxCount = 5,needLogin = true) 首先是实现这个注解： 12345678910111213141516171819package com.springboot.SecKill.access;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import static java.lang.annotation.ElementType.METHOD;/** * 注解 * @author WilsonSong * @date 2018/8/9/009 */@Retention(RetentionPolicy.RUNTIME)@Target(METHOD)public @interface AccessLimit &#123; int seconds(); int maxCount(); boolean needLogin() default true;&#125; 要想这个注解能够生效，必须要配置拦截器AccessInterceptor： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.springboot.SecKill.access;import com.alibaba.fastjson.JSON;import com.springboot.SecKill.domain.SecKillUser;import com.springboot.SecKill.redis.AccessKey;import com.springboot.SecKill.redis.RedisService;import com.springboot.SecKill.result.CodeMsg;import com.springboot.SecKill.result.Result;import com.springboot.SecKill.service.SecKillUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.StringUtils;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.OutputStream;/** * 拦截器 * @author WilsonSong * @date 2018/8/9/009 */@Servicepublic class AccessInterceptor extends HandlerInterceptorAdapter&#123; @Autowired SecKillUserService secKillUserService; @Autowired RedisService redisService; //方法执行前执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if(handler instanceof HandlerMethod)&#123; SecKillUser user = getUser(request,response); UserContext.setUser(user); //把用户保存在本地线程变量中,并且该user与线程绑定一直执行到结束 HandlerMethod handlerMethod = (HandlerMethod)handler; AccessLimit accessLimit = handlerMethod.getMethodAnnotation(AccessLimit.class); //取方法上的注解 if (accessLimit == null)&#123; return true; &#125; int seconds = accessLimit.seconds(); int maxCount = accessLimit.maxCount(); boolean needLogin = accessLimit.needLogin(); String key = request.getRequestURI(); if (needLogin)&#123; if (user == null)&#123; render(response,CodeMsg.SESSION_ERROR); return false; &#125; key +="_" + user.getId(); &#125;else &#123; //da nothing &#125; //访问次数限制 访问次数存入内存 AccessKey accessKey = AccessKey.withExpires(seconds); Integer count = redisService.get(accessKey,key, Integer.class); if (count == null)&#123; redisService.set(accessKey,key, 1); &#125;else if (count &lt; maxCount)&#123; redisService.incr(accessKey,key); &#125;else &#123; render(response,CodeMsg.ACCESS_LIMIT_REACHED); return false; &#125; &#125; return true; &#125; /** * 返回客户端的错误信息 * @param response * @param cm * @throws Exception */ public void render(HttpServletResponse response,CodeMsg cm) throws Exception&#123; response.setContentType("application/json;charset=UTF-8"); //返回的数据的编码方式 OutputStream outputStream = response.getOutputStream(); String str = JSON.toJSONString(Result.error(cm)); outputStream.write(str.getBytes("UTF-8")); outputStream.flush(); outputStream.close(); &#125; /** * 通过cookie获取用户 * @param request * @param response * @return */ private SecKillUser getUser(HttpServletRequest request, HttpServletResponse response)&#123; String paramToken = request.getParameter(SecKillUserService.COOKIE_NAME_TOKEN); String cookieToken = getCookieValue(request,SecKillUserService.COOKIE_NAME_TOKEN); if (StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken))&#123; return null; &#125; String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken; return secKillUserService.getByToken(response,token); &#125; /** * 获取cookie * @param request * @param cookieName * @return */ private String getCookieValue(HttpServletRequest request,String cookieName)&#123; Cookie[] cookies = request.getCookies(); if(cookies == null || cookies.length &lt;= 0)&#123; return null; &#125; for (Cookie cookie : cookies)&#123; if (cookie.getName().equals(cookieName))&#123; return cookie.getValue(); &#125; &#125; return null; &#125;&#125; 要想这个拦截器工作，我们要重写WebMvcConfigurerAdapter中的addInterceptors方法，将我们的拦截器添加进去就可以了： 123public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(accessInterceptor);&#125; 这样，利用注解和拦截器就实现了接口通用的限流功能。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>接口优化，秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习之秒杀接口优化]]></title>
    <url>%2F2018%2F08%2F08%2FAPIIOptimise%2F</url>
    <content type="text"><![CDATA[使用RabbitMQ改写秒杀功能实现思路思路：减少数据库访问 具体的实现流程就是 1234567891.系统初始化，把商品库存数量加载到Redis2.收到请求，Redis预减库存，库存不足，直接返回，否则33.请求入队，立即返回排队中4.请求出队，生成订单，减少库存5.客户端轮询，是否秒杀成功 其中4和5是同时并发处理的。 具体实现系统初始化，把商品库存数量加载到Redis如何在初始化的时候就将库存数据存入缓存中 通过实现InitializingBean接口中的一个方法:afterPropertiesSet() 系统初始化会首先调用该函数： 12345678910111213141516/** * 系统初始化会调用该函数 * @throws Exception */ @Override public void afterPropertiesSet() throws Exception &#123; List&lt;GoodsVo&gt; goodsVoList = goodsService.listGoodsVo(); if (goodsVoList == null)&#123; return; &#125; for (GoodsVo goodsVo:goodsVoList)&#123; //预先把商品库存加载到redis中 redisService.set(GoodsKey.getSeckillGoodsStock,""+goodsVo.getId(),goodsVo.getStockCount()); localOverMap.put(goodsVo.getId(),false); &#125; &#125; 收到请求，Redis预减库存，库存不足，直接返回，否则请求入队，立即返回排队中首先需要一个RabbitMQ的队列 使用Direct交换机模式 12345678/** * Direct 交换机模式 */ //队列 @Bean public Queue secKill_QUEUE() &#123; return new Queue(SECKILL_QUEUE,true); &#125; 队列消息的发送 123456public void sendSecKillMessage(SecKillMessage secKillMessage) &#123; String msg = RedisService.Bean2String(secKillMessage); logger.info(&quot;send SecKill message: &quot; + msg); amqpTemplate.convertAndSend(MQConfig.SECKILL_QUEUE, msg); &#125; 秒杀的实现 1234567891011121314151617//预先减库存long stock = redisService.decr(GoodsKey.getSeckillGoodsStock,""+goodsId);if (stock &lt; 0)&#123;localOverMap.put(goodsId,true);return Result.error(CodeMsg.SECKILL_OVER);&#125;//判断是否已经秒杀到了SecKillOrder order = orderService.getOrderByUserIdGoodsId(user.getId(),goodsId);if (order != null)&#123;return Result.error( CodeMsg.SECKILL_REPEATE);&#125;//压入RabbitMQ队列SecKillMessage secKillMessage = new SecKillMessage();secKillMessage.setUser(user);secKillMessage.setGoodsId(goodsId);mqSender.sendSecKillMessage(secKillMessage);return Result.success(0); //排队中 请求出队，生成订单，减少库存其实就是RabbitMQ的队列出队去处理相关的业务 1234567891011121314151617181920212223@RabbitListener(queues = MQConfig.SECKILL_QUEUE) public void receive(String message)&#123; logger.info("receive message" + message); SecKillMessage secKillMessage = RedisService.String2Bean(message,SecKillMessage.class); SecKillUser user = secKillMessage.getUser(); long goodsId = secKillMessage.getGoodsId(); //判断库存 GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId); int stock = goods.getStockCount(); if (stock &lt;= 0)&#123; return; &#125; //判断是否已经秒杀到了 SecKillOrder order = orderService.getOrderByUserIdGoodsId(user.getId(),goodsId); if (order != null)&#123; return; &#125; //减库存 下订单 写入秒杀订单 //订单的详细信息 OrderInfo orderInfo = secKillService.secKill(user, goods); &#125; 客户端轮询，是否秒杀成功123456789101112131415161718192021//秒杀的结果 /** * orderId:秒杀成功 * -1： 秒杀失败 * 0：排队中 * @param model * @param user * @param goodsId * @return */ @RequestMapping(value = "/result",method = RequestMethod.GET) @ResponseBody public Result&lt;Long&gt; miaoshaResult(Model model, SecKillUser user, @RequestParam("goodsId") long goodsId)&#123; model.addAttribute("user",user); if (user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; long result = secKillService.getSecKillResult(user.getId(),goodsId); return Result.success(result); &#125; secKillService.getSecKillResult(): 1234567891011121314151617181920212223//获取结果 /** * orderId :成功 * -1:失败 * 0： 排队中 * @param userId * @param goodsId * @return */ public long getSecKillResult(Long userId, long goodsId) &#123; SecKillOrder order = orderService.getOrderByUserIdGoodsId(userId,goodsId); if (order != null)&#123; return order.getOrderId(); &#125;else &#123; boolean isOver = getGoodsOver(goodsId); if (isOver)&#123; return -1; &#125;else &#123; return 0; &#125; &#125; &#125; 这里涉及到了redis的访问，就是redis中有商品的数量，通过该参数判断卖没卖完，当一次性来了多于商品数目的请求的时候，redis预减库存，减为负数，其实在这个时候在来商品购买请求的时候就不需要在访问redis了。因为商品已经卖完了，这个时候就做一个标记，先判断内存这个标记，如果库存已经小于0了，就不再访问redis，这样就减少了redis的访问次数。 没有订单有两种情况，卖完了失败，和排队中, 在上面的秒杀那做个标记。这个商品是否秒杀完了。存入redis中。 之后去判断是否存在这个key就知道是哪种情况,这样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//事务，原子性操作 @Transactional public OrderInfo secKill(SecKillUser user, GoodsVo goods) &#123; //减库存 下订单 写入秒杀订单 必须是同时完成的 boolean success = goodsService.reduceStock(goods); //减库存成功了才进行下订单 if (success) &#123; return orderService.createOrder(user, goods); &#125;else&#123; //说明商品秒杀完了。做一个标记 setGoodsOver(goods.getId()); return null; &#125; &#125; //获取结果 /** * orderId :成功 * -1:失败 * 0： 排队中 * @param userId * @param goodsId * @return */ public long getSecKillResult(Long userId, long goodsId) &#123; SecKillOrder order = orderService.getOrderByUserIdGoodsId(userId,goodsId); if (order != null)&#123; return order.getOrderId(); &#125;else &#123; boolean isOver = getGoodsOver(goodsId); if (isOver)&#123; return -1; &#125;else &#123; return 0; &#125; &#125; &#125; public void setGoodsOver(Long goodsId) &#123; redisService.set(SecKillKey.isGoodsOver,""+goodsId,true); &#125; public boolean getGoodsOver(Long goodsId) &#123; return redisService.exists(SecKillKey.isGoodsOver,""+goodsId); &#125;&#125; 相对应的前端的修改 原来的detail页面中秒杀事件函数： 12345678910111213141516171819function doMiaosha()&#123; $.ajax(&#123; url:"/miaosha/do_miaosha", type:"POST", data:&#123; goodsId:$("#goodsId").val(), &#125;, success:function(data)&#123; if(data.code == 0)&#123; window.location.href="/order_detail.htm?orderId="+data.data.id; &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125; 秒杀到商品就直接返回，现在后端改为消息队列，所以需要增加函数进行判断，必要时需要轮询： 12345if(data.code == 0)&#123; window.location.href="/order_detail.htm?orderId="+data.data.id;&#125;else&#123; layer.msg(data.msg);&#125; 所以将其改为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//其他的部分省略...if(data.code == 0)&#123; //window.location.href="/order_detail.htm?orderId="+data.data.id; //秒杀到商品的时候，这个时候不是直接返回成功，后端是进入消息队列，所以前端是轮询结果，显示排队中 getMiaoshaResult($("#goodsId").val());&#125;else&#123; layer.msg(data.msg);&#125;...function getMiaoshaResult(goodsId) &#123; g_showLoading(); $.ajax(&#123; url:"/miaosha/result", type:"GET", data:&#123; goodsId:$("#goodsId").val(), &#125;, success:function(data)&#123; if(data.code == 0)&#123; var result = data.data; //失败--- -1 if(result &lt;= 0)&#123; layer.msg("对不起，秒杀失败！"); &#125; //排队等待，轮询--- 0 else if(result == 0)&#123;//继续轮询 setTimeout(function () &#123; getMiaoshaResult(goodsId); &#125;,50); &#125; //成功---- 1 else &#123; layer.msg("恭喜你，秒杀成功，查看订单?",&#123;btn:["确定","取消"]&#125;, function () &#123; window.location.href="/order_detail.htm?orderId="+result; &#125;, function () &#123; layer.closeAll(); &#125; ); &#125; &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125; 压测测试环境 1g + 4核 + 50000个请求]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之安装RabbitMQ（踩坑）及RabbitMQ原理和使用详解]]></title>
    <url>%2F2018%2F08%2F08%2FRabbitMQ%2F</url>
    <content type="text"><![CDATA[SpringBoot之安装RabbitMQ（踩坑）及RabbitMQ原理和使用详解安装RabbitMQ安装环境centos7 + RabbitMQ 3.7.7 + OTP 21.0 Source File 1.安装erlang: （1）.下载: http://www.erlang.org/downloads （2）.安装依赖yum install ncurses-devel （3）.解压tar xf otp_src_21.0.tar.gz （4）.安装目录./configure –prefix=/usr/local/erlang –without-javac （5）编译make （6）安装make install （7）验证安装是否成功 ​ cd /usr/local/erlang/bin/ 执行./erl 2.安装rabbitmq rabbitmq解压即可用 （1）解压xz -d rabbitmq-server-generic-unix-3.7.7.tar.xz tar xf rabbitmq-server-generic-unix-3.7.7.tar （2）安装依赖: 123yum install python -yyum install xmlto -yyum install python-simplejson -y （3）启动: cd rabbitmq/sbin/ ./rabbitmq-server 正常到这里就完成安装了，但是我的并没有，报错了 踩坑（报错四部曲）（1）启动报错啊 显示./rabbitmq-server:行85: erl: 未找到命令 解决办法执行 vim /etc/profile 在文件中添加: ERL_HOME=/usr/local/erlang export PATH=$PATH:$ERL_HOME/bin （2）再启动还报错 显示错误如下： 123456789101112Error description: init:do_boot/3 init:start_em/1 rabbit:start_it/1 line 450 rabbit:broker_start/0 line 324 rabbit_plugins:prepare_plugins/1 line 289 rabbit_plugins:ensure_dependencies/1 line 263throw:&#123;error,&#123;missing_dependencies,[crypto,ssl], [amqp10_client,cowboy,cowlib,rabbitmq_aws, rabbitmq_management, rabbitmq_management_agent,rabbitmq_shovel, rabbitmq_trust_store]&#125;&#125; 解决方法： 应该是缺少依赖，openssl的两个包 看一下自己的Linux下有没有 which openssl 我的里面是有的，显示 /usr/bin/openssl 看一下版本 openssl version 版本有点老，可能是这个原因。 重新安装spenssl https://www.openssl.org/source/ 安装的话就找个教程就完事了 （3）安装完再启动还报错 错误信息： 1/usr/local/openssl/bin/openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory 其实就是找不到libssl.so.1.1 可以做一个软连接 假如你的libssl.so.1.1 文件在/usr/local/openssl/lib/下面，可以这样做 ln -s /usr/local/openssl/lib/libssl.so.1.1 /usr/lib64/libssl.so.1.1 ln -s /usr/local/openssl/lib/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1 完成后看一下当前版本 openssl version 显示OpenSSL 1.1.0g 2 Nov 2017 然后重启一般就可以了 （4）还报错，和2一样的错误 然而我的还是还是不行，怎么办，重装erlang, 然后启动rabbitmq就好使了。 会看到log tail -f /usr/local/rabbitmq/var/log/rabbitmq/rabbit@localhost.log 看一下启动起来没有,一般是在5672端口启动的，可以看一下5672端口有没有在监听 netstat -nap | grep 5672 也可以执行 ps -ef | gerp rabbitmq 看RabbitMQ相关的服务有没有启动 关闭RabbitMQ ./rabbitmqctl stop 把rabbitmq-server 写到环境变量中 vim /etc/profile 在文件中写入 export PATH=$PATH:/usr/local/ruby/bin:/usr/local/erlang/bin:/usr/local/rabbitmq/sbin 怎么让RabbitMQ在后台运行: ./rabbitmq-server -detached RabbitMQ基本原理讲解基础概念的前面，我们先来整体构造一个结构图，这样会方便们更好地去理解RabbitMQ的基本原理。 通过上面这张应用相结合的结构图既能够清晰的看清楚整体的send Message到Receive Message的一个大致的流程。当然上面有很多名词都相比还没有介绍到，不要着急接下来我们就开始对其进行详细的讲解。 QueueQueue（队列）RabbitMQ的作用是存储消息，队列的特性是先进先出。上图可以清晰地看到Client A和Client B是生产者，生产者生产消息最终被送到RabbitMQ的内部对象Queue中去，而消费者则是从Queue队列中取出数据。可以简化成表示为： 生产者Send Message “A”被传送到Queue中，消费者发现消息队列Queue中有订阅的消息，就会将这条消息A读取出来进行一些列的业务操作。这里只是一个消费正对应一个队列Queue，也可以多个消费者订阅同一个队列Queue，当然这里就会将Queue里面的消息平分给其他的消费者，但是会存在一个一个问题就是如果每个消息的处理时间不同，就会导致某些消费者一直在忙碌中，而有的消费者处理完了消息后一直处于空闲状态，因为前面已经提及到了Queue会平分这些消息给相应的消费者。这里我们就可以使用prefetchCount来限制每次发送给消费者消息的个数。详情见下图所示： 这里的prefetchCount=1是指每次从Queue中发送一条消息来。等消费者处理完这条消息后Queue会再发送一条消息给消费者。 Exchange我们在开篇的时候就留了一个坑，就是那个应用结构图里面，消费者Client A和消费者Client B是如何知道我发送的消息是给Queue1还是给Queue2，有没有过这个问题，那么我们就来解开这个面纱，看看到底是个什么构造。首先明确一点就是生产者产生的消息并不是直接发送给消息队列Queue的，而是要经过Exchange（交换器），由Exchange再将消息路由到一个或多个Queue，当然这里还会对不符合路由规则的消息进行丢弃掉，这里指的是后续要谈到的Exchange Type。那么Exchange是怎样将消息准确的推送到对应的Queue的呢？那么这里的功劳最大的当属Binding，RabbitMQ是通过Binding将Exchange和Queue链接在一起，这样Exchange就知道如何将消息准确的推送到Queue中去。简单示意图如下所示： 在绑定（Binding）Exchange和Queue的同时，一般会指定一个Binding Key，生产者将消息发送给Exchange的时候，一般会产生一个Routing Key，当Routing Key和Binding Key对应上的时候，消息就会发送到对应的Queue中去。那么Exchange有四种类型，不同的类型有着不同的策略。也就是表明不同的类型将决定绑定的Queue不同，换言之就是说生产者发送了一个消息，Routing Key的规则是A，那么生产者会将Routing Key=A的消息推送到Exchange中，这时候Exchange中会有自己的规则，对应的规则去筛选生产者发来的消息，如果能够对应上Exchange的内部规则就将消息推送到对应的Queue中去。那么接下来就来详细讲解下Exchange里面类型。 Exchange Typefanout fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。 上图所示，生产者（P）生产消息1将消息1推送到Exchange，由于Exchange Type=fanout这时候会遵循fanout的规则将消息推送到所有与它绑定Queue，也就是图上的两个Queue最后两个消费者消费。 direct direct类型的Exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中 当生产者（P）发送消息时Rotuing key=booking时，这时候将消息传送给Exchange，Exchange获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的Queue，这时发现Queue1和Queue2都符合，就会将消息传送给这两个队列，如果我们以Rotuing key=create和Rotuing key=confirm发送消息时，这时消息只会被推送到Queue2队列中，其他Routing Key的消息将会被丢弃。 topic 前面提到的direct规则是严格意义上的匹配，换言之Routing Key必须与Binding Key相匹配的时候才将消息传送给Queue，那么topic这个规则就是模糊匹配，可以通过通配符满足一部分规则就可以传送。它的约定是： routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit” binding key与routing key一样也是句点号“. ”分隔的字符串 binding key中可以存在两种特殊字符“”与“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词（可以是零个） 当生产者发送消息Routing Key=F.C.E的时候，这时候只满足Queue1，所以会被路由到Queue中，如果Routing Key=A.C.E这时候会被同是路由到Queue1和Queue2中，如果Routing Key=A.F.B时，这里只会发送一条消息到Queue2中。 headers headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。该类型的Exchange没有用到过（不过也应该很有用武之地），所以不做介绍。 总结成表格： 类型名称 类型描述 Fandout 把所有发送到该Exchange的消息路由到所有与它绑定的Queue中 Direct Routing Key==Binding Key Topic 模糊匹配 Headers Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。 Binding所谓绑定就是将一个特定的 Exchange 和一个特定的 Queue 绑定起来。Exchange 和Queue的绑定可以是多对多的关系。 通信过程假设P1和C1注册了相同的Broker，Exchange和Queue。P1发送的消息最终会被C1消费。基本的通信流程大概如下所示： P1生产消息，发送给服务器端的Exchange Exchange收到消息，根据ROUTINKEY，将消息转发给匹配的Queue1 Queue1收到消息，将消息发送给订阅者C1 C1收到消息，发送ACK给队列确认收到消息 Queue1收到ACK，删除队列中缓存的此条消息 Consumer收到消息时需要显式的向rabbit broker发送basic.ack消息或者consumer订阅消息时设置auto_ack参数为true。在通信过程中，队列对ACK的处理有以下几种情况： 如果consumer接收了消息，发送ack,rabbitmq会删除队列中这个消息，发送另一条消息给consumer。 如果cosumer接受了消息, 但在发送ack之前断开连接，rabbitmq会认为这条消息没有被deliver,在consumer在次连接的时候，这条消息会被redeliver。 如果consumer接受了消息，但是程序中有bug,忘记了ack,rabbitmq不会重复发送消息。 rabbitmq2.0.0和之后的版本支持consumer reject某条（类）消息，可以通过设置requeue参数中的reject为true达到目地，那么rabbitmq将会把消息发送给下一个注册的consumer。 SpringBoot集成RabbitMQ(1)添加依赖 12345&lt;!--rabbitmq--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; (2)添加配置 1234567891011121314151617181920212223#rabbitmqspring.rabbitmq.host=192.168.78.133spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.virtual-host=/#消费者数量#消费者队列的数量spring.rabbitmq.listener.simple.concurrency= 10spring.rabbitmq.listener.simple.max-concurrency= 10#消费者每次从队列获取的消息数量spring.rabbitmq.listener.simple.prefetch= 1#消费者自动启动spring.rabbitmq.listener.simple.auto-startup=true#消费失败，自动重新入队spring.rabbitmq.listener.simple.default-requeue-rejected= true#启用发送重试#队列的发送者，队列满了就重置spring.rabbitmq.template.retry.enabled=truespring.rabbitmq.template.retry.initial-interval=1000 spring.rabbitmq.template.retry.max-attempts=3spring.rabbitmq.template.retry.max-interval=10000spring.rabbitmq.template.retry.multiplier=1.0 配置去这里找： https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/ 每个配置的详细信息是什么： https://github.com/spring-projects/spring-boot/blob/v2.0.4.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java 配置完成之后，RabbitMQ有4种交换机模式，下面分别实现下。 4种交换机模式实现Direct、Topic、Fanout和Headers模式的实现如下： （1）初始化队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.springboot.SecKill.rabbitmq;import org.springframework.amqp.core.*;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.retry.annotation.Backoff;import java.util.HashMap;import java.util.Map;/** * rabbitMQ配置初始化 * @author WilsonSong * @date 2018/8/8 */@Configurationpublic class MQConfig &#123; public static final String QUEUE = "queue"; public static final String TOPIC_QUEUE1 = "topic.queue1"; public static final String TOPIC_QUEUE2 = "topic.queue2"; public static final String FANOUT_QUEUE1 = "fanout.queue1"; public static final String FANOUT_QUEUE2 = "fanout.queue2"; public static final String HEADERS_QUEUE = "headers.queue"; public static final String TOPIC_EXCHANGE = "topicExchange"; public static final String FANOUT_EXCHANGE = "fanoutExchange"; public static final String HEADERS_EXCHANGE = "headersExchange"; /** * Direct 交换机模式 */ //队列 @Bean public Queue queue() &#123; return new Queue(QUEUE,true); &#125; /** * Topic 交换机模式 */ @Bean public Queue topicQueue1()&#123; return new Queue(TOPIC_QUEUE1,true); &#125; @Bean public Queue topicQueue2()&#123; return new Queue(TOPIC_QUEUE2,true); &#125; @Bean public TopicExchange topicExchange()&#123; return new TopicExchange(TOPIC_EXCHANGE); &#125; /** * 绑定Exchange和queue */ @Bean public Binding topicBinding1()&#123; return BindingBuilder.bind(topicQueue1()).to(topicExchange()).with("topic.key1"); &#125; @Bean public Binding topicBinding2()&#123; return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with("topic.#"); //# 通配符，代表多个单词 &#125; /** * Fanout模式 交换机Exchange */ @Bean public Queue fanoutQueue1()&#123; return new Queue(FANOUT_QUEUE1,true); &#125; @Bean public Queue fanoutQueue2()&#123; return new Queue(FANOUT_QUEUE2,true); &#125; @Bean public FanoutExchange fanoutExchange()&#123; return new FanoutExchange(FANOUT_EXCHANGE); &#125; @Bean public Binding fanoutBinding1()&#123; return BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange()); &#125; @Bean public Binding fanoutBinding2()&#123; return BindingBuilder.bind(fanoutQueue2()).to(fanoutExchange()); &#125; /** * Header模式 交换机Exchange */ @Bean public HeadersExchange headersExchange()&#123; return new HeadersExchange(HEADERS_EXCHANGE); &#125; @Bean public Queue headersQueue()&#123; return new Queue(HEADERS_QUEUE,true); &#125; @Bean public Binding headersBinding()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("header1","value1"); map.put("header2","value2"); return BindingBuilder.bind(headersQueue()).to(headersExchange()).whereAll(map).match(); &#125;&#125; (2)消息发送者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.springboot.SecKill.rabbitmq;import com.springboot.SecKill.redis.RedisService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.amqp.core.Message;import org.springframework.amqp.core.MessageProperties;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * @author WilsonSong * @date 2018/8/8 */@Servicepublic class MQSender &#123; private static final Logger logger = LoggerFactory.getLogger(MQReceiver.class); @Autowired AmqpTemplate amqpTemplate; /** * Direct 交换机模式 */ //消息发送到队列 public void send(Object message)&#123; String msg = RedisService.Bean2String(message); logger.info("send topic message: " + msg); amqpTemplate.convertAndSend(MQConfig.QUEUE, msg); &#125; /** * Topic 交换机模式 */ public void sendTopic(Object message)&#123; String msg = RedisService.Bean2String(message); logger.info("send topic message: " + msg); amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE,"topic.key1",msg+"1"); amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE,"topic.key2",msg+"1"); &#125; /** * Fanout模式 交换机Exchange */ public void sendFanout(Object message)&#123; String msg = RedisService.Bean2String(message); logger.info("send fanout message: " + msg); amqpTemplate.convertAndSend(MQConfig.FANOUT_EXCHANGE,"",msg+"1"); &#125; /** * Header模式 交换机Exchange *"header1","value1"要与队列初始化的时候一样 */ public void sendHeaders(Object message)&#123; String msg = RedisService.Bean2String(message); logger.info("send headers message: " + msg); MessageProperties properties = new MessageProperties(); properties.setHeader("header1","value1"); properties.setHeader("header2","value2"); Message obj = new Message(msg.getBytes(),properties); amqpTemplate.convertAndSend(MQConfig.HEADERS_EXCHANGE,"",obj); &#125;&#125; (3)消息接收 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.springboot.SecKill.rabbitmq;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Service;/** * @author WilsonSong * @date 2018/8/8 */@Servicepublic class MQReceiver &#123; private static final Logger logger = LoggerFactory.getLogger(MQReceiver.class); /** * Direct 交换机模式 */ @RabbitListener(queues = MQConfig.QUEUE) public void receive(String message)&#123; logger.info("receive message" + message); &#125; /** * Topic 交换机模式 */ @RabbitListener(queues = MQConfig.TOPIC_QUEUE1) public void receiveTopic1(String message)&#123; logger.info("receive topic queue1 message: " + message); &#125; @RabbitListener(queues = MQConfig.TOPIC_QUEUE2) public void receiveTopic2(String message)&#123; logger.info("receive topic queue2 message: " + message); &#125; /** * Fanout模式 交换机Exchange */ @RabbitListener(queues = MQConfig.FANOUT_QUEUE1) public void receiveFanout1(String message)&#123; logger.info("receive fanout queue1 message: " + message); &#125; @RabbitListener(queues = MQConfig.FANOUT_QUEUE2) public void receiveFanout2(String message)&#123; logger.info("receive fanout queue2 message: " + message); &#125; /** * Header模式 交换机Exchange */ @RabbitListener(queues = MQConfig.HEADERS_QUEUE) public void receiveFanout2(byte[] message)&#123; logger.info("receive headers queue message: " + new String(message)); &#125;&#125; 启动程序，报错了 1Caused by: com.rabbitmq.client.AuthenticationFailureException: ACCESS_REFUSED - Login was refused using authentication mechanism PLAIN. For details see the broker logfile. 其实就是拒绝我们访问啊，因为我们定义的时候就是默认的用户名和密码 12spring.rabbitmq.username=guestspring.rabbitmq.password=guest 为什么默认的是这俩？ 看一下rabbitMQ的变量定义就知道了: 123456789/** * Login user to authenticate to the broker. */ private String username = "guest"; /** * Login to authenticate against the broker. */ private String password = "guest"; 怎么改呢？ 官网这么说的 “guest” user can only connect via localhost By default, the guest user is prohibited from connecting to the broker remotely; it can only connect over a loopback interface (i.e. localhost). This applies both to AMQP 0-9-1 and to any other protocols enabled via plugins. Any other users you create will not (by default) be restricted in this way. The recommended way to address this in production systems is to create a new user or set of users with the permissions to access the necessary virtual hosts. This can be done using CLI tools, HTTP API or definitions import. This is configured via the loopback_users item in the configuration file. If you wish to allow the guest user to connect from a remote host, you should set the loopback_users configuration to none. A complete RabbitMQ config file which does this would look like: loopback_users = none Or, in the classic config file format (rabbitmq.config): [{rabbit, [{loopback_users, []}]}]. 其实第二种就是在usr/local/rabbitmq/etc/rabbitmq下新建rabbitmq.config文件，添加 [{rabbit, [{loopback_users, []}]}]. 重启rabbitmq在运行程序就可以了]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2踩坑之SpringWebContext方法过时]]></title>
    <url>%2F2018%2F08%2F05%2FSpringWebContext%2F</url>
    <content type="text"><![CDATA[SpringWebContext方法过时今天在做项目的时候，为了优化访问速度，应对高并发，想把页面信息全部获取出来存到redis缓存中，这样每次访问就不用客户端进行渲染了，速度能快不少。 想用thymeleafViewResolver.getTemplateEngine().process(&quot;goodslist.html&quot;,ctx);函数实现，里面有一个ctx参数，这个参数就是WebContext 然后定义这个变量 SpringWebContext ctx = new SpringWebContext（......） 哎，这个方法在SpringBoot1.X的时候还能有，在org.thymeleaf.spring4.context这个package下，在、SpringBoot2.X +thymeleaf3.0.9 中没有，想去找一下用什么来代替，直接去org.thymeleaf.spring4下面去找，没找到相同类型的，然后取找thymeleaf.spring5的API，还找不到，只能找到thymeleaf.spring4的API,。想想还要用，怎么办啊，总不能把版本切换了吧，那有些别的说不定也得改，自己写吧，自力更生艰苦奋斗。 找了之前的一个项目，然后找到了那里面的SpringWebContext是怎么写的，超过来就完了， 但是不行SpringWebContext继承的是org.thymeleaf.context下的WebContext方法，在SpringBoot2.0+thymeleaf3.0.9中定义成final类型的，不能继承，想想要不把库的代码改了，还是算了，再往上找，找到这个WebContext extends AbstractContext implements IWebContext，没有final，所以一层一层的找到之后，按照他的源码改了一下，自己重写了SpringWebContext方法，如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.springboot.SecKill.util;import org.springframework.context.ApplicationContext;import org.thymeleaf.context.AbstractContext;import org.thymeleaf.context.IWebContext;import javax.servlet.ServletContext;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.util.Locale;import java.util.Map;import java.util.HashMap;import java.util.concurrent.ConcurrentHashMap;/** * @author WilsonSong * @date 2018/8/5 */public class SpringWebContextUtil extends AbstractContext implements IWebContext &#123; private final HttpServletRequest request; private final HttpServletResponse response; private final ServletContext servletContext; public static final String BEANS_VARIABLE_NAME = "beans"; private static final ConcurrentHashMap&lt;ApplicationContext, HashMap&lt;String, Object&gt;&gt; variableMapPrototypes = new ConcurrentHashMap(); private final ApplicationContext applicationContext; public SpringWebContextUtil(final HttpServletRequest request, final HttpServletResponse response, final ServletContext servletContext, final Locale locale, final Map&lt;String, Object&gt; variables, final ApplicationContext appctx)&#123; super(locale,addSpringSpecificVariables(variables, appctx)); this.request = request; this.response = response; this.servletContext = servletContext; this.applicationContext = appctx; &#125; private static Map&lt;String, Object&gt; addSpringSpecificVariables(Map&lt;String, ?&gt; variables, ApplicationContext appctx) &#123; HashMap&lt;String, Object&gt; variableMapPrototype = (HashMap)variableMapPrototypes.get(appctx); if (variableMapPrototype == null) &#123; variableMapPrototype = new HashMap(20, 1.0F); ContexBeans beans = new ContexBeans(appctx); variableMapPrototype.put("beans", beans); variableMapPrototypes.put(appctx, variableMapPrototype); &#125; Map newVariables; synchronized(variableMapPrototype) &#123; newVariables = (Map)variableMapPrototype.clone(); &#125; if (variables != null) &#123; newVariables.putAll(variables); &#125; return newVariables; &#125; public ApplicationContext getApplicationContext() &#123; return this.applicationContext; &#125; public HttpServletRequest getRequest() &#123; return this.request; &#125; public HttpSession getSession() &#123; return this.request.getSession(false); &#125; public HttpServletResponse getResponse() &#123; return this.response; &#125; public ServletContext getServletContext() &#123; return this.servletContext; &#125;&#125; 其中的ContexBeans是自己定义的，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.springboot.SecKill.util;/** * @author WilsonSong * @date 2018/8/5 */import java.util.Arrays;import java.util.Collection;import java.util.LinkedHashSet;import java.util.Map;import java.util.Set;import java.util.Map.Entry;import org.springframework.context.ApplicationContext;import org.thymeleaf.util.Validate;public class ContexBeans implements Map&lt;String, Object&gt; &#123; private final ApplicationContext ctx; public ContexBeans(ApplicationContext ctx) &#123; Validate.notNull(ctx, &quot;Application Context cannot be null&quot;); this.ctx = ctx; &#125; public boolean containsKey(Object key) &#123; Validate.notNull(key, &quot;Key cannot be null&quot;); return this.ctx.containsBean(key.toString()); &#125; public Object get(Object key) &#123; Validate.notNull(key, &quot;Key cannot be null&quot;); return this.ctx.getBean(key.toString()); &#125; public Set&lt;String&gt; keySet() &#123; return new LinkedHashSet(Arrays.asList(this.ctx.getBeanDefinitionNames())); &#125; public int size() &#123; return this.ctx.getBeanDefinitionCount(); &#125; public boolean isEmpty() &#123; return this.ctx.getBeanDefinitionCount() &lt;= 0; &#125; public boolean containsValue(Object value) &#123; throw new UnsupportedOperationException(&quot;Method \&quot;containsValue\&quot; not supported in Beans object&quot;); &#125; public Object put(String key, Object value) &#123; throw new UnsupportedOperationException(&quot;Method \&quot;put\&quot; not supported in Beans object&quot;); &#125; public void putAll(Map&lt;? extends String, ?&gt; m) &#123; throw new UnsupportedOperationException(&quot;Method \&quot;putAll\&quot; not supported in Beans object&quot;); &#125; public Object remove(Object key) &#123; throw new UnsupportedOperationException(&quot;Method \&quot;remove\&quot; not supported in Beans object&quot;); &#125; public void clear() &#123; throw new UnsupportedOperationException(&quot;Method \&quot;clear\&quot; not supported in Beans object&quot;); &#125; public Collection&lt;Object&gt; values() &#123; throw new UnsupportedOperationException(&quot;Method \&quot;values\&quot; not supported in Beans object&quot;); &#125; public Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() &#123; throw new UnsupportedOperationException(&quot;Method \&quot;entrySet\&quot; not supported in Beans object&quot;); &#125;&#125; 这样就能用了。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2之秒杀页面优化及解决超卖问题]]></title>
    <url>%2F2018%2F08%2F05%2FSecKillPageOptimise%2F</url>
    <content type="text"><![CDATA[页面缓存+URL缓存+对象缓存页面缓存其实系统访问某个页面的时候，并不是直接使用系统渲染，而是先从缓存中获取找到数据之后就然后返回给客户端，要是没有找到就手动渲染这个模板，渲染完成之后再把数据返回给客户端，同时把数据缓存到redis中。 其实流程很简单：（1）取缓存 （2）手动渲染模板 （3）结果输出 关于手动渲染，官方的介绍是这么说的; If you use Thymeleaf, you also have a ThymeleafViewResolver named ‘thymeleafViewResolver’. It looks for resources by surrounding the view name with a prefix and suffix. The prefix is spring.thymeleaf.prefix, and the suffix is spring.thymeleaf.suffix. The values of the prefix and suffix default to ‘classpath:/templates/’ and ‘.html’, respectively. You can override ThymeleafViewResolver by providing a bean of the same name. 就是 Thymeleaf,的模板引擎的时候需要用ThymeleafViewResolver来实现资源的渲染，用的时候注入就可以了。 1234567891011121314151617181920212223/商品列表页 不返回页面，直接返回HTML的代码 @RequestMapping(value = "/to_list", produces = "text/html") @ResponseBody public String list(HttpServletRequest request, HttpServletResponse response, Model model, SecKillUser user)&#123; model.addAttribute("user",user); //查询商品列表 List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo(); model.addAttribute("goodsList", goodsList); //取缓存 String html = redisService.get(GoodsKey.getGoodsList,"",String.class); if (!StringUtils.isEmpty(html))&#123; return html; &#125; //缓存中没有数据的时候手动渲染 SpringWebContextUtil ctx = new SpringWebContextUtil(request, response, request.getServletContext(),request.getLocale(),model.asMap(),applicationContext); html = thymeleafViewResolver.getTemplateEngine().process("goodslist.html",ctx); if(!StringUtils.isEmpty(html))&#123; redisService.set(GoodsKey.getGoodsList,"",html); &#125; return html; &#125; 这里还踩到一个小坑，取页面信息的SpringWebContext在org.thymeleaf.spring5.context这个包下面已经没有了，被删除了;在org.thymeleaf.spring4.context下面是有的，自己重写了SpringWebContext这个类。为什么非要要重写，我单独写篇博客写一下，更清晰一些。 URL缓存其实说是URL缓存，真的是有点不太准确哈，其实和页面缓存是一样的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@RequestMapping(value = "/to_detail/&#123;goodsId&#125;", produces = "text/html") @ResponseBody public String detail(HttpServletRequest request, HttpServletResponse response,Model model, SecKillUser user, @PathVariable("goodsId") long goodsId)&#123; model.addAttribute("user",user); //取缓存 String html = redisService.get(GoodsKey.getGoodsDetail,""+goodsId,String.class); if (!StringUtils.isEmpty(html))&#123; return html; &#125; //手动渲染 GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId); model.addAttribute("goods",goods); //秒杀的详细信息 long startAt = goods.getStartDate().getTime(); long endAt = goods.getEndDate().getTime(); long now = System.currentTimeMillis(); //当前的时间 int SecKillStatus = 0; int remainSeconds = 0; if (now &lt; startAt)&#123; //秒杀未开始 SecKillStatus = 0; remainSeconds = (int)((startAt - now)/1000); &#125;else if (now &gt; endAt)&#123; //秒杀结束 SecKillStatus = 2; remainSeconds = -1; &#125;else &#123; SecKillStatus = 1; remainSeconds = 0; &#125; model.addAttribute("miaoshaStatus",SecKillStatus); model.addAttribute("remainSeconds",remainSeconds); //缓存中没有数据的时候手动渲染 SpringWebContextUtil ctx = new SpringWebContextUtil(request, response, request.getServletContext(), request.getLocale(),model.asMap(),applicationContext); html = thymeleafViewResolver.getTemplateEngine().process("goods_detail.html",ctx); if(!StringUtils.isEmpty(html))&#123; redisService.set(GoodsKey.getGoodsDetail,""+goodsId ,html); &#125; return html;&#125; 对象缓存对象缓存其实就是把缓存数据和对象放在缓存中，这样每次访问的时候从缓存中读取就可以了，就相应的减少了读取数据库的次数，从而提高了网站访问的速度 。 上面的页面缓存是设置有有效期的，因为页面信息可能随时会变，一直在缓存中中就页面的信息每次读出来就不一样了，但是对象就不一样了，这个不设置有效期，或者把有效期设置的很长。 这里做个简单的例子，把做秒杀商品的用户对象放在内存中 1234567891011121314public SecKillUser getUserById(long id)&#123; //取缓存 SecKillUser user = redisService.get(SecKillUserKey.getById,""+id, SecKillUser.class); if (user !=null)&#123; return user; &#125; //缓存中没有从数据库中取出来放入缓存中 user = secKillUserDao.getUserById(id); if (user != null)&#123; redisService.set(SecKillUserKey.getById,""+id, user); &#125; return user; &#125; 因为设置缓存中的对象数据永不过期，那有人更新了自己的密码或者用户名或者其他的信息怎么办，缓存也要随着更新,要不然就缓存数据不一致了。 1234567891011121314151617public boolean updatePassword(String token,long id, String formPasswordNew)&#123; SecKillUser user = getUserById(id); if (user == null)&#123; throw new GlobalException(CodeMsg.MOBILE_NOT_EXITS); &#125; SecKillUser user2Update = new SecKillUser(); user2Update.setId(id); user2Update.setPassword(MD5Util.fromPass2DBPass(formPasswordNew,user.getSalt())); secKillUserDao.update(user2Update); //修改缓存 redisService.delete(SecKillUserKey.getById,""+id); //更新缓存中的token user.setPassword(user2Update.getPassword()); redisService.set(SecKillUserKey.token,token, user); return true; &#125; 做了部分优化，测试一下，测试的Linux服务器为1g+4核。 没有优化之前 优化之后 可以看到并发已经上去了，QPS从1267上升到2218了。 页面静态优化 前后端分离先想一下我们在平常的开发中前后端交互的流程：其实服务端为动态页面作用很单一就是提供了网站需要展示的数据而已，服务端是不会创造一个新页面的。服务端提供的数据的类型也是很统一，要不就是服务端语言提供的基本数据类型例如：字符、数字、日期等等，要不就是复杂点的数据类型例如数组、列表、键值对等等，不过归属服务端的动态页面还需要服务端语言帮助做一件事情，那就是把服务端提供的数据整合到页面里，最终产生一个浏览器可以解析的html网页，这个操作无非就是使用服务端语言可以构造文件的能力构建一个符合要求的html文件而已。不过一个页面里需要动态变化的往往只是其中一部分，所以做服务端的动态页面开发时候我们可以直接写html代码，这些html代码就等于在构造页面展示的模板而已，而模板的空白处则是使用服务端数据填充，因此在java的web开发里视图层技术延生出了Thymeleaf，freemark这样的技术，我们将其称之为模板语言的由来。 由此可见，服务端MVC框架里抢夺的web前端的工作就是抢占了构建html模板的工作，那么我们在设计web前端的MVC框架时候对于和服务端对接这块只需要让服务端保持提供数据的特性即可。从这些论述里我们发现了，其实前端MVC框架要解决的核心问题应该有这两个,它们分别是： 核心问题一：让模板技术交由浏览器来做，让服务端只提供单纯的数据服务。 核心问题二：模板技术交由浏览器来承担，那么页面的动态性体现也就是根据不同的服务端数据进行页面部分刷新来完成的。 而这两个核心问题解决办法那就是使用ajax技术，ajax技术天生就符合解决这些问题的技术手段了。 简答来讲就是其实就是将页面缓存到客户的浏览器上，当用户访问页面的时候，仅从与服务器取数据，从本地缓存中取页面，节省网络流量。 12345678910111213141516171819202122232425262728293031//商品详情页 @RequestMapping(value="/detail/&#123;goodsId&#125;") @ResponseBody public Result&lt;GoodsDetailVo&gt; detail(HttpServletRequest request, HttpServletResponse response, Model model, SecKillUser user, @PathVariable("goodsId") long goodsId)&#123; GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId); //秒杀的详细信息 long startAt = goods.getStartDate().getTime(); long endAt = goods.getEndDate().getTime(); long now = System.currentTimeMillis(); //当前的时间 int secKillStatus = 0; int remainSeconds = 0; if (now &lt; startAt)&#123; //秒杀未开始 secKillStatus = 0; remainSeconds = (int)((startAt - now)/1000); &#125;else if (now &gt; endAt)&#123; //秒杀结束 secKillStatus = 2; remainSeconds = -1; &#125;else &#123; secKillStatus = 1; remainSeconds = 0; &#125; GoodsDetailVo vo = new GoodsDetailVo(); vo.setRemainSeconds(remainSeconds); vo.setSecKillStatus(secKillStatus); vo.setGoods(goods); vo.setUser(user); return Result.success(vo); &#125; 之前我们是把数据通过model.addAttributes()传递给页面的，然后返回的是HTML页面，这里直接就是@ResponseBody，返回的是页面上需要的一些数据，不需要整合把数据整合到页面中。 对应的前端HTML的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&lt;!DOCTYPE HTML&gt;&lt;html &gt;&lt;head&gt; &lt;title&gt;商品详情&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;!-- jquery --&gt; &lt;script type="text/javascript" src="./js/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- bootstrap --&gt; &lt;link rel="stylesheet" type="text/css" href="./bootstrap/css/bootstrap.min.css" /&gt; &lt;script type="text/javascript" src="./bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;!-- jquery-validator --&gt; &lt;script type="text/javascript" src="./jquery-validation/jquery.validate.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./jquery-validation/localization/messages_zh.min.js"&gt;&lt;/script&gt; &lt;!-- layer --&gt; &lt;script type="text/javascript" src="./layer/layer.js"&gt;&lt;/script&gt; &lt;!-- md5.js --&gt; &lt;script type="text/javascript" src="./js/md5.min.js"&gt;&lt;/script&gt; &lt;!-- common.js --&gt; &lt;script type="text/javascript" src="./js/common.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt;秒杀商品详情&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;span id="userTip"&gt; 您还没有登录，请登陆后再操作&lt;br/&gt;&lt;/span&gt; &lt;span&gt;没有收货地址的提示。。。&lt;/span&gt; &lt;/div&gt; &lt;table class="table" id="goodslist"&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td colspan="3" id="goodsName"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td colspan="3"&gt;&lt;img id="goodsImg" width="200" height="200" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;秒杀开始时间&lt;/td&gt; &lt;td id="startTime"&gt;&lt;/td&gt; &lt;td &gt; &lt;input type="hidden" id="remainSeconds" /&gt; &lt;span id="miaoshaTip"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;button class="btn btn-primary btn-block" type="button" id="buyButton"onclick="doMiaosha()"&gt;立即秒杀&lt;/button&gt; &lt;input type="hidden" name="goodsId" id="goodsId" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品原价&lt;/td&gt; &lt;td colspan="3" id="goodsPrice"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;秒杀价&lt;/td&gt; &lt;td colspan="3" id="miaoshaPrice"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;库存数量&lt;/td&gt; &lt;td colspan="3" id="stockCount"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;function doMiaosha()&#123; $.ajax(&#123; url:"/miaosha/do_miaosha", type:"POST", data:&#123; goodsId:$("#goodsId").val(), &#125;, success:function(data)&#123; if(data.code == 0)&#123; window.location.href="/order_detail.htm?orderId="+data.data.id; &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125;function render(detail)&#123; var miaoshaStatus = detail.secKillStatus; var remainSeconds = detail.remainSeconds; var goods = detail.goods; var user = detail.user; if(user)&#123; $("#userTip").hide(); &#125; $("#goodsName").text(goods.goodsName); $("#goodsImg").attr("src", goods.goodsImg); $("#startTime").text(new Date(goods.startDate).format("yyyy-MM-dd hh:mm:ss")); $("#remainSeconds").val(remainSeconds); $("#goodsId").val(goods.id); $("#goodsPrice").text(goods.goodsPrice); $("#miaoshaPrice").text(goods.miaoshaPrice); $("#stockCount").text(goods.stockCount); countDown();&#125;$(function()&#123; //countDown(); getDetail();&#125;);function getDetail()&#123; var goodsId = g_getQueryString("goodsId"); $.ajax(&#123; url:"/goods/detail/"+goodsId, type:"GET", success:function(data)&#123; if(data.code == 0)&#123; render(data.data); &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125;function countDown()&#123; var remainSeconds = $("#remainSeconds").val(); var timeout; if(remainSeconds &gt; 0)&#123;//秒杀还没开始，倒计时 $("#buyButton").attr("disabled", true); $("#miaoshaTip").html("秒杀倒计时："+remainSeconds+"秒"); timeout = setTimeout(function()&#123; $("#countDown").text(remainSeconds - 1); $("#remainSeconds").val(remainSeconds - 1); countDown(); &#125;,1000); &#125;else if(remainSeconds == 0)&#123;//秒杀进行中 $("#buyButton").attr("disabled", false); if(timeout)&#123; clearTimeout(timeout); &#125; $("#miaoshaTip").html("秒杀进行中"); &#125;else&#123;//秒杀已经结束 $("#buyButton").attr("disabled", true); $("#miaoshaTip").html("秒杀已经结束"); &#125;&#125;&lt;/script&gt;&lt;/html&gt; 可以看到这里把html中的原来的依赖于Thymeleaf的部分全部重写，直接从浏览器的缓存中取数据，填充页面。其实还需要做一个配置，就是把application.properties中添加上spring对于静态资源的配置，就是SPRING RESOURCES HANDLING的配置 12345678#staticspring.resources.add-mappings=truespring.resources.chain.cache=truespring.resources.cache.period=3600spring.resources.chain.enabled=truespring.resources.chain.gzipped=truespring.resources.chain.html-application-cache=truespring.resources.static-locations=classpath:/static/ 这样就完成了前后端的分离。 静态资源优化代码压缩 最常规的优化手段之一。 我们在平时开发的时候，JS脚本文件和CSS样式文件中的代码，都会依据一定的代码规范（比如javascript-standard-style）来提高项目的可维护性，以及团队之间合作的效率。 但是在项目发布现网后， 这些代码是给客户端（浏览器）识别的，此时代码的命名规范、空格缩进都已没有必要，我们可以使用工具将这些代码进行混淆和压缩，减少静态文件的大小 文件合并 在npm流行的今天，前端在进行项目开发的时候，往往会使用很多第三方代码库，比如jQuery，axios，weixin-js-sdk，lodash，bootstrap等等，每个库都有属于自己的脚本或者样式文件。 按照最老的方式的话，我们会用一些标签分别引入这些库文件，导致在打开一个页面的时候会发起几十个请求，这对于移动端来说是不可接受的。在减少文件请求数量方面大致有以下三方面：1、合并js脚本文件2、合并css样式文件3、合并css引用的图片，使用sprite雪碧图。 GZip 开启GZip，精简JavaScript，移除重复脚本，图像优化 CDN优化 简介：CDN（内容发布网络）,是一个加速用户获取数据的系统；既可以是静态资源，又可以是动态资源，这取决于我们的决策策略。经常大部分视频加速都依赖于CDN，比如优酷，爱奇艺等，据此加速； 原理：CDN部署在距离用户最近的网络节点上，用户上网的时候通过网络运营商（电信，长城等）访问距离用户最近的要给城域网网络地址节点上，然后通过城域网跳到主干网上，主干网则根据访问IP找到访问资源所在服务器，但是，很大一部分内容在上一层节点已经找到，此时不用往下继续查找，直接返回所访问的资源即可，减小了服务器的负担。一般互联网公司都会建立自己的CDN机群或者租用CDN。 这些就了解下原理，毕竟大部分是前端的。 关于这个还找到了一篇博客啊，仅供参考。 https://blog.csdn.net/zhangjs712/article/details/51166748 超卖问题超发的原因假设某个抢购场景中，我们一共只有100个商品，在最后一刻，我们已经消耗了99个商品，仅剩最后一个。这个时候，系统发来多个并发请求，这批请求读取到的商品余量都是99个，然后都通过了这一个余量判断，最终导致超发。（同文章前面说的场景） 在上面的这个图中，就导致了并发用户B也“抢购成功”，多让一个人获得了商品。这种场景，在高并发的情况下非常容易出现。 1.数据库唯一索引 就是分表，秒杀的订单和正常的订单是两张表，在数据库中建立用户id和商品id的唯一索引，防止用户插入重复的记录。 2. 悲观锁思路 解决线程安全的思路很多，可以从“悲观锁”的方向开始讨论。 悲观锁，也就是在修改数据的时候，采用锁定状态，排斥外部请求的修改。遇到加锁的状态，就必须等待。 虽然上述的方案的确解决了线程安全的问题，但是，别忘记，我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常。 3. FIFO队列思路 那好，那么我们稍微修改一下上面的场景，我们直接将请求放入队列中的，采用FIFO（First Input First Output，先进先出），这样的话，我们就不会导致某些请求永远获取不到锁。看到这里，是不是有点强行将多线程变成单线程的感觉哈。 然后，我们现在解决了锁的问题，全部请求采用“先进先出”的队列方式来处理。那么新的问题来了，高并发的场景下，因为请求很多，很可能一瞬间将队列内存“撑爆”，然后系统又陷入到了异常状态。或者设计一个极大的内存队列，也是一种方案，但是，系统处理完一个队列内请求的速度根本无法和疯狂涌入队列中的数目相比。也就是说，队列内的请求会越积累越多，最终Web系统平均响应时候还是会大幅下降，系统还是陷入异常。 4. 乐观锁思路 这个时候，我们就可以讨论一下“乐观锁”的思路了。乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。这样的话，我们就不需要考虑队列的问题，不过，它会增大CPU的计算开销。但是，综合来说，这是一个比较好的解决方案。 有很多软件和服务都“乐观锁”功能的支持，例如Redis中的watch就是其中之一。通过这个实现，我们保证了数据的安全。 就是采用计数器的方式，用一个集合，存放每个商品以及其对应的数量，如果只是单纯的decr函数或者是incr函数，不能解决秒杀这种问题。因为有可能在并发的情况下，两个请求取到的数都是0，然后都加1，结果为1，实际上应该是2。那么这个时候建议利用乐观锁，实现自己的decr函数。 乐观锁的机制如同版本控制，如果修改的时候，要修改的value在redis中的值已经跟取出来时不一样，则修改失败。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>秒杀， 页面优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习之Windows和Linux下的JMeter压测和redis压测]]></title>
    <url>%2F2018%2F08%2F04%2FJMeter%2F</url>
    <content type="text"><![CDATA[SpringBoot学习之JMeter压测JMeter入门jmeter是apache公司基于java开发的一款开源压力测试工具，体积小，功能全，使用方便，是一个比较轻量级的测试工具，使用起来非常简单。因为jmeter是java开发的，所以运行的时候必须先要安装jdk才可以。jmeter是免安装的，拿到安装包之后直接解压就可以使用，同时它在linux/windows/macos上都可以使用。 jmeter可以做接口测试和压力测试。其中接口测试的简单操作包括做http脚本（发get/post请求、加cookie、加header、加权限认证、上传文件）、做webservice脚本、参数化、断言、关联（正则表达式提取器和处理json-json path extractor）和jmeter操作数据库等等。JMeter的官方网站：http://jmeter.apache.org/JMeter的参考手册：http://jmeter.apache.org/usermanual/get-started.html具体的使用参考官网就可以了。## Windows下的压测### Jmeter-http接口脚本一般分五个步骤:（1）添加线程组 （2）添加http请求 （3）在http请求中写入接入url、路径、请求方式和参数 （4）添加聚合报告 （5）调用接口、查看返回值（1）添加线程组：（2）添加http请求：（3）在http请求中写入接入url、路径、请求方式和参数 ：（4）添加聚合报告和图形结果或查看结果树：聚合报告只是总体的进行解析压测结果。（5）调用接口、查看返回值：同时启动1000个线程:### JMeter 自定义变量新建http请求，添加token:压测之后能够看到自己添加的token，还能看到返回的数据## JMeter读取自定义文件模拟多用户需要在线程组里面添加配置元件-CSV Data Set Config，添加文件和自定义文件中对应的变量名其中遇到文件结束符再次循环（Recycle on EOF）:设置True后，允许循环取值引入${userToken}，与你定义的变量名相同。## Linux下使用JMeter压测首先在Windows下创建一个压测，然后存为.jmx文件。上传至Linux下执行1./apache-jmeter-4.0/bin/jmeter.sh -n -t goods_list.jmx -l result.jtl 这样就可以得到 result.jtl数据了，可以查看结果 当然也可以直接在Linux下直接测试，我这是为了方便就这么做了。 redis 压测看一下redis服务是否在运行 12ps -ef | grep redis 执行： 1redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000 -c 100 就是100个并发 -n 100000 就是100000个请求。 看一下其中的一个结果 100000个请求在2.38s内完成，有4.12%的请求在1ms内完成，一秒大概完成41963.91个请求。以3字节大小测试。 再看这条命令： 1redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100 -q 就是quiet，输出少一些，-d 100是存取数据包为100字节大小的数据包，上面默认是3 字节存取的。看一下输出 只测试某些命令的性能 1redis-benchmark -t set,lpush -q -n 10000 -t set,lpush 是只测试set和lpush命令。 只测试某些数据存取的性能： 1redis-benchmark -q -n 10000 script load &quot;redis.call(&apos;set&apos;,&apos;foo&apos;,&apos;bar&apos;)&quot; 只对’set’,’foo’,’bar’该命令做压测。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot使用JSR303参数校验并进行全局异常处理]]></title>
    <url>%2F2018%2F08%2F02%2FJSR303%2F</url>
    <content type="text"><![CDATA[SpringBoot使用JSR303参数校验开发web项目有时候我们需要对controller层传过来的参数进行一些基本的校验，比如非空，非null，整数值的范围，字符串的个数，日期，邮箱等等。最常见的就是我们直接写代码校验，这样以后比较繁琐，而且不够灵活。 不能总是写繁琐的代码来实现吧。 使用JSR303来做参数校验就方便并且整洁很多了。 pop引入依赖12345&lt;!--JSR303校验的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; Controller中使用12345@RequestMapping("/login")//@Valid是JSR303校验public Result&lt;Boolean&gt; login(@Valid LoginVo loginVo)&#123; &#125; 校验实体123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.springboot.SecKill.vo;import com.springboot.SecKill.validator.IsMobile;import org.hibernate.validator.constraints.Length;import javax.validation.constraints.NotNull;/** * @author WilsonSong * @date 2018/8/2/002 */public class LoginVo &#123; @NotNull @IsMobile private String mobile; @NotNull @Length(min=32) private String password; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "LoginVo&#123;" + "mobile='" + mobile + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 自定义校验JSR303中给我们定义了一些常用的校验注解，如本文最后常用常用注解中所示，但是要是还不能满足学习怎么去自己定义注解呢？ 参照@NotNull这个校验注解的定义方法，@NotNull是这么定义的 12345678910111213141516171819202122232425262728293031323334353637//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package javax.validation.constraints;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import javax.validation.Constraint;import javax.validation.Payload;@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)@Retention(RetentionPolicy.RUNTIME)@Repeatable(NotNull.List.class)@Documented@Constraint( validatedBy = &#123;&#125;)public @interface NotNull &#123; String message() default "&#123;javax.validation.constraints.NotNull.message&#125;"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; @Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface List &#123; NotNull[] value(); &#125;&#125; 参照上面，我们实现自己的注解 12345678910111213141516171819202122232425262728package com.springboot.SecKill.validator;import javax.validation.Constraint;import javax.validation.Payload;import java.lang.annotation.*;/** * @author WilsonSong * @date 2018/8/2/002 */@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint( validatedBy = &#123;IsMobileValidator.class&#125;)public @interface IsMobile &#123; boolean required() default true; //校验不通过，提示默认的错误信息 String message() default "手机号码格式错误"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 实现具体校验器上面只是实现了自己定义的校验器的接口，具体的实现类如下： 123456789101112131415161718192021222324252627282930313233343536package com.springboot.SecKill.validator;import com.springboot.SecKill.util.ValidatorUtil;import org.springframework.util.StringUtils;import javax.validation.ConstraintValidator;import javax.validation.ConstraintValidatorContext;/** * JSR303具体的校验器 * @author WilsonSong * @date 2018/8/2/002 */public class IsMobileValidator implements ConstraintValidator&lt;IsMobile, String&gt; &#123; public boolean required = false; //初始化 @Override public void initialize(IsMobile constraintAnnotation) &#123; required = constraintAnnotation.required(); &#125; //校验 @Override public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) &#123; if(required)&#123; //值是必须的就判断是否合法 return ValidatorUtil.isMobile(s); //不为空就判断格式 &#125;else &#123; //若不必须就判断是否有值 if (StringUtils.isEmpty(s))&#123; return true; &#125;else &#123; return ValidatorUtil.isMobile(s); //不为空就判断格式 &#125; &#125; &#125;&#125; 异常处理参数校验不通过就会产生错误信息，显示一大串例如 1&#123;"timestamp":"2018-08-02T13:07:50.890+0000","status":400,"error":"Bad Request","errors":[&#123;"codes":["IsMobile.loginVo.mobile","IsMobile.mobile","IsMobile.java.lang.String","IsMobile"],"arguments":[&#123;"codes":["loginVo.mobile","mobile"],"arguments":null,"defaultMessage":"mobile","code":"mobile"&#125;,true],"defaultMessage":"手机号码格式错误","objectName":"loginVo","field":"mobile","rejectedValue":"22111111111","bindingFailure":false,"code":"IsMobile"&#125;],"message":"Validation failed for object='loginVo'. Error count: 1","path":"/login/do_login"&#125; 为了方便查看，统一进行异常处理 1234567891011121314151617181920212223242526272829303132333435363738package com.springboot.SecKill.exception;import com.springboot.SecKill.result.CodeMsg;import com.springboot.SecKill.result.Result;import org.springframework.validation.ObjectError;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import org.springframework.validation.BindException;import java.util.List;/** * @author WilsonSong * @date 2018/8/2/002 */@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123; @ExceptionHandler(value = Exception.class) //拦截所有的异常 public Result&lt;String&gt; exceptionHandler(HttpServletRequest httpServletRequest, Exception e)&#123; // 参数校验异常 if(e instanceof BindException)&#123; BindException ex = (BindException)e; List&lt;ObjectError&gt; errors = ex.getAllErrors(); ObjectError error= errors.get(0); String msg = error.getDefaultMessage(); return Result.error(CodeMsg.BIND_ERROR.fillArgs(msg)); &#125;else &#123; //其他异常 return Result.error(CodeMsg.SERVER_ERROR); &#125; &#125;&#125; 全局的异常处理上面的知识参数检验时候的异常处理，但是在工程中很多的异常，用全局的异常处理更加方便维护。 首先定义一个全局的异常 1234567891011121314151617181920212223242526272829303132package com.springboot.SecKill.exception;import com.springboot.SecKill.result.CodeMsg;/** * @author WilsonSong * @date 2018/8/2/002 */public class GlobalException extends RuntimeException &#123; private static final long serialVersionUID = 1L; private CodeMsg cm; public GlobalException (CodeMsg cm)&#123; super(cm.toString()); this.cm = cm; &#125; public static long getSerialVersionUID() &#123; return serialVersionUID; &#125; public CodeMsg getCm() &#123; return cm; &#125; public void setCm(CodeMsg cm) &#123; this.cm = cm; &#125;&#125; 然后在全局异常处理器中添加这个全局的异常，也就是在GlobalExceptionHandler类中添加 1234if(e instanceof GlobalException)&#123; GlobalException ex = (GlobalException) e; return Result.error(ex.getCm()); &#125; 然后在产生异常的地方直接抛出全局异常就可以了 123if (loginVo == null)&#123; throw new GlobalException(CodeMsg.SERVER_ERROR); &#125; CodeMsg.SERVER_ERROR是自己定义的异常信息。 常用注解1234567891011121314151617@Null 被注释的元素必须为null@NotNull 被注释的元素不能为null@AssertTrue 被注释的元素必须为true@AssertFalse 被注释的元素必须为false@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Size(max,min) 被注释的元素的大小必须在指定的范围内。@Digits(integer,fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内@Past 被注释的元素必须是一个过去的日期@Future 被注释的元素必须是一个将来的日期@Pattern(value) 被注释的元素必须符合指定的正则表达式。@Email 被注释的元素必须是电子邮件地址@Length 被注释的字符串的大小必须在指定的范围内@NotEmpty 被注释的字符串必须非空@Range 被注释的元素必须在合适的范围内]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JSR303</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2.0集成Redis详解及踩过的坑（Could not get a resource from the pool）]]></title>
    <url>%2F2018%2F08%2F02%2FRedis%2F</url>
    <content type="text"><![CDATA[SpringBoot2.0集成Redis首先安装的过程就不提了。上一个项目的redis是配置在Windows下的，集成很简单，也没有做什么配置。这次为了进行测试，装在了linux下。在SpringBoot集成的过程中遇到了一些小坑，分享一下。 pom文件中添加依赖12345678910111213&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入Json依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt; 可以看到除了Redis我还加入了JSON的依赖，这是因为我之后读取出来的数据要转换成JSON串的格式，数据可读，方便开发。 application.properties文件中添加配置12345678910111213#redis配置#Linux主机地址spring.redis.host=192.168.78.131#端口spring.redis.port=6379#超时时间，msspring.redis.timeout=3000#连接池的最大连接数spring.redis.jedis.pool.max-active=10#链接的最大等待时间msspring.redis.jedis.pool.max-wait=3000#连接池中的最大的等待数量spring.redis.jedis.pool.max-idle=10 在SpringBoot2.0的版本中timeout变成了Duration类型的，从其源码中我们可以看一下是怎么定义的: 123public void setTimeout(Duration timeout) &#123; this.timeout = timeout; &#125; 所以正常的写法应该是： 1spring.redis.timeout=3000ms 但是这样也带来了一个问题，下面再说这个问题是什么，这里先按照初始的定义，不会报错的 正常的人可能还会在配置文件中添加redis的密码的配置，没有密码的话就不要添加这个配置，就算默认为空也会导致出现错误，不能实现OAuth认证，要是有密码的话就添加上并写上自己的密码。 1spring.redis.password= Redis的自定义初始化首先写redisConfig的文件，读取application.properties文件中yml的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.springboot.SecKill.redis;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import org.springframework.stereotype.Component;/** * Redis的配置 * @author WilsonSong * @date 2018/8/1/001 *///作为组件扫描进来@Component//读取配置文件@Configuration@ConfigurationProperties(prefix = "spring.redis")public class RedisConfig &#123; private String host; //主机 private int port; //端口 private int timeout; //超时时间 @Value("$&#123;spring.redis.jedis.pool.max-active&#125;") private int maxActive; //连接池最大线程数 @Value("$&#123;spring.redis.jedis.pool.max-wait&#125;") private long maxWait; //等待时间 @Value("$&#123;spring.redis.jedis.pool.max-idle&#125;") private int maxIdle;//最大空闲连接 public String getHost() &#123; return host; &#125; public void setHost(String host) &#123; this.host = host; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125; public int getTimeout() &#123; return timeout; &#125; public void setTimeout(int timeout) &#123; this.timeout = timeout; &#125; public int getMaxActive() &#123; return maxActive; &#125; public void setMaxActive(int maxActive) &#123; this.maxActive = maxActive; &#125; public long getMaxWait() &#123; return maxWait; &#125; public void setMaxWait(long maxWait) &#123; this.maxWait = maxWait; &#125; public int getMaxIdle() &#123; return maxIdle; &#125; public void setMaxIdle(int maxIdle) &#123; this.maxIdle = maxIdle; &#125;&#125; 上面用了两种方式来读取application.properties中的配置，一种是直接设置@ConfigurationProperties(prefix = “spring.redis”)，然后变量名与application.properties中的变量名一样，这样就可以读出来了，然后像max-wait这种变量名没法定义啊，所以又用了@Value(“${spring.redis.jedis.pool.max-idle}”)这种注解的方式来读取，当然你可以全部影注解的方式来读取，注意过程中的每一个变量的基本数据类型定义准确。maxWait和timeout这两个本来都是Duration类型的，但是这里分别写成long和int类型的。一会儿再解释这个问题。 过程中需要从redis连接池中获取redis服务，所以这里初始化jedisPool的配置 123456789101112131415161718192021222324252627282930313233package com.springboot.SecKill.redis;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.stereotype.Service;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * @author WilsonSong * @date 2018/8/1/001 */@Servicepublic class RedisPoolFactory &#123; @Autowired RedisConfig redisConfig; /** * redis连接池的一些配置 * @return */ @Bean public JedisPool JedisPoolFactory()&#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxIdle(redisConfig.getMaxIdle()); poolConfig.setMaxTotal(redisConfig.getMaxActive()); poolConfig.setMaxWaitMillis((redisConfig.getMaxWait())); JedisPool jedisPool = new JedisPool(poolConfig, redisConfig.getHost(),redisConfig.getPort(),redisConfig.getTimeout()); return jedisPool; &#125;&#125; 这里解释下maxWait和timeout这两个数据类型的问题。首先 1poolConfig.setMaxWaitMillis((redisConfig.getMaxWait())); 用到了maxWait这个变量，看一下setMaxWaitMillis（）函数的源码 123public void setMaxWaitMillis(long maxWaitMillis) &#123; this.maxWaitMillis = maxWaitMillis; &#125; maxWaitMillis这个变量是long类型的，所以执勤才那么定义。 同理 1JedisPool jedisPool = new JedisPool(poolConfig, redisConfig.getHost(),redisConfig.getPort(),redisConfig.getTimeout()); 这里面有用到redisConfig.getTimeout()，看一下JedisPool是怎么初始化的 123public JedisPool(GenericObjectPoolConfig poolConfig, String host, int port, int timeout) &#123; this(poolConfig, host, port, timeout, (String)null, 0, (String)null); &#125; 可以看到timeout是int类型的，你要一开始定义成Duration类型的，然后可能过程中会涉及到数据类型的强制准换，会不会报错不知道，有兴趣的可以试一下。 最后就是初始化redis的方法如get,set等等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163package com.springboot.SecKill.redis;import com.alibaba.fastjson.JSON;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;/** * @author WilsonSong * @date 2018/8/1 */@Servicepublic class RedisService &#123; private static final Logger logger = LoggerFactory.getLogger(RedisService.class); @Autowired JedisPool jedisPool; public &lt;T&gt; T get(KeyPrefix prefix, String key, Class&lt;T&gt; clazz)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); //生成real key String realKey = prefix.getPrefix() + key; String str = jedis.get(realKey); T t = String2Bean(str, clazz); return t; &#125;catch (Exception e)&#123; logger.error("redis连接池异常"+e.getMessage()); return null; &#125;finally &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125; &#125; public &lt;T&gt; boolean set(KeyPrefix prefix,String key, T value)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); String value_new = Bean2String(value); if (value_new == null || value_new.length() &lt;0)&#123; return false; &#125; //生成real key String realKey = prefix.getPrefix() + key; //过期时间 int seconds = prefix.expireSeconds(); if (seconds &lt;= 0)&#123; jedis.set(realKey, value_new); &#125;else &#123; jedis.setex(realKey,seconds,value_new); &#125; return true; &#125;catch (Exception e)&#123; logger.error("redis连接池异常"+e.getMessage()); return false; &#125;finally &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125; &#125; //key 是否存在 public &lt;T&gt; Boolean exists(KeyPrefix prefix, String key)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); //生成real key String realKey = prefix.getPrefix() + key; return jedis.exists(realKey); &#125;catch (Exception e)&#123; logger.error("redis连接池异常"+e.getMessage()); return null; &#125;finally &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125; &#125; //增加key对应的值 public &lt;T&gt; Long incr(KeyPrefix prefix, String key)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); //生成real key String realKey = prefix.getPrefix() + key; return jedis.incr(realKey); &#125;catch (Exception e)&#123; logger.error("redis连接池异常"+e.getMessage()); return null; &#125;finally &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125; &#125; //减少key对应的对象的值 public &lt;T&gt; Long decr(KeyPrefix prefix, String key)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); //生成real key String realKey = prefix.getPrefix() + key; return jedis.decr(realKey); &#125;catch (Exception e)&#123; logger.error("redis连接池异常"+e.getMessage()); return null; &#125;finally &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125; &#125; //bean对象准换为String private &lt;T&gt; String Bean2String(T value) &#123; if (value == null)&#123; return null; &#125; Class&lt;?&gt; clazz = value.getClass(); if (clazz == int.class || clazz == Integer.class)&#123; return ""+value; &#125;else if (clazz == String.class)&#123; return (String)value; &#125;else if (clazz == long.class || clazz == Long.class)&#123; return ""+value; &#125;else &#123; return JSON.toJSONString(value); &#125; &#125; //String转换为bean private &lt;T&gt; T String2Bean(String str, Class&lt;T&gt; clazz) &#123; if (str == null || str.length() &lt;0 || clazz == null)&#123; return null; &#125; if (clazz == int.class || clazz == Integer.class)&#123; return (T)Integer.valueOf(str); &#125;else if (clazz == String.class)&#123; return (T)str; &#125;else if (clazz == long.class || clazz == Long.class)&#123; return (T)Long.valueOf(str); &#125;else &#123; return JSON.toJavaObject(JSON.parseObject(str),clazz); &#125; &#125;&#125; 最后在controller中编写一个方法实现对service层的调用即可，就不赘述了。 踩过的坑运行程序发现报出异常 Could not get a resource from the pool。 其实也就是在执行 jedis = jedisPool.getResource();这一步时出错了 首先第一种可能是你的redis服务没开启，检查下。 确认开启了之后就修改你的redis.conf文件，把bind 127.0.0.1改成bind 0.0.0.0， ​ 也就是把redis的访问权限有只能本机访问改成所有的都能访问。 最后可能的原因有你的Linux的防火墙没有开放Redis的端口，可以配置打开，也可以直接关掉防火墙，我这里直接关掉了Linux的防火墙。 我用的是centos7 永久关闭防火墙的方法 1234//临时关闭systemctl stop firewalld//禁止开机启动systemctl disable firewalld 这样你再测试下，要是还不能用还有别的原因，可以自己上网去看一下具体怎么解决。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之逻辑回归（Logistic Regression）与决策边界]]></title>
    <url>%2F2018%2F07%2F30%2FLogisticRegression%2F</url>
    <content type="text"><![CDATA[逻辑回归与决策边界what？逻辑回归其实是一个分类算法而不是回归算法。通常是利用已知的自变量来预测一个离散型因变量的值（像二进制值0/1，是/否，真/假）。简单来说，它就是通过拟合一个逻辑函数（logit fuction）来预测一个事件发生的概率。所以它预测的是一个概率值，自然，它的输出值应该在0到1之间。 Logistic回归简单分析: 优点：计算代价不高，易于理解和实现 缺点：容易欠拟合，分类精度可能不高 适用数据类型：数值型和标称型数据 基本原理按照我自己的理解，可以简单的描述为这样的过程： 找一个合适的预测函数，一般表示为h函数，该函数就是我们需要找的分类函数，它用来预测输入数据的判断结果。这个过程时非常关键的，需要对数据有一定的了解或分析，知道或者猜测预测函数的“大概”形式，比如是线性函数还是非线性函数。借助sigmoid函数构造出的预测函数形式一般为：$$h_{\theta }(x) = g(\theta ^{_{T}}x) = \frac{1}{1+e^{-\theta ^{T}x}}$$其中sigmoid函数为: 构造一个Cost函数（损失函数），该函数表示预测的输出（h）与训练数据类别（y）之间的偏差，可以是二者之间的差（h-y）或者是其他的形式。cost函数为：$$Cost(h_{\theta }x,y) = \begin{cases} -log(h_{\theta }(x))&amp; \text{ if } y=1 \ -log(1-h_{\theta }(x))&amp; \text{ if } y=0 \end{cases}$$综合考虑所有训练数据的“损失”，将Cost求和或者求平均，记为J(θ)函数，表示所有训练数据预测值与实际类别的偏差。J(θ函数一般为：$$J(\theta ) = -\frac{1}{m}[\sum_{i=1}^{m}(y_{i}logh_{\theta }(x_{i})+(1-y_{i})log(1-h_{\theta }(x_{i})))]$$ 显然，J(θ)函数的值越小表示预测函数越准确（即h函数越准确），所以这一步需要做的是找到J(θ)函数的最小值。找函数的最小值有不同的方法，Logistic Regression实现时用的是梯度下降法（Gradient Descent）。&emsp;关于详细的公式推导就不介绍了 伪代码12345678初始化线性函数参数为1构造sigmoid函数重复循环I次 计算数据集梯度 更新线性函数参数确定最终的sigmoid函数输入训练（测试）数据集运用最终sigmoid函数求解分类 代码实现 逻辑回归的python代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import numpy as np from sklearn.metrics import accuracy_score class LogisticRegression: def __init__(self): """初始化Logistic Regression模型""" self.coef_ = None self.intercept_ = None self._theta = None def _sigmoid(self, t): return 1.0 / (1.0 + np.exp(-t)) def fit(self, X_train, y_train, eta=0.01, n_iters=1e4): """根据训练数据集X_train, y_train, 使用梯度下降法训练Logictic Regression模型""" assert X_train.shape[0] == y_train.shape[0], \ "the size of X_train must be equal to the size of y_train" def J(theta, X_b, y): y_hat = self._sigmoid(X_b.dot(theta)) try: return -np.sum(y*np.log(y_hat) + (1-y)*np.log(1-y_hat)) / len(y) except: return float('inf') '''逻辑回归''' def dJ(theta, X_b, y): return X_b.T.dot(self._sigmoid(X_b.dot(theta)) - y) / len(X_b) '''梯度下降法''' def gradient_descent(X_b, y, initial_theta, eta, n_iters=1e4, epsilon=1e-8): theta = initial_theta cur_iter = 0 while cur_iter &lt; n_iters: gradient = dJ(theta, X_b, y) last_theta = theta theta = theta - eta * gradient if (abs(J(theta, X_b, y) - J(last_theta, X_b, y)) &lt; epsilon): break cur_iter += 1 return theta X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) initial_theta = np.zeros(X_b.shape[1]) self._theta = gradient_descent(X_b, y_train, initial_theta, eta, n_iters) self.intercept_ = self._theta[0] self.coef_ = self._theta[1:] return self def predict_proba(self, X_predict): """给定待预测数据集X_predict，返回表示X_predict的结果概率向量""" assert self.intercept_ is not None and self.coef_ is not None, \ "must fit before predict!" assert X_predict.shape[1] == len(self.coef_), \ "the feature number of X_predict must be equal to X_train" X_b = np.hstack([np.ones((len(X_predict), 1)), X_predict]) return self._sigmoid(X_b.dot(self._theta)) def predict(self, X_predict): """给定待预测数据集X_predict，返回表示X_predict的结果向量""" assert self.intercept_ is not None and self.coef_ is not None, \ "must fit before predict!" assert X_predict.shape[1] == len(self.coef_), \ "the feature number of X_predict must be equal to X_train" proba = self.predict_proba(X_predict) return np.array(proba &gt;= 0.5, dtype='int') def score(self, X_test, y_test): """根据测试数据集 X_test 和 y_test 确定当前模型的准确度""" y_predict = self.predict(X_test) ''''分类的准确度''' return accuracy_score(y_test, y_predict) def __repr__(self): return "LogisticRegression() 上述结果为本次测试数据,可以看出来该数据集其实是三维的数据，因为逻辑回归只能解决二分类的问题，因此取数据集中的前两维数据，作为两种类别，因此使用该数据集可以用来判断逻辑回归测试结果的好坏 测试代码： 12345678from playML.model_selection import train_test_splitfrom playML.LogisticRegression import LogisticRegressionx_train, x_test, y_train, y_test = train_test_split(x, y, seed=666)log_reg = LogisticRegression()log_reg.fit(x_train, y_train)log_reg.score(x_test, y_test)log_reg.predict_proba(x_test) 输出的测试结果： 0.98664939, 0.14852024, 0.17601199, 0.0369836 ,0.0186637 , 0.04936918, 0.99669244, 0.97993941, 0.74524655,0.04473194, 0.00339285, 0.26131273, 0.0369836 , 0.84192923,0.79892262, 0.82890209, 0.32358166, 0.06535323, 0.20735334])```1234567891011121314151617 对于上述简单的测试数据，输出的array中的数据表示将某个数据分类成某一类别的概率，越接近于0就越趋近于分类成0这个类别，同理越趋近与1，就越趋近于分类成1，最后的分类的测试值输出为1.### 决策边界怎么对新输入的数据进行预测分类呢？ 每输入一个值&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&#123;_&#123;b&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&#123;_&#123;b&#125;&#125;&quot; title=&quot;x^&#123;_&#123;b&#125;&#125;&quot; /&gt;&lt;/a&gt;，与\theta ^&#123;T&#125;点乘，&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&#123;_&#123;b&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&#123;_&#123;b&#125;&#125;&quot; title=&quot;x^&#123;_&#123;b&#125;&#125;&quot; /&gt;&lt;/a&gt;·$\theta ^&#123;T&#125;$&gt;0，p&gt;0.5，&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&#123;_&#123;b&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&#123;_&#123;b&#125;&#125;&quot; title=&quot;x^&#123;_&#123;b&#125;&#125;&quot; /&gt;&lt;/a&gt;·$\theta ^&#123;T&#125;$&lt;0，p&lt;0.5,这样就能实类别的分类。当&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&#123;_&#123;b&#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&#123;_&#123;b&#125;&#125;&quot; title=&quot;x^&#123;_&#123;b&#125;&#125;&quot; /&gt;&lt;/a&gt;·$\theta ^&#123;T&#125;$=0就称为该分类的决策边界。 然后使用上面简单的数据集，绘制决策边界，其实也就是分类的边界，当有新的数据的时候骡子坳那边就分类为该类别。```pythondef x2(x1):return (-log_reg.coef_[0] * x1 - log_reg.intercept_) / log_reg.coef_[1]x1_plot = np.linspace(4, 8, 1000)x2_plot = x2(x1_plot)plt.scatter(x[y==0,0], x[y==0,1], color=&apos;red&apos;)plt.scatter(x[y==1,0], x[y==1,1], color=&apos;blue&apos;)plt.plot(x1_plot, x2_plot)plt.show() 得到的结果如下： 上述的决策边界是一条直线，所以不严格的说还是属于线性分类，当分类数据不线性的时候就需要不规则的决策边界。 举个例子使用KNN算法来对上述数据进行分类： 123456789from sklearn.neighbors import KNeighborsClassifierknn_clf = KNeighborsClassifier()knn_clf.fit(x_train, y_train)knn_clf.score(x_test, y_test)plot_decision_boundary(knn_clf, axis=[4, 7.5, 1.5, 4.5])plt.scatter(x[y==0,0], x[y==0,1])plt.scatter(x[y==1,0], x[y==1,1])plt.show() 结果如下： 可以看出通过使用KNN方法对上述数据的决策边界就是不规则的 因为KNN是支持多类别数据的分类的，然后我们的数据集也是3中类别的，所以测试下KNN在三分类中的分类的效果。 12345678knn_clf_all = KNeighborsClassifier()knn_clf_all.fit(iris.data[:,:2], iris.target)# 欠拟合plot_decision_boundary(knn_clf_all, axis=[4, 8, 1.5, 4.5])plt.scatter(iris.data[iris.target==0,0], iris.data[iris.target==0,1])plt.scatter(iris.data[iris.target==1,0], iris.data[iris.target==1,1])plt.scatter(iris.data[iris.target==2,0], iris.data[iris.target==2,1])plt.show() 得到的结果如下： 可以看出分类的结果是非常的不规则的，其实也就是应该是发生了过拟合的问题。 对于KNeighborsClassifier()这个函数其实其中有一个参数是可以调节的,就是n_neighbors这个参数，可以直接运行 knn_clf_all = KNeighborsClassifier()查看其中的参数，n_neighbors这个参数的含义其实就是分类的复杂程度，越小的话越复杂，就容易出现过拟合的问题。这里调节下这个参数看一下效果，设置knn_clf_all = KNeighborsClassifier(n_neighbors = 50)，其余代码相同 得到的结果如下: 明显能够看出来决策边界规则了许多，但是相应的分类效果弱了一些，所以调参，调参。 上面的数据集是可以线性分类的，当数据的类别线性不可分的时候，逻辑回归的方式怎么去处理呢？举个例子： 当数据集是这样的，显然线性不可分，决策边界是不规则类似于圆。其实这个时候就需要类似于使用多项式回归的方式来处理。给逻辑回归中添加多项式。 1234567891011121314151617181920212223242526272829303132333435363738from sklearn.pipeline import Pipelinefrom sklearn.preprocessing import PolynomialFeaturesfrom sklearn.preprocessing import StandardScalerfrom playML.LogisticRegression import LogisticRegressionlog_reg = LogisticRegression()def plot_decision_boundary(model, axis):x0, x1 = np.meshgrid(np.linspace(axis[0], axis[1], int((axis[1]-axis[0])*100)).reshape(-1,1),np.linspace(axis[2], axis[3], int((axis[3]-axis[2])*100)).reshape(-1,1))X_new = np.c_[x0.ravel(), x1.ravel()]y_predict = model.predict(X_new)zz = y_predict.reshape(x0.shape)from matplotlib.colors import ListedColormapcustom_cmap = ListedColormap(['#EF9A9A','#FFF59D','#90CAF9'])plt.contourf(x0, x1, zz, linewidth=5, cmap=custom_cmap)#多项式def PolynomialLogisticRegression(degree):return Pipeline([('poly', PolynomialFeatures(degree=degree)), #多项式参数('std_scaler', StandardScaler()), #标准化（归一化）('log_reg', LogisticRegression()) #逻辑回归对象])poly_log_reg = PolynomialLogisticRegression(degree=2)poly_log_reg.fit(X, y)plot_decision_boundary(poly_log_reg, [-4, 4, -4, 4])plt.scatter(X[y==0,0], X[y==0,1])plt.scatter(X[y==1,0], X[y==1,1])plt.show()print("准确度：" + str(poly_log_reg.score(X, y))) 得到如下的结果： 可以看出添加了多项式的逻辑回归可以解决非线性可分的问题。 逻辑回归中使用正则化处理过拟合的问题因为数据线性不可分的时候，需要在逻辑回归中引入多项式，这也使得分类变得复杂，容桂产生过拟合的问题，解决方法有两个，一个是调节degree参数，另一种就是正则化。通用的正则化的方式就是在J(θ)函数中加一个正则项，使用J(θ）+aL2作为新的损失函数。a用来调节J(θ)和L2各自所占比重。这里C·J(θ）+L1作为所示函数，其实C也是用来平衡J(θ)和L1，原理是一样的。L1和L2是正则化中的一个重要的参数。 1234567891011121314151617181920from sklearn.linear_model import LogisticRegressionfrom sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=666)def PolynomialLogisticRegression2(degree, C, penalty='l2'):return Pipeline([('poly', PolynomialFeatures(degree=degree)),('std_scaler', StandardScaler()),('log_reg', LogisticRegression(C=C, penalty=penalty))])poly_log_reg2 = PolynomialLogisticRegression2(degree=10, C=13, penalty='l1')poly_log_reg2.fit(X_train, y_train)plot_decision_boundary(poly_log_reg2, [-4, 4, -4, 4])plt.scatter(X[y==0,0], X[y==0,1])plt.scatter(X[y==1,0], X[y==1,1])plt.show() 说实话这里选取的数据集的代表性不太够，没有太突出正则化的优点，注重点在方法的实现上，但是还是能看出有一点区别的，决策边界更加清楚了。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习，逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之线性回归（Linear Regression）]]></title>
    <url>%2F2018%2F07%2F30%2FLinearRegression%2F</url>
    <content type="text"><![CDATA[线性回归概念线性回归(Linear Regression)是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。 回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。 其特点为： 解决回归问题 思想简单，实现容易 许多强大的非线性模型的基础 结果具有很好的可解释性 蕴含机器学习中的很多重要思想 简单线性回归的实现下面我们来举例何为一元线性回归分析: 首先假设有这样一组数据 从数据中我们可以看出，可以找到一条直线实现数据的拟合，这条直线设为 y=ax+b 那怎么计算a和b的参数，公式如下: jupyter notebook中具体的代码实现： 12345678910111213141516x_mean = np.mean(x)y_mean = np.mean(y)#分子num = 0.0#分母d = 0.0for x_i, y_i in zip(x, y):num += (x_i - x_mean) * (y_i - y_mean)d += (x_i - x_mean) ** 2a = num/db = y_mean - a*x_meany_hat = a*x + bplt.scatter(x,y)plt.plot(x,y_hat,color="r")plt.axis([0,6,0,6])plt.show() 得到了拟合数据的直线： 这里还可以在底层自己实现线性回归的算法，然后在jupyter notebook中调用，相应的pycharm的代码为： import numpy as np from sklearn.metrics import r2_score class LinearRegression: def __init__(self): &quot;&quot;&quot;初始化Linear Regression模型&quot;&quot;&quot; self.coef_ = None self.intercept_ = None self._theta = None def fit_normal(self, X_train, y_train): &quot;&quot;&quot;根据训练数据集X_train, y_train训练Linear Regression模型&quot;&quot;&quot; assert X_train.shape[0] == y_train.shape[0], \ &quot;the size of X_train must be equal to the size of y_train&quot; X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) self._theta = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y_train) self.intercept_ = self._theta[0] self.coef_ = self._theta[1:] return self def fit_gd(self, X_train, y_train, eta=0.01, n_iters=1e4): &quot;&quot;&quot;根据训练数据集X_train, y_train, 使用梯度下降法训练Linear Regression模型&quot;&quot;&quot; assert X_train.shape[0] == y_train.shape[0], \ &quot;the size of X_train must be equal to the size of y_train&quot; def J(theta, X_b, y): try: return np.sum((y - X_b.dot(theta)) ** 2) / len(y) except: return float(&apos;inf&apos;) def dJ(theta, X_b, y): # res = np.empty(len(theta)) # res[0] = np.sum(X_b.dot(theta) - y) # for i in range(1, len(theta)): # res[i] = (X_b.dot(theta) - y).dot(X_b[:, i]) # return res * 2 / len(X_b) return X_b.T.dot(X_b.dot(theta) - y) * 2. / len(X_b) def gradient_descent(X_b, y, initial_theta, eta, n_iters=1e4, epsilon=1e-8): theta = initial_theta cur_iter = 0 while cur_iter &lt; n_iters: gradient = dJ(theta, X_b, y) last_theta = theta theta = theta - eta * gradient if (abs(J(theta, X_b, y) - J(last_theta, X_b, y)) &lt; epsilon): break cur_iter += 1 return theta X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) initial_theta = np.zeros(X_b.shape[1]) self._theta = gradient_descent(X_b, y_train, initial_theta, eta, n_iters) self.intercept_ = self._theta[0] self.coef_ = self._theta[1:] return self def fit_sgd(self, X_train, y_train, n_iters=5, t0=5, t1=50): &quot;&quot;&quot;根据训练数据集X_train, y_train, 使用梯度下降法训练Linear Regression模型&quot;&quot;&quot; assert X_train.shape[0] == y_train.shape[0], \ &quot;the size of X_train must be equal to the size of y_train&quot; assert n_iters &gt;= 1 def dJ_sgd(theta, X_b_i, y_i): return X_b_i * (X_b_i.dot(theta) - y_i) * 2. def sgd(X_b, y, initial_theta, n_iters, t0=5, t1=50): def learning_rate(t): return t0 / (t + t1) theta = initial_theta m = len(X_b) for cur_iter in range(n_iters): indexes = np.random.permutation(m) X_b_new = X_b[indexes] y_new = y[indexes] for i in range(m): gradient = dJ_sgd(theta, X_b_new[i], y_new[i]) theta = theta - learning_rate(cur_iter * m + i) * gradient return theta X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) initial_theta = np.random.randn(X_b.shape[1]) self._theta = sgd(X_b, y_train, initial_theta, n_iters, t0, t1) self.intercept_ = self._theta[0] self.coef_ = self._theta[1:] return self def predict(self, X_predict): &quot;&quot;&quot;给定待预测数据集X_predict，返回表示X_predict的结果向量&quot;&quot;&quot; assert self.intercept_ is not None and self.coef_ is not None, \ &quot;must fit before predict!&quot; assert X_predict.shape[1] == len(self.coef_), \ &quot;the feature number of X_predict must be equal to X_train&quot; X_b = np.hstack([np.ones((len(X_predict), 1)), X_predict]) return X_b.dot(self._theta) def score(self, X_test, y_test): &quot;&quot;&quot;根据测试数据集 X_test 和 y_test 确定当前模型的准确度&quot;&quot;&quot; y_predict = self.predict(X_test) return r2_score(y_test, y_predict) def __repr__(self): return &quot;LinearRegression()&quot; ​ 这里其实就是一个简单的一元数据的一个简答线性回归算法。 线性回归评价指标那怎么去评价线性回归算法的指标的好坏呢？ 常用得三个指标：均方误差MSE、均方根误差RMSE、平均绝对误差MAE，这三类算法具体公式这些就不再赘述了，这三类指标都存在一个局限性：作用域的使用范围，对不同事物的预测缺乏统一标准，这样就引出了新的一个预测指标R Squared，其实就是R^2,关于R^2的解释如下： 从上面的图中我们到关于R^2的公式，公式中上面分子就是我们训练出的模型预测的所有误差。 下面分母就是 不管什么我们猜的结果就是y的平均数。（其实也就是我们瞎猜的误差） 那具体实现下这些评价指标，首先换一个数据集，上面是我们自己构造的的太简单了， 导入sklearn中的datasets 123456789101112131415161718192021222324252627282930313233import numpy as npimport matplotlib.pyplot as pltfrom sklearn import datasetsfrom sklearn.model_selection import train_test_splitfrom sklearn.metrics import mean_squared_error, mean_absolute_errorboston = datasets.load_boston()x = boston.data[:,5]y = boston.targetx = x[y&lt;50.0]y = y[y&lt;50.0]plt.scatter(x, y)plt.show()# 划分训练集和测试集x_train, x_test, y_train, y_test = train_test_split(x,y,test_size=0.2)# 简单线性规划x_mean = np.mean(x_train)y_mean = np.mean(y_train)# 分子num = 0.0# 分母d = 0.0for x_i, y_i in zip(x_train, y_train):num += (x_i - x_mean) * (y_i - y_mean)d += (x_i - x_mean) ** 2a = num/db = y_mean - a*x_meany_hat = a*x_train + b # 回归函数plt.scatter(x_train, y_train)plt.plot(x_train, y_hat, color="r")plt.show() y_predict = a*x_test + b mse = mean_squared_error(y_test, y_predict) mae = mean_absolute_error(y_test, y_predict) print(&quot;均方误差为：&quot; + str(mse)) print(&quot;平均绝对误差为：&quot; + str(mae)) rs = 1 - mse/np.var(y_test) print(&quot;R Square = &quot; + str(rs)) 这样我们就得到了所有的评价指标。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习，线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之梯度下降法(GradientDescent)]]></title>
    <url>%2F2018%2F07%2F29%2FGradientDescent%2F</url>
    <content type="text"><![CDATA[梯度下降法概念梯度下降法是迭代法的一种,其实它不是一种具体的机器学习算法，是一种基于搜索的最优化方法，可以用于求解最小二乘问题(线性和非线性都可以)。在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法。在求解损失函数的最小值时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数和模型参数值。相应的还有一个梯度上升法，它的作用是最大化一个效用函数。 ​ 用一个图来表示梯度下降法： 怎么理解呢？梯度其实是在在多维空间中的概念，在二维的平面上其实就是导数，梯度表示的就是方向，通过求某一个点的梯度，我们就可以知道J(损失函数)增大的方向，然后乘-η就可以找到J(损失函数)减小的方向，不断地求J的导数，直到其变为0，这样就找到J的最小值点。这里的η称为学习率，η的取值影响获得最优解的速度，η取值太小的时候学习速度收敛太慢，η太大有可能直接跳过最小值点然后导致不收敛。 有可能在某一次取值的过程中找到的是局部最优解，而不是全局最优解。这个时候怎么解决呢？多次运行，随机化初始点，这样的话增加了找到全局最优解的概率。 模拟实现梯度下降法jupyter notebook中实现： 123456789101112131415161718192021222324252627282930313233343536import numpy as npimport matplotlib.pyplot as plt#datasetsx = np.linspace(-1, 6 ,141)y = (x-2.5)**2-1# 求导数def dJ(theta):return 2*(theta - 2.5)# 损失函数def J(theta):return (theta - 2.5)**2-1# 梯度下降法theta = 0.0eta = 0.1#误差精度epsilon = 1e-8theta_history = [theta]while True:gradient = dJ(theta)last_theta = thetatheta = theta - eta * gradienttheta_history.append(theta)if(abs(J(theta) - J(last_theta)) &lt; epsilon):breakplt.plot(x, y)plt.plot(np.array(theta_history), J(np.array(theta_history)), color='R', marker = 'o')plt.xlabel("theta")plt.ylabel("J")plt.show()print("theta = " + str(theta))print("J(theta) = " + str(J(theta))) 得到的结果如下： 然后我们上面讨论过，η取值太小的时候学习速度收敛太慢，η太大有可能直接跳过最小值点然后导致不收敛。下面测试一下。先取η=0.01 我们可以看出梯度下降的速度变慢了 然后取η=1 当η&gt;1的时候编译器就自动报错，但是这里只是针对这里定义的这个函数，并不是意味着η=1就是极限值，针对不同的函数有不同的取值。 多元线性回归中使用批量梯度下降线性回归中使用梯度下降法，其目标是使得$$\sum_{i=1}^{m}(y^i-\hat{y}^i)^2$$尽可能小，而且线性回归算法的损失函数是具有唯一解的。 其中$$\hat{y}^{i} = \theta _{0} + \theta _{1}X_{1}^{i}+…++ \theta _{n}X_{n}^{i}$$带入因此线性回归中梯度下降的目标就成为了$$\sum_{i=1}^{m}(y^i - \theta _{0} + \theta _{1}X_{1}^{i}+…++ \theta _{n}X_{n}^{i})$$使得其尽可能小。那梯度怎么去求呢？如下： 批量梯度下降法具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445import numpy as npimport matplotlib.pyplot as pltnp.random.seed(666)x = 2 * np.random.random(size = 100)y = x * 3.0 + 4.0 + np.random.normal(size = 100)X = x.reshape(-1, 1)#损失函数def J(theta, X_b, y):try:return np.sum((y - X_b.dot(theta))**2)/len(X_b)except:return float(&apos;inf&apos;)#损失函数的梯度def dJ(theta, X_b, y):res = np.empty(len(theta))res[0] = np.sum(X_b.dot(theta) - y)for i in range(1, len(theta)):res[i] = (X_b.dot(theta) - y).dot(X_b[:,i])return res *2 /len(X_b)#梯度下降法def gradient_descent(X_b, y, initial_thata, eta, n_iters = 1e4, epsilon = 1e-8):theta = initial_thetai_iter = 0while i_iter &lt; n_iters:# n_iters是最大循环次数gradient = dJ(theta, X_b, y)last_theta = thetatheta = theta - eta * gradientif(abs(J(theta, X_b, y) - J(last_theta, X_b, y)) &lt; epsilon):breaki_iter += 1return thetaX_b = np.hstack([np.ones((len(x), 1)), x.reshape(-1, 1)])initial_theta = np.zeros(X_b.shape[1])eta = 0.01theta = gradient_descent(X_b, y, initial_theta, eta) 12345plt.scatter(x, y)Y = X_b.dot(theta)plt.plot(x, Y, color="red")plt.show()print("theta = " + str(theta)) 得到的结果 在初始化数据的时候，斜率设为3，截距为4，然后我们训练出的结果theta与两值接近，证明训练的模型是准确的：y = x * 3.0 + 4.0 + np.random.normal(size = 100) 随机梯度下降法上面我们用的是批量梯度下降法，这种方法有一个缺点，就是每一项都需要对所有的样本点进行计算，数据量少的时候还可以，但是数据量很大的时候就显得很鸡肋了，计算非常的耗资源。能不能每一次计算的时候只对其中的一个样本进行计算呢？这就衍生出了随机梯度下降法。 即每读取一条样本，就迭代对Θ进行更新，然后判断其是否收敛，若没收敛，则继续读取样本进行处理，如果所有样本都读取完毕了，则循环重新从头开始读取样本进行处理。但是，相较于批量梯度下降算法而言，随机梯度下降算法使得J(Θ)趋近于最小值的速度更快，但是有可能造成永远不可能收敛于最小值，有可能一直会在最小值周围震荡，但是实践中，大部分值都能够接近于最小值，所以当数据量很大的时候可以用精度来换取时间。 在随机梯度下降法中为了得到更高的收敛结果，学习率是要随着循环次数的增加而逐渐的减小。这是因为在学习的过程中要是学习率是一个固定值，但是可能由于随机的过程不够好，eta有是一个固定值，那么在学习的过程中随机梯度下降法接近最优解的时候又会慢慢的跳出最优解的范围。气质学习率随着循环次数的增加而逐渐的减小这种思想是模拟退火的思想，去搜了下模拟退火，下面写下自己的理解。 模拟退火算法拟退火其实也是一种贪心算法，但是它的搜索过程引入了随机因素。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。模拟退火算法描述： 想象一个高温物体的降温过程。其温度为T时出现能量差为dE的降温概率为P(dE) = e ^ ( -dE / (k * T) ) 。其实就是温度越高降温的概率越大，温度越低降温概率越小。而模拟退火就是利用这样一种思想去进行搜索。那么在进行搜索的时候首先定义一个初始值( 温度 ) T , 一个系数 r ( 降温速度 0 \&lt; r \&lt; 1 ) , 假设你当前状态为 f i , 你的下一个状态为 f i +1 , 对这两个状态进行评价，如果更接近你想要的结果，就更新到这个状态，否则则以 P ( dE ) 的概率去更新到 这个状态，但是其实在实际题目中，这个概率是不必要的，这一步有时是可以忽略掉的。我们可以想象，随着搜索次数的不断增多，搜索范围将越来越趋近于稳定，也就是随着时间的增长温度降低的概率越来越低，直到趋近于1。对应搜索就是随着你搜索的次数越多，你搜索到的值是你想要的值的概率就越大。 然后结合模拟退火的思想，在随机梯度下降法中设置学习率为: 然后结合模拟退火的思想，在随机梯度下降法中设置学习率为:$$\eta = \frac{a}{i_iters + b}$$其中i_iters是循环次数，a,b是两个经验参数，根据实际情况设置。 看完了梯度下降法，其优缺点如下： 第一种，遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，更新梯度。这种方法每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢，不支持在线学习，其实这就是批量梯度下降。 其中i_iters是循环次数，a,b是两个经验参数，根据实际情况设置。 看完了梯度下降法，其优缺点如下： 第一种，遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，更新梯度。这种方法每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢，不支持在线学习，其实这就是批量梯度下降。 其中i_iters是循环次数，a,b是两个经验参数，根据实际情况设置。看完了梯度下降法，其优缺点如下：第一种，遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，更新梯度。这种方法每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢，不支持在线学习，其实这就是批量梯度下降。 另一种，每看一个数据就算一下损失函数，然后求梯度更新参数，这个其实也就是随机梯度下降，这个方法速度比较快，但是收敛性能不太好，可能在最优点附近晃来晃去，找不到不到最优点。两次参数的更新也有可能互相抵消掉，造成目标函数震荡的比较剧烈。 为了克服两种方法的缺点，现在一般采用的是一种折中手段，小批的梯度下降，这种方法把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。 另一种，每看一个数据就算一下损失函数，然后求梯度更新参数，这个其实也就是随机梯度下降，这个方法速度比较快，但是收敛性能不太好，可能在最优点附近晃来晃去，找不到不到最优点。两次参数的更新也有可能互相抵消掉，造成目标函数震荡的比较剧烈。为了克服两种方法的缺点，现在一般采用的是一种折中手段，小批的梯度下降，这种方法把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。 为了克服两种方法的缺点，现在一般采用的是一种折中手段，小批的梯度下降，这种方法把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。 随机梯度下降法实现1234567891011121314151617181920212223242526272829303132333435import numpy as npimport matplotlib.pyplot as pltm = 100000x = np.random.normal(size = m)X = x.reshape(-1, 1)y = 4.0 * x + 3.0 + np.random.normal(0 ,3, size = m)def J(theta, X_b, y):try:return np.sum((y - X_b.dot(theta))**2) / len(y)except:return float(&apos;inf&apos;)def dJ_sgd(theta, X_b_i, y_i):return X_b_i.T.dot(X_b_i.dot(theta) - y_i) * 2.0 def sgd(X_b, y, initial_theta, n_iters):t0 = 5t1 = 50def learning_rate(t):return t0 / (t + t1)theta = initial_thetafor cur_iter in range(n_iters):rand_i = np.random.randint(len(X_b))gradient = dJ_sgd(theta, X_b[rand_i], y[rand_i])theta = theta - learning_rate(cur_iter) * gradientreturn thetaX_b = np.hstack([np.ones((len(X), 1)), X])initial_theta = np.zeros(X_b.shape[1])theta = sgd(X_b, y, initial_theta, n_iters = len(X_b)//3)print(&quot;theta = &quot; + str(theta)) 输出的theta = [3.00887864 4.05589554]，与设置的数据相接近。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习，梯度下降，python3，jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈哈哈，终于把博客搭建起来啦]]></title>
    <url>%2F2018%2F06%2F21%2Ffirst-blog%2F</url>
    <content type="text"><![CDATA[用来几个小时的时间，算是完成了简单的搭建，果然在学习的过程中才是最开心的。为什么要跑到这里搭建博客呢？嗯。。。。 毕竟是要常年混迹在全球最大的同性交友社区了，把博客搭起来写写项目开发经历，记录下自己开踩过的坑，还是很重要的。 希望路能越走越顺吧。啦啦啦……..]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
